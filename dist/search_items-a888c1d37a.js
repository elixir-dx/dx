searchNodes=[{"doc":"This is the main entry for using the Dx API. get/3 evaluates the given predicate(s) using only the (pre)loaded data available, and returns the result(s) load/3 is like get , but loads any additional data as needed put/3 is like load , but puts the results into the :inferred field (or virtual schema field) of the subject(s) as a map, and returns the subject(s) These functions return a tuple, either {:ok, result} , {:error, error} , or {:not_loaded, data_reqs} (only get ). The corresponding get!/3 , load!/3 and put!/3 functions return result directly, or otherwise raise an exception. Arguments: subjects can either be an individual subject (with the given predicates defined on it), or a list of subjects. Passing an individual subject will return the predicates for the subject, passing a list will return a list of them. predicates can either be a single predicate, or a list of predicates. Passing a single predicate will return the resulting value, passing a list will return a map of the predicates and their resulting values. options (optional) See below. Options: args (list or map) can be used to pass in data from the caller's context that can be used in rules (see Arguments below). A classic example is the current_user , e.g. put! ( project , :can_edit? , args : [ user : current_user ] ) extra_rules (module or list of modules) can be used to add context-specific rules that are not defined directly on the subject. This can be used to structure rules into their own modules and use them only where needed. debug (boolean) makes Dx print additional information to the console as rules are evaluated. Should only be used while debugging. return_cache (boolean) makes non-bang functions return {:ok, result, cache} instead of {:ok, result} on success. This cache can be passed to other Dx functions (see cache option) cache ( Dataloader struct) can be used to pass in an existing cache, so data already loaded doesn't need to be loaded again. Can be initialized using Dx.Loaders.Dataloader.init/1 . loader allows choosing a loader module. Defaults to Dx.Loaders.Dataloader . loader_options are passed to loader.init/1 function. See Dx.Loaders.Dataloader for options supported by the default loader.","ref":"Dx.html","title":"Dx","type":"module"},{"doc":"Removes all elements not matching the given condition from the given list.","ref":"Dx.html#filter/3","title":"Dx.filter/3","type":"function"},{"doc":"Like get/3 but returns the result value, or raises an error.","ref":"Dx.html#get!/3","title":"Dx.get!/3","type":"function"},{"doc":"Evaluates one or multiple predicates for one or multiple records and returns the results. Does not load any additional data.","ref":"Dx.html#get/3","title":"Dx.get/3","type":"function"},{"doc":"Like get!/3 , but loads additional data if needed.","ref":"Dx.html#load!/3","title":"Dx.load!/3","type":"function"},{"doc":"Like get/3 , but loads additional data if needed.","ref":"Dx.html#load/3","title":"Dx.load/3","type":"function"},{"doc":"","ref":"Dx.html#put!/3","title":"Dx.put!/3","type":"function"},{"doc":"Loads the given predicate(s) for the given record(s) and merges the results into the inferred map field of the record(s), returning them. Options Same as for get/3 .","ref":"Dx.html#put/3","title":"Dx.put/3","type":"function"},{"doc":"Returns all records matching the given condition. Caveat In general, as much work as possible is done in the database. If possible, the condition is completely translated to an Ecto.Query so the database only returns matching records. All condition parts that can not be translated to an Ecto.Query , will be evaluated by loading all remaining records , and associations as needed, and evaluating the rules on them.","ref":"Dx.html#query_all/3","title":"Dx.query_all/3","type":"function"},{"doc":"Returns the first record matching the given condition. Options Same as for query_all/3 .","ref":"Dx.html#query_one/3","title":"Dx.query_one/3","type":"function"},{"doc":"Removes all elements matching the given condition from the given list.","ref":"Dx.html#reject/3","title":"Dx.reject/3","type":"function"},{"doc":"Functions to dynamically generate Ecto query parts.","ref":"Dx.Ecto.Query.html","title":"Dx.Ecto.Query","type":"module"},{"doc":"Returns a 2-tuple with the modified queryable with the given conditions applied as WHERE clauses any remaining conditions that couldn't be added to the query Returns {query, true} if all conditions could be added to the query.","ref":"Dx.Ecto.Query.html#apply_condition/3","title":"Dx.Ecto.Query.apply_condition/3","type":"function"},{"doc":"Applies all known options to the given queryable and returns it, along with all options that were unknown.","ref":"Dx.Ecto.Query.html#apply_options/2","title":"Dx.Ecto.Query.apply_options/2","type":"function"},{"doc":"Apply all options to the given queryable , raise on any unknown option.","ref":"Dx.Ecto.Query.html#from_options/2","title":"Dx.Ecto.Query.from_options/2","type":"function"},{"doc":"","ref":"Dx.Ecto.Query.html#inspect/2","title":"Dx.Ecto.Query.inspect/2","type":"function"},{"doc":"","ref":"Dx.Ecto.Query.html#is_simple/1","title":"Dx.Ecto.Query.is_simple/1","type":"macro"},{"doc":"","ref":"Dx.Ecto.Query.html#limit/2","title":"Dx.Ecto.Query.limit/2","type":"function"},{"doc":"","ref":"Dx.Ecto.Query.html#order_by/2","title":"Dx.Ecto.Query.order_by/2","type":"function"},{"doc":"Returns generated SQL for given query with all params replaced","ref":"Dx.Ecto.Query.html#to_sql/2","title":"Dx.Ecto.Query.to_sql/2","type":"function"},{"doc":"Add predicate-based filters to a queryable and return it.","ref":"Dx.Ecto.Query.html#where/3","title":"Dx.Ecto.Query.where/3","type":"function"},{"doc":"Internal data structure to keep track of all context needed to translate complex Dx rules to Ecto queries. Context switches Evaluate rule on other subject Can not access existing aliases Reset path Keep only next alias index Subquery (EXISTS) Can access existing aliases &amp; path Mark existing aliases &amp; path entries as :parent Add alias &amp; path entry Join Can access existing aliases &amp; path Add alias &amp; path entry","ref":"Dx.Ecto.Query.Builder.html","title":"Dx.Ecto.Query.Builder","type":"module"},{"doc":"","ref":"Dx.Ecto.Query.Builder.html#add_aliased/1","title":"Dx.Ecto.Query.Builder.add_aliased/1","type":"function"},{"doc":"","ref":"Dx.Ecto.Query.Builder.html#add_aliased_join/2","title":"Dx.Ecto.Query.Builder.add_aliased_join/2","type":"function"},{"doc":"","ref":"Dx.Ecto.Query.Builder.html#current_alias/1","title":"Dx.Ecto.Query.Builder.current_alias/1","type":"function"},{"doc":"","ref":"Dx.Ecto.Query.Builder.html#current_type/1","title":"Dx.Ecto.Query.Builder.current_type/1","type":"function"},{"doc":"","ref":"Dx.Ecto.Query.Builder.html#field/3","title":"Dx.Ecto.Query.Builder.field/3","type":"function"},{"doc":"","ref":"Dx.Ecto.Query.Builder.html#from_root/2","title":"Dx.Ecto.Query.Builder.from_root/2","type":"function"},{"doc":"","ref":"Dx.Ecto.Query.Builder.html#init/2","title":"Dx.Ecto.Query.Builder.init/2","type":"function"},{"doc":"","ref":"Dx.Ecto.Query.Builder.html#negate/2","title":"Dx.Ecto.Query.Builder.negate/2","type":"function"},{"doc":"","ref":"Dx.Ecto.Query.Builder.html#root_alias/1","title":"Dx.Ecto.Query.Builder.root_alias/1","type":"function"},{"doc":"","ref":"Dx.Ecto.Query.Builder.html#root_type/1","title":"Dx.Ecto.Query.Builder.root_type/1","type":"function"},{"doc":"","ref":"Dx.Ecto.Query.Builder.html#step_into/4","title":"Dx.Ecto.Query.Builder.step_into/4","type":"function"},{"doc":"","ref":"Dx.Ecto.Query.Builder.html#with_join/3","title":"Dx.Ecto.Query.Builder.with_join/3","type":"function"},{"doc":"","ref":"Dx.Ecto.Query.Builder.html#t:mapped_alias/0","title":"Dx.Ecto.Query.Builder.mapped_alias/0","type":"type"},{"doc":"","ref":"Dx.Ecto.Query.Builder.html#t:t/0","title":"Dx.Ecto.Query.Builder.t/0","type":"type"},{"doc":"See Dx .","ref":"Dx.Ecto.Schema.html","title":"Dx.Ecto.Schema","type":"module"},{"doc":"Encapsulates the main functionality of working with rules.","ref":"Dx.Engine.html","title":"Dx.Engine","type":"module"},{"doc":"","ref":"Dx.Engine.html#evaluate_condition/3","title":"Dx.Engine.evaluate_condition/3","type":"function"},{"doc":"Traverses the value of a rule, replacing special tuples {:ref, path} with the predicate or field value found at the given path {fun/n, arg_1, ..., arg_n} with the result of calling the given function with the given arguments (which in turn can be special tuples) {:bound, :var} - with a corresponding matching {:bind, :var} {:bound, :var, default} - same with default ...","ref":"Dx.Engine.html#map_result/2","title":"Dx.Engine.map_result/2","type":"function"},{"doc":"Returns the result of evaluating a field or predicate.","ref":"Dx.Engine.html#resolve/3","title":"Dx.Engine.resolve/3","type":"function"},{"doc":"Returns the result of evaluating a predicate.","ref":"Dx.Engine.html#resolve_predicate/3","title":"Dx.Engine.resolve_predicate/3","type":"function"},{"doc":"","ref":"Dx.Engine.html#resolve_source/2","title":"Dx.Engine.resolve_source/2","type":"function"},{"doc":"Represents an evaluation run in Dx.Engine according to the token pattern in Elixir.","ref":"Dx.Evaluation.html","title":"Dx.Evaluation","type":"module"},{"doc":"","ref":"Dx.Evaluation.html#add_options/2","title":"Dx.Evaluation.add_options/2","type":"function"},{"doc":"","ref":"Dx.Evaluation.html#from_options/1","title":"Dx.Evaluation.from_options/1","type":"function"},{"doc":"Loads the given data requirements in an evaluation, and returns it updated.","ref":"Dx.Evaluation.html#load_data_reqs/2","title":"Dx.Evaluation.load_data_reqs/2","type":"function"},{"doc":"","ref":"Dx.Evaluation.html#t:t/0","title":"Dx.Evaluation.t/0","type":"type"},{"doc":"Uses Dataloader to load missing data incrementally. Supported options These options are passed to Dataloader.Ecto.new/2 : timeout Timeout in milliseconds for Dataloader to wait for all data to be loaded. Defaults to 15_000. repo_options Options passed to the Ecto.Repo when loading data. Defaults to [] .","ref":"Dx.Loaders.Dataloader.html","title":"Dx.Loaders.Dataloader","type":"module"},{"doc":"","ref":"Dx.Loaders.Dataloader.html#config/1","title":"Dx.Loaders.Dataloader.config/1","type":"function"},{"doc":"","ref":"Dx.Loaders.Dataloader.html#init/1","title":"Dx.Loaders.Dataloader.init/1","type":"function"},{"doc":"","ref":"Dx.Loaders.Dataloader.html#load/2","title":"Dx.Loaders.Dataloader.load/2","type":"function"},{"doc":"","ref":"Dx.Loaders.Dataloader.html#lookup/2","title":"Dx.Loaders.Dataloader.lookup/2","type":"function"},{"doc":"Receives the module attributes created by the macros in Dx.DSL and converts them into normalized aliases and lists of Dx.Rule structs.","ref":"Dx.Parser.html","title":"Dx.Parser","type":"module"},{"doc":"","ref":"Dx.Parser.html#directive_to_rules/2","title":"Dx.Parser.directive_to_rules/2","type":"function"},{"doc":"","ref":"Dx.Parser.html#normalize_aliases/1","title":"Dx.Parser.normalize_aliases/1","type":"function"},{"doc":"Entry point for this module","ref":"Dx.Parser.html#parse/2","title":"Dx.Parser.parse/2","type":"function"},{"doc":"","ref":"Dx.Parser.Token.html","title":"Dx.Parser.Token","type":"module"},{"doc":"Encapsulates all static args to be passed around between functions.","ref":"Dx.Parser.Token.html#__struct__/0","title":"Dx.Parser.Token.__struct__/0","type":"function"},{"doc":"","ref":"Dx.Parser.Token.html#set_aliases/2","title":"Dx.Parser.Token.set_aliases/2","type":"function"},{"doc":"","ref":"Dx.Parser.Token.html#with_opts/2","title":"Dx.Parser.Token.with_opts/2","type":"function"},{"doc":"","ref":"Dx.Parser.Token.html#t:t/0","title":"Dx.Parser.Token.t/0","type":"type"},{"doc":"Result types and helpers to work with them. A result is either: {:error, e} if an error occurred {:not_loaded, data_reqs} if the result could not be determined without loading more data {:ok, boolean, binds} otherwise, in contexts where a boolean is expected (type t:b() ) {:ok, result, binds} otherwise, where result can be any value (type t:v() ) Data loading In general, {:not_loaded, all_reqs} only ever returns data requirements that are really needed. Example using all For example, using all?/1 with 3 conditions A, B and C, where iex&gt; [ ...&gt; { :ok , true , %{ } } , # A ...&gt; { :not_loaded , [ 1 ] } , # B ...&gt; { :ok , false , %{ } } , # C ...&gt; ] ...&gt; |&gt; Dx.Result . all? ( ) { :ok , false , %{ } } The overall result is {:ok, false, %{}} . While B would need more data to be loaded, C can already determined and is false , so and any additional data loaded will not change that. Example using find Another example, using find/1 with 5 conditions A, B, C, D and E, where iex&gt; [ ...&gt; { :ok , false , %{ } } , # A ...&gt; { :not_loaded , [ 1 ] } , # B ...&gt; { :not_loaded , [ 2 ] } , # C ...&gt; { :ok , true , %{ } } , # D ...&gt; { :not_loaded , [ 3 ] } , # E ...&gt; ] ...&gt; |&gt; Dx.Result . find ( ) { :not_loaded , [ 1 , 2 ] } The overall result is {:not_loaded, data_reqs1 + data_reqs2} . While D can already be determined and is {:ok, true, %{}} , B and C come first and need more data to be loaded, so they can be determined and returned if either is {:ok, true, %{}} first. All data requirements that might be needed are returned together in the result (those of B and C), while those of E can be ruled out, as D already returns {:ok, true, %{}} and comes first.","ref":"Dx.Result.html","title":"Dx.Result","type":"module"},{"doc":"Returns {:ok, true} if fun evaluates to {:ok, true} for all elements in enum . Otherwise, returns {:not_loaded, data_reqs} if any yield that. Otherwise, returns {:ok, false} . Examples iex&gt; [ ...&gt; { :ok , true , %{ } } , ...&gt; { :not_loaded , [ ] } , ...&gt; { :ok , false , %{ } } , ...&gt; ] ...&gt; |&gt; Dx.Result . all? ( ) { :ok , false , %{ } } iex&gt; [ ...&gt; { :ok , true , %{ } } , ...&gt; { :not_loaded , [ ] } , ...&gt; { :ok , true , %{ } } , ...&gt; ] ...&gt; |&gt; Dx.Result . all? ( ) { :not_loaded , [ ] } iex&gt; [ ...&gt; { :ok , true , %{ } } , ...&gt; { :ok , true , %{ } } , ...&gt; ] ...&gt; |&gt; Dx.Result . all? ( ) { :ok , true , %{ } }","ref":"Dx.Result.html#all?/2","title":"Dx.Result.all?/2","type":"function"},{"doc":"Returns {:ok, true, binds} if fun evaluates to {:ok, true, binds} for any element in enum . Otherwise, returns {:not_loaded, data_reqs} if any yields that. Otherwise, returns {:ok, false, %{}} . Examples iex&gt; [ ...&gt; { :ok , true , %{ a : 1 } } , ...&gt; { :not_loaded , [ ] } , ...&gt; { :ok , false , %{ } } , ...&gt; ] ...&gt; |&gt; Dx.Result . any? ( ) { :ok , true , %{ a : 1 } } iex&gt; [ ...&gt; { :ok , false , %{ } } , ...&gt; { :not_loaded , [ ] } , ...&gt; { :ok , false , %{ } } , ...&gt; ] ...&gt; |&gt; Dx.Result . any? ( ) { :not_loaded , [ ] } iex&gt; [ ...&gt; { :ok , false , %{ } } , ...&gt; { :ok , false , %{ } } , ...&gt; ] ...&gt; |&gt; Dx.Result . any? ( ) { :ok , false , %{ } }","ref":"Dx.Result.html#any?/2","title":"Dx.Result.any?/2","type":"function"},{"doc":"If ok, binds the result to the given key and returns the updated tuple. Otherwise, returns first argument as is.","ref":"Dx.Result.html#bind/3","title":"Dx.Result.bind/3","type":"function"},{"doc":"Returns the number of elements for which fun evaluates to {:ok, true} . If any elements return {:not_loaded, data_reqs} , returns all of them combined as {:not_loaded, ...} . Otherwise, returns {:ok, default} . Examples iex&gt; [ ...&gt; { :ok , true , %{ } } , ...&gt; { :ok , false , %{ } } , ...&gt; { :ok , true , %{ } } , ...&gt; ] ...&gt; |&gt; Dx.Result . count ( ) { :ok , 2 , %{ } } iex&gt; [ ...&gt; { :ok , false , %{ } } , ...&gt; { :not_loaded , [ 1 ] } , ...&gt; { :not_loaded , [ 2 ] } , ...&gt; { :ok , true , %{ } } , ...&gt; { :not_loaded , [ 3 ] } , ...&gt; ] ...&gt; |&gt; Dx.Result . count ( ) { :not_loaded , [ 1 , 2 , 3 ] } iex&gt; [ ...&gt; { :ok , true , %{ } } , ...&gt; { :ok , :skip , %{ } } , ...&gt; { :ok , false , %{ } } , ...&gt; { :ok , false , %{ } } , ...&gt; ] ...&gt; |&gt; Dx.Result . count ( ) { :ok , 1 , %{ } } iex&gt; [ ...&gt; false , ...&gt; false , ...&gt; ] ...&gt; |&gt; Dx.Result . count ( &amp; { :ok , not &amp;1 , %{ } } ) { :ok , 2 , %{ } }","ref":"Dx.Result.html#count/2","title":"Dx.Result.count/2","type":"function"},{"doc":"Returns the number of elements before fun evaluates to {:ok, false} or an element is nil . Elements are skipped (not counted) whenever fun evaluates to {:ok, :skip} . If any elements before that return {:not_loaded, data_reqs} , returns all of them combined as {:not_loaded, ...} . Otherwise, returns {:ok, default} . Examples iex&gt; [ ...&gt; { :ok , true , %{ } } , ...&gt; { :not_loaded , [ ] } , ...&gt; { :ok , false , %{ } } , ...&gt; ] ...&gt; |&gt; Dx.Result . count_while ( ) { :not_loaded , [ ] } iex&gt; [ ...&gt; { :ok , false , %{ } } , ...&gt; { :not_loaded , [ 1 ] } , ...&gt; { :not_loaded , [ 2 ] } , ...&gt; { :ok , true , %{ } } , ...&gt; { :not_loaded , [ 3 ] } , ...&gt; ] ...&gt; |&gt; Dx.Result . count_while ( ) { :ok , 0 , %{ } } iex&gt; [ ...&gt; { :ok , true , %{ } } , ...&gt; { :ok , :skip , %{ } } , ...&gt; { :ok , false , %{ } } , ...&gt; { :ok , false , %{ } } , ...&gt; ] ...&gt; |&gt; Dx.Result . count_while ( ) { :ok , 1 , %{ } } iex&gt; [ ...&gt; false , ...&gt; false , ...&gt; ] ...&gt; |&gt; Dx.Result . count_while ( &amp; { :ok , not &amp;1 , %{ } } ) { :ok , 2 , %{ } }","ref":"Dx.Result.html#count_while/2","title":"Dx.Result.count_while/2","type":"function"},{"doc":"","ref":"Dx.Result.html#filter_map/3","title":"Dx.Result.filter_map/3","type":"function"},{"doc":"Returns {:ok, elem} for the first elem for which fun evaluates to {:ok, true} . If any elements before that return {:not_loaded, data_reqs} , returns all of them combined as {:not_loaded, ...} . Otherwise, returns {:ok, default} . Examples iex&gt; [ ...&gt; { :ok , true , %{ } } , ...&gt; { :not_loaded , [ ] } , ...&gt; { :ok , false , %{ } } , ...&gt; ] ...&gt; |&gt; Dx.Result . find ( ) { :ok , { :ok , true , %{ } } , %{ } } iex&gt; [ ...&gt; { :ok , false , %{ } } , ...&gt; { :not_loaded , [ 1 ] } , ...&gt; { :not_loaded , [ 2 ] } , ...&gt; { :ok , true , %{ } } , ...&gt; { :not_loaded , [ 3 ] } , ...&gt; ] ...&gt; |&gt; Dx.Result . find ( ) { :not_loaded , [ 1 , 2 ] } iex&gt; [ ...&gt; { :ok , false , %{ } } , ...&gt; { :ok , false , %{ } } , ...&gt; ] ...&gt; |&gt; Dx.Result . find ( ) { :ok , nil , %{ } } iex&gt; [ ...&gt; false , ...&gt; false , ...&gt; ] ...&gt; |&gt; Dx.Result . find ( &amp; { :ok , not &amp;1 , %{ } } ) { :ok , false , %{ } }","ref":"Dx.Result.html#find/4","title":"Dx.Result.find/4","type":"function"},{"doc":"Converts 2-tuples to the internal 3-tuple result format (type t:v() or t:b() ). Examples iex&gt; { :ok , 5 } ...&gt; |&gt; Dx.Result . from_simple ( ) { :ok , 5 , %{ } } iex&gt; { :error , :err } ...&gt; |&gt; Dx.Result . from_simple ( ) { :error , :err }","ref":"Dx.Result.html#from_simple/1","title":"Dx.Result.from_simple/1","type":"function"},{"doc":"Returns {:ok, mapped_results, binds} if all elements map to {:ok, result, binds} . Otherwise, returns {:error, e} on error, or {:not_loaded, data_reqs} with all data requirements. Examples iex&gt; [ ...&gt; { :ok , 1 , %{ } } , ...&gt; { :ok , 2 , %{ } } , ...&gt; { :ok , 3 , %{ } } , ...&gt; ] ...&gt; |&gt; Dx.Result . map ( ) { :ok , [ 1 , 2 , 3 ] , %{ } } iex&gt; [ ...&gt; { :ok , 1 , %{ } } , ...&gt; { :not_loaded , [ :x ] } , ...&gt; { :ok , 3 , %{ } } , ...&gt; { :not_loaded , [ :y ] } , ...&gt; ] ...&gt; |&gt; Dx.Result . map ( ) { :not_loaded , [ :x , :y ] } iex&gt; [ ...&gt; { :ok , 1 , %{ } } , ...&gt; { :error , :x } , ...&gt; { :ok , 3 , %{ } } , ...&gt; { :not_loaded , [ :y ] } , ...&gt; ] ...&gt; |&gt; Dx.Result . map ( ) { :error , :x }","ref":"Dx.Result.html#map/2","title":"Dx.Result.map/2","type":"function"},{"doc":"Returns {:ok, new_keyword_list, binds} with new values if all values map to {:ok, new_value, binds} . Otherwise, returns {:error, e} on error, or {:not_loaded, data_reqs} with all data requirements. Examples iex&gt; [ ...&gt; a : { :ok , 1 , %{ } } , ...&gt; b : { :ok , 2 , %{ } } , ...&gt; c : { :ok , 3 , %{ } } , ...&gt; ] ...&gt; |&gt; Dx.Result . map_keyword_values ( ) { :ok , [ a : 1 , b : 2 , c : 3 ] , %{ } } iex&gt; [ ...&gt; a : { :ok , 1 , %{ } } , ...&gt; b : { :not_loaded , MapSet . new ( [ :x ] ) } , ...&gt; c : { :ok , 3 , %{ } } , ...&gt; d : { :not_loaded , MapSet . new ( [ :y ] ) } , ...&gt; ] ...&gt; |&gt; Dx.Result . map_keyword_values ( ) { :not_loaded , MapSet . new ( [ :x , :y ] ) } iex&gt; [ ...&gt; a : { :ok , 1 , %{ } } , ...&gt; b : { :error , :x } , ...&gt; c : { :ok , 3 , %{ } } , ...&gt; d : { :not_loaded , [ :y ] } , ...&gt; ] ...&gt; |&gt; Dx.Result . map_keyword_values ( ) { :error , :x }","ref":"Dx.Result.html#map_keyword_values/2","title":"Dx.Result.map_keyword_values/2","type":"function"},{"doc":"Returns {:ok, new_map, binds} with new values if all values map to {:ok, new_value, binds} . Otherwise, returns {:error, e} on error, or {:not_loaded, data_reqs} with all data requirements. Examples iex&gt; %{ ...&gt; a : { :ok , 1 , %{ } } , ...&gt; b : { :ok , 2 , %{ } } , ...&gt; c : { :ok , 3 , %{ } } , ...&gt; } ...&gt; |&gt; Dx.Result . map_values ( ) { :ok , %{ a : 1 , b : 2 , c : 3 } , %{ } } iex&gt; %{ ...&gt; a : { :ok , 1 , %{ } } , ...&gt; b : { :not_loaded , MapSet . new ( [ :x ] ) } , ...&gt; c : { :ok , 3 , %{ } } , ...&gt; d : { :not_loaded , MapSet . new ( [ :y ] ) } , ...&gt; } ...&gt; |&gt; Dx.Result . map_values ( ) { :not_loaded , MapSet . new ( [ :x , :y ] ) } iex&gt; %{ ...&gt; a : { :ok , 1 , %{ } } , ...&gt; b : { :error , :x } , ...&gt; c : { :ok , 3 , %{ } } , ...&gt; d : { :not_loaded , [ :y ] } , ...&gt; } ...&gt; |&gt; Dx.Result . map_values ( ) { :error , :x }","ref":"Dx.Result.html#map_values/2","title":"Dx.Result.map_values/2","type":"function"},{"doc":"Wraps a value in an :ok result.","ref":"Dx.Result.html#ok/2","title":"Dx.Result.ok/2","type":"function"},{"doc":"When given {:ok, value, binds} , runs fun on value and returns the result. Otherwise, returns first argument as is.","ref":"Dx.Result.html#then/2","title":"Dx.Result.then/2","type":"function"},{"doc":"Converts the internal 3-tuple result format (type t:v() or t:b() ) to a 2-tuple format. Examples iex&gt; { :ok , 5 , %{ } } ...&gt; |&gt; Dx.Result . to_simple ( ) { :ok , 5 } iex&gt; { :error , :err } ...&gt; |&gt; Dx.Result . to_simple ( ) { :error , :err }","ref":"Dx.Result.html#to_simple/1","title":"Dx.Result.to_simple/1","type":"function"},{"doc":"","ref":"Dx.Result.html#to_simple_if/2","title":"Dx.Result.to_simple_if/2","type":"function"},{"doc":"When given {:ok, value, binds} , runs fun on value and returns {:ok, new_value, binds} . Otherwise, returns first argument as is.","ref":"Dx.Result.html#transform/2","title":"Dx.Result.transform/2","type":"function"},{"doc":"When given {:ok, value, binds} or {:ok, value} , returns value . Otherwise, raises an exception. Examples iex&gt; Dx.Result . unwrap! ( { :error , % ArgumentError { } } ) ** (ArgumentError) argument error iex&gt; Dx.Result . unwrap! ( { :error , :not_an_exception } ) ** (Dx.Error.Generic) Error occurred: :not_an_exception","ref":"Dx.Result.html#unwrap!/1","title":"Dx.Result.unwrap!/1","type":"function"},{"doc":"Wraps a value in a compatible tuple for use with this module, if it's not wrapped already.","ref":"Dx.Result.html#wrap/1","title":"Dx.Result.wrap/1","type":"function"},{"doc":"Possible return values from conditions.","ref":"Dx.Result.html#t:b/0","title":"Dx.Result.b/0","type":"type"},{"doc":"","ref":"Dx.Result.html#t:binds/0","title":"Dx.Result.binds/0","type":"type"},{"doc":"Possible return values from resolving predicates.","ref":"Dx.Result.html#t:v/0","title":"Dx.Result.v/0","type":"type"},{"doc":"Represents a rule, based on an individual record. when Nested map with data requirements and matching values. Lists mean one of the values must match. Negations can be expressed using {:not, value} or {:not, [values]} .","ref":"Dx.Rule.html","title":"Dx.Rule","type":"module"},{"doc":"","ref":"Dx.Rule.html#t:t/0","title":"Dx.Rule.t/0","type":"type"},{"doc":"See Dx .","ref":"Dx.Rules.html","title":"Dx.Rules","type":"module"},{"doc":"Alias for predicate_group/1 .","ref":"Dx.Rules.html#field_group/1","title":"Dx.Rules.field_group/1","type":"macro"},{"doc":"","ref":"Dx.Rules.html#import_rules/2","title":"Dx.Rules.import_rules/2","type":"macro"},{"doc":"","ref":"Dx.Rules.html#infer/1","title":"Dx.Rules.infer/1","type":"macro"},{"doc":"","ref":"Dx.Rules.html#infer/2","title":"Dx.Rules.infer/2","type":"macro"},{"doc":"","ref":"Dx.Rules.html#infer_alias/1","title":"Dx.Rules.infer_alias/1","type":"macro"},{"doc":"","ref":"Dx.Rules.html#predicate_group/1","title":"Dx.Rules.predicate_group/1","type":"macro"},{"doc":"Helpers needed in several core modules.","ref":"Dx.Util.html","title":"Dx.Util","type":"module"},{"doc":"Merges two nested maps recursively.","ref":"Dx.Util.html#deep_merge/2","title":"Dx.Util.deep_merge/2","type":"function"},{"doc":"","ref":"Dx.Util.html#rules_for_predicate/3","title":"Dx.Util.rules_for_predicate/3","type":"function"},{"doc":"Utility functions to inspect Ecto schemas. See: https://hexdocs.pm/ecto/Ecto.Schema.html#module-reflection","ref":"Dx.Util.Ecto.html","title":"Dx.Util.Ecto","type":"module"},{"doc":"","ref":"Dx.Util.Ecto.html#association_details/2","title":"Dx.Util.Ecto.association_details/2","type":"function"},{"doc":"","ref":"Dx.Util.Ecto.html#association_names/1","title":"Dx.Util.Ecto.association_names/1","type":"function"},{"doc":"","ref":"Dx.Util.Ecto.html#association_type/2","title":"Dx.Util.Ecto.association_type/2","type":"function"},{"doc":"","ref":"Dx.Util.Ecto.html#field_details/2","title":"Dx.Util.Ecto.field_details/2","type":"function"},{"doc":"Utility functions for working with Enum data structures.","ref":"Dx.Util.Enum.html","title":"Dx.Util.Enum","type":"module"},{"doc":"","ref":"Dx.Util.Enum.html#zip/4","title":"Dx.Util.Enum.zip/4","type":"function"},{"doc":"Utility functions for working with Map data structures.","ref":"Dx.Util.Map.html","title":"Dx.Util.Map","type":"module"},{"doc":"","ref":"Dx.Util.Map.html#do_get_in/2","title":"Dx.Util.Map.do_get_in/2","type":"function"},{"doc":"","ref":"Dx.Util.Map.html#do_put_in/3","title":"Dx.Util.Map.do_put_in/3","type":"function"},{"doc":"","ref":"Dx.Util.Map.html#do_zip/3","title":"Dx.Util.Map.do_zip/3","type":"function"},{"doc":"When given two maps, merges the second map into the first. When the first argument is nil , returns the second argument.","ref":"Dx.Util.Map.html#maybe_merge/2","title":"Dx.Util.Map.maybe_merge/2","type":"function"},{"doc":"Returns a Map with given keys and values zipped together Examples iex&gt; [ :d , :e , :b ] ...&gt; |&gt; Dx.Util.Map . zip ( [ 8 , 2 , 3 ] ) %{ d : 8 , e : 2 , b : 3 }","ref":"Dx.Util.Map.html#zip/2","title":"Dx.Util.Map.zip/2","type":"function"},{"doc":"Utility functions for working with modules and their functions.","ref":"Dx.Util.Module.html","title":"Dx.Util.Module","type":"module"},{"doc":"See Kernel.function_exported?/3 .","ref":"Dx.Util.Module.html#has_function?/3","title":"Dx.Util.Module.has_function?/3","type":"function"},{"doc":"","ref":"Dx.Ecto.Query.TranslationError.html","title":"Dx.Ecto.Query.TranslationError","type":"exception"},{"doc":"Callback implementation for Exception.message/1 .","ref":"Dx.Ecto.Query.TranslationError.html#message/1","title":"Dx.Ecto.Query.TranslationError.message/1","type":"function"},{"doc":"","ref":"Dx.Error.Generic.html","title":"Dx.Error.Generic","type":"exception"},{"doc":"Callback implementation for Exception.message/1 .","ref":"Dx.Error.Generic.html#message/1","title":"Dx.Error.Generic.message/1","type":"function"},{"doc":"","ref":"Dx.Error.NotLoaded.html","title":"Dx.Error.NotLoaded","type":"exception"},{"doc":"Callback implementation for Exception.message/1 .","ref":"Dx.Error.NotLoaded.html#message/1","title":"Dx.Error.NotLoaded.message/1","type":"function"},{"doc":"","ref":"Dx.Error.RulesNotFound.html","title":"Dx.Error.RulesNotFound","type":"exception"},{"doc":"Callback implementation for Exception.message/1 .","ref":"Dx.Error.RulesNotFound.html#message/1","title":"Dx.Error.RulesNotFound.message/1","type":"function"},{"doc":"","ref":"Dx.Error.Timeout.html","title":"Dx.Error.Timeout","type":"exception"},{"doc":"Callback implementation for Exception.message/1 .","ref":"Dx.Error.Timeout.html#message/1","title":"Dx.Error.Timeout.message/1","type":"function"},{"doc":"","ref":"full_reference.html","title":"Full Reference","type":"extras"},{"doc":"use Dx.Ecto.Schema enables a module to specify inferences, such as use Dx.Ecto.Schema infer has_children? : true , when : %{ relatives : %{ relation : &quot;parent_of&quot; } } infer has_children? : false Unlike full-fledged inference engines (such as calypte or retex ), all rules in Dx are bound to an individual record type as their subject. This, in turn, allows to utilize Ecto schemas and queries to their full extent.","ref":"full_reference.html#augment-ecto-schema","title":"Full Reference - Augment Ecto schema","type":"extras"},{"doc":"infer ... defines a rule in a module. It applies to an instance of that module: A struct, Ecto record, Ash resource, ... This instance of a module, on which rules are evaluated, is the subject . A rule can have a condition , or :when part, that must be met in order for it to apply, e.g. %{relatives: %{relation: &quot;parent_of&quot;}} . When the condition is met, a given predicate is assigned a given value , e.g. has_children?: true . This is also called the result of the rule. All rules are evaluated from top to bottom until the first one for each predicate matches, similar to a cond statement. A condition can make use of other predicates as well as fields defined on the schema or struct of the underlying type. An executed rule results in a (derived) fact : subject, predicate, value.","ref":"full_reference.html#terminology","title":"Full Reference - Terminology","type":"extras"},{"doc":"Dx.get/3 evaluates the given predicate(s) using only the (pre)loaded data available, and returns the result(s) Dx.load/3 is like get , but loads any additional data as needed Dx.put/3 is like load , but puts the results into the :inferred field (or virtual schema field) of the subject(s) as a map, and returns the subject(s) These functions return a tuple, either {:ok, result} , {:error, error} , or {:not_loaded, data_reqs} (only get ). The corresponding Dx.get!/3 , Dx.load!/3 and Dx.put!/3 functions return result directly, or otherwise raise an exception. Arguments: subjects can either be an individual subject (with the given predicates defined on it), or a list of subjects. Passing an individual subject will return the predicates for the subject, passing a list will return a list of them. predicates can either be a single predicate, or a list of predicates. Passing a single predicate will return the resulting value, passing a list will return a map of the predicates and their resulting values. options (optional) See below. Options: args (list or map) can be used to pass in data from the caller's context that can be used in rules (see Arguments below). A classic example is the current_user , e.g. Dx . put! ( project , :can_edit? , args : [ user : current_user ] ) extra_rules (module or list of modules) can be used to add context-specific rules that are not defined directly on the subject. This can be used to structure rules into their own modules and use them only where needed. debug? (boolean) makes Dx print additional information to the console as rules are evaluated. Should only be used while debugging.","ref":"full_reference.html#api-overview","title":"Full Reference - API overview","type":"extras"},{"doc":"In a rule condition, the part after when: ... , Maps represent multiple conditions, of which all need to be satisfied (logical AND ). Lists represent multiple conditions, of which at least one needs to be satisfied (logical OR ). Values can be negated using {:not, &quot;value&quot;} . Examples: # :role must be &quot;admin&quot; infer role : :admin , when : %{ role : &quot;admin&quot; } # :role must be either &quot;admin&quot; or &quot;superadmin&quot; infer role : :admin , when : %{ role : [ &quot;admin&quot; , &quot;superadmin&quot; ] } # :role must be &quot;admin&quot; and :verified? must be true infer role : :admin , when : %{ role : &quot;admin&quot; , verified? : true } # :role must be &quot;admin&quot; and :verified_at must not be nil infer role : :admin , when : %{ role : &quot;admin&quot; , verified_at : { :not , nil } } Boolean shorthand form A single atom is a shorthand for %{atom: true} . Conditions on list data When conditions are tested against list data, e.g. a person's list of roles, the condition is satisfied if at least one element of the list matches the given conditions (like Enum.any?/2 ). Although they might look similar, it's important to differentiate between lists that appear in conditions, and lists that appear in the data, which are checked against a condition. When both occur together, i.e. a list in a condition is checked against a list of values, the condition is met if at least one of the condition list elements applies to at least one element of the value list. For example: infer :can_edit? , when : %{ roles : [ &quot;project_manager&quot; , &quot;admin&quot; ] } iex&gt; % Person { roles : [ &quot;worker&quot; , &quot;assistant&quot; ] } |&gt; Dx . get! ( :can_edit? ) nil iex&gt; % Person { roles : [ &quot;assistant&quot; , &quot;project_manager&quot; ] } |&gt; Dx . get! ( :can_edit? ) true iex&gt; % Person { roles : [ &quot;admin&quot; ] } |&gt; Dx . get! ( :can_edit? ) true The same applies to complex conditions.","ref":"full_reference.html#conditions","title":"Full Reference - Conditions","type":"extras"},{"doc":"The assigned value of a predicate is generally assigned as is. A few special tuples, however, will be replaced by Dx (see Features below) Example: infer d : 4 infer nested : %{ a : 1 , b : 2 , c : { :ref , :d } } # =&gt; %{a: 1, b: 2, c: 4}","ref":"full_reference.html#rule-results","title":"Full Reference - Rule results","type":"extras"},{"doc":"Syntax: {:ref, path} (in conditions and result values) Arguments: path is a list of fields or predicates, starting from the subject. The brackets can be omitted (i.a. an atom passed), if the path consists of one element. The last element can be a map or list (see Branching below) Example: infer ot_fields : %{ editable : true } , when : %{ construction_bectu? : true , roles : %{ user : { :ref , [ :args , :user ] } , type : [ &quot;project_manager&quot; , &quot;admin&quot; ] } } Branching Any part of the path that represents an underlying list of subjects , such as referencing a has_many association, will cause the result of the :ref to be a list as well. It basically behaves similar to Enum.map/2 . A map as last element of a path will branch the returned result out into this map. The keys are returned as is, the values must be a list (or atom) continuing that path. This is particularly powerful when used on a list of subjects (see above), because it will return the given map with the values at the given paths for each underlying subject: A list as last element of a path behaves like a map where each value equals its key. Examples: infer list : [ %{ a : 1 , b : 2 , c : %{ d : 4 } } , %{ a : 9 , b : 8 , c : %{ d : 6 } } ] infer result1 : { :ref , [ :list , :a ] } # =&gt; [1, 9] infer result2 : { :ref , [ :list , %{ x : :a , y : [ :c , :d ] } ] } # =&gt; [%{x: 1, y: 4}, %{x: 9, y: 6}] infer result3 : { :ref , [ :list , [ :a , :b ] ] } # =&gt; [%{a: 1, b: 2}, %{a: 9, b: 8}]","ref":"full_reference.html#references","title":"Full Reference - References","type":"extras"},{"doc":"Passing :args as an option to any of the Dx API functions enables referencing the passed data in conditions and values using {:ref, [:args, ...]} .","ref":"full_reference.html#arguments","title":"Full Reference - Arguments","type":"extras"},{"doc":"It's possible to give predicates the same name as existing fields in the schema. This represents the fact that these fields are derived from other data, using rules. Rules on these fields can even take into account the existing value of the underlying field. In order to reference it, use :fields in between a path or condition, for example: schema &quot;blog_posts&quot; do field :state field :published_at end # nilify published_at when deleted, or when it&#39;s an old archived post infer published_at : nil , when : %{ state : &quot;deleted&quot; } infer published_at : nil , when : %{ state : &quot;archived&quot; , fields : %{ published_at : { :before , ~D[2020-02-20] } } } infer published_at : { :ref , [ :fields , :published_at ] } While it's always possible to achieve a similar behavior by giving the predicate a different name than the field, and then mapping the predicate to the field somewhere else, using the field name in conjunction with :fields makes explicit that it's a conditional override.","ref":"full_reference.html#overriding-existing-fields","title":"Full Reference - Overriding existing fields","type":"extras"},{"doc":"Syntax: {:bind, key} (in conditions) {:bind, key, subcondition} (in conditions) {:bound, key} (in result values) {:bound, key, default} (in result values) When a condition is evaluated on a list of values, the first value satisfying the condition can be bound to a variable using {:bind, variable} . These bound values can be referenced using {:bound, key} with an optional default: {:bound, key, default} . infer project_manager : { :bound , :person } , when : %{ roles : %{ type : &quot;project_manager&quot; , person : { :bind , :person } } }","ref":"full_reference.html#binding-subject-parts","title":"Full Reference - Binding subject parts","type":"extras"},{"doc":"Syntax: infer_alias key: ... (in modules before using key in infer ... ) In order to create shorthands and avoid repetition, aliases can be defined. These apply only to subsequent rules within the same module and are not exposed in any other way. infer_alias pm? : %{ roles : %{ type : [ &quot;project_manager&quot; , admin ] } } infer ot_fields : %{ editable : true } , when : [ :pm? , %{ construction_bectu? : true } ]","ref":"full_reference.html#local-aliases","title":"Full Reference - Local aliases","type":"extras"},{"doc":"Syntax: {&amp;module.fun/n, [arg_1, ..., arg_n]} (in result values) {&amp;module.fun/1, arg_1} (in result values) Any function can be called to map the given arguments to other values. The function arguments must be passed as a list, except if it's only one. Arguments can be fixed values or other Dx features (passed as is), such as references. infer day_of_week : { &amp; Date . day_of_week / 1 , { :ref , :date } } infer duration : { &amp; Timex . diff / 3 , [ { :ref , :start_datetime } , { :ref , :end_datetime } , :hours ] } Only pure functions with low overhead should be used. Dx might call them very often during evaluation (once after each loading of data).","ref":"full_reference.html#calling-functions","title":"Full Reference - Calling functions","type":"extras"},{"doc":"Syntax: {:query_one, type, conditions} {:query_one, type, conditions, options} {:query_first, type, conditions} {:query_first, type, conditions, options} {:query_all, type, conditions} {:query_all, type, conditions, options} Arguments: type is a module name (or Ecto queryable), e.g. an Ecto schema conditions is a keyword list of fields and their respective values, or lists of values, they must match options is a subset of the options that Ecto queries support: order_by limit Conditions The first key-value pair has a special behavior: It is used as the main condition for Dataloader , and thus should have the highest cardinality. It must be a single value, not a list of values. Rule of thumb: Put a single field that has the most unique values as first condition.","ref":"full_reference.html#querying","title":"Full Reference - Querying","type":"extras"},{"doc":"Syntax: {:filter, source, condition} (in result values) {:map, source, mapper} (in result values) {:map, source, bind_key/condition, mapper} (in result values) Arguments: source can either be a list literal, a field or predicate that evaluates to a list, or another feature such as a query. condition has the same form and functionality as any other rule condition. mapper can either be a field or predicate (atom), or is otherwise treated as any other rule value. There are 3 variants: {:filter, source, condition} keeps only elements from source , for which the condition is met. {:map, source, mapper} returns the result of mapper for each element in source . {:map, source, bind_key/condition, mapper} is a special form of :map , where the mapper is based on the subject of the rule, not the list element. The list element is referenced using the middle arg, which can be either: a bind_key (atom) - the current list element is referenced via {:bound, bind_key} in the mapper a condition - any values bound in the condition via {:bind, key, ...} can be accessed via {:bound, key} in the mapper Use the special form of :map only when you need to reference both the list element (via :bound ), and the subject of the rule (via :ref ). Using a combination of :filter and basic :map instead is always preferred, if possible. Any nil elements in the list are mapped to nil , when using :map without condition. Examples: infer accepted_offers : { :filter , :offers , %{ state : &quot;accepted&quot; } } infer offer_ids : { :map , :offers , :id } infer first_offer_of_same_user : { :map , :offers , %{ state : &quot;accepted&quot; , user_id : { :bind , :uid , { :not , nil } } } , { :query_first , Offer , user_id : { :bound , :uid } , project_id : { :ref , :project_id } } }","ref":"full_reference.html#transforming-lists","title":"Full Reference - Transforming lists","type":"extras"},{"doc":"Syntax: {:count, source, condition/predicate} (in result values) {:count_while, source, condition/predicate} (in result values) Arguments: source can either be a list literal, a field or predicate that evaluates to a list, or another feature such as a query. condition has the same form and functionality as any other rule condition. predicate can either be a predicate (atom) that returns either true , false , or :skip (only for :count_while ) Takes the given list and counts the elements that evaluate to true . :count_while stops after the first element that returns false . To not count an element, but not stop counting either, the given predicate may return :skip . Any nil elements in the list are treated as false .","ref":"full_reference.html#counting","title":"Full Reference - Counting","type":"extras"},{"doc":"Welcome to the documentation of Dx , a rule-based inference engine written in Elixir. If you're new to Dx , we recommend starting with the basics .","ref":"welcome.html","title":"Welcome ðŸ‘‹","type":"extras"},{"doc":"In the following sections, we'll learn... what predicates are, and how to define rules to assign their values how associations are easily traversed when defining rules combining conditions to define more complex rules using references to compare multiple fields or predicates with each other passing in arguments from the outside context in which rules are evaluated Finally, we close with a chapter on Thinking in Dx , learn to apply all the lessons learnt.","ref":"00_intro.html","title":"Introduction","type":"extras"},{"doc":"Dx allows you to add predicates to your schema. Predicates are like virtual fields, but instead of storing values, you define what the value should be, based on conditions. Example: boolean predicate Say we have a ToDo list app with a Todo.List schema type. defmodule Todo.List do use Ecto.Schema use Dx.Ecto.Schema , repo : Todo.Repo schema &quot;lists&quot; do field :archived_at , :utc_datetime end infer archived? : false , when : %{ archived_at : nil } infer archived? : true end Here, we define a predicate archived? on our Todo.List schema. It has the value false when the field archived_at is nil . If this condition doesn't match, Dx will look at the next rule and assign the value true . Since there is no condition for this last rule, it will always match. Tip: It is a good practice to always have a last rule without condition to define a fallback value. Usage This predicate can now be used like a field, as long as you use an Dx to to evaluate it, such as Dx.get!/2 : # loading a predicate iex&gt; % Todo.List { archived_at : nil } ...&gt; |&gt; Dx . get! ( :archived? ) false iex&gt; % Todo.List { archived_at : ~U[2022-02-02 22:22:22Z] } ...&gt; |&gt; Dx . get! ( :archived? ) true Example: multi-value predicate Instead of assigning true or false , we might define a predicate state that can be easily extended later on. We can even use the existing predicate and reference it in our new rule: defmodule Todo.List do use Ecto.Schema use Dx.Ecto.Schema , repo : Todo.Repo schema &quot;lists&quot; do field :archived_at , :utc_datetime end infer archived? : false , when : %{ archived_at : nil } infer archived? : true infer state : :archived , when : %{ archived? : true } infer state : :active end Usage Just as with archived? , we can now use state as if it was a field when using Dx : iex&gt; % Todo.List { archived_at : nil } ...&gt; |&gt; Dx . get! ( :state ) :active iex&gt; % Todo.List { archived_at : ~U[2022-02-02 22:22:22Z] } ...&gt; |&gt; Dx . get! ( :state ) :archived","ref":"01_predicates.html","title":"Predicates","type":"extras"},{"doc":"Dx allows to easily traverse associations to access fields or even predicates defined on associated records. Say our Todo.List schema from the previous guide now has_many tasks: defmodule Todo.List do use Ecto.Schema use Dx.Ecto.Schema , repo : Todo.Repo schema &quot;lists&quot; do field :archived_at , :utc_datetime has_many :tasks , Todo.Task end infer archived? : false , when : %{ archived_at : nil } infer archived? : true infer state : :archived , when : %{ archived? : true } infer state : :active end In return, we add a Task schema that belongs_to a List: defmodule Todo.Task do use Ecto.Schema use Dx.Ecto.Schema , repo : Todo.Repo schema &quot;tasks&quot; do field :completed_at , :utc_datetime belongs_to :list , Todo.List end infer completed? : false , when : %{ completed_at : nil } infer completed? : true end belongs_to Say we want a Task to be archived? when the List it belongs to is archived. We could write a similar rule on the Todo.Task schema as we have on the List: infer archived? : false , when : %{ list : %{ archived_at : nil } } infer archived? : true The archived? predicate looks at the associated list (defined using belongs_to ) and its field archived_at , and compares that to nil . If it's nil then the Task's predicate archived? is false , otherwise it's true . However, since we've already defined this logic on the List, we can also use the predicate on the associated List instead, and change things around a bit: infer archived? : true , when : %{ list : %{ archived? : true } } infer archived? : false Usage Like before, we can use Dx.get!/2 to evaluate the predicate, but only if the association is (pre)loaded: iex&gt; list = % Todo.List { archived_at : ~U[2022-02-02 22:22:22Z] } |&gt; Todo.Repo . insert! ( ) ...&gt; % Todo.Task { completed_at : nil , list : list } ...&gt; |&gt; Dx . get! ( :archived? ) true If the association is not (pre)loaded, Dx.get!/2 will raise an error: iex&gt; list = % Todo.List { archived_at : ~U[2022-02-02 22:22:22Z] } |&gt; Todo.Repo . insert! ( ) ...&gt; % Todo.Task { completed_at : nil , list : list } ...&gt; |&gt; Todo.Repo . insert! ( ) |&gt; Todo.Repo . reload! ( ) # insert and reload without associations ...&gt; |&gt; Dx . get! ( :archived? ) ** (Dx.Error.NotLoaded) Association list is not loaded on nil. Cannot get path: nil To allow Dx to load associations as needed, use Dx.load!/2 instead: iex&gt; list = % Todo.List { archived_at : ~U[2022-02-02 22:22:22Z] } |&gt; Todo.Repo . insert! ( ) ...&gt; % Todo.Task { completed_at : nil , list : list } ...&gt; |&gt; Todo.Repo . insert! ( ) |&gt; Todo.Repo . reload! ( ) # insert and reload without associations ...&gt; |&gt; Dx . load! ( :archived? ) # loads the associated list true has_many We can also define predicates based on a has_many association. Dx generally treats conditions on a list of records like an Enum.any? condition: defmodule Todo.List do # ... infer in_progress? : true , when : %{ tasks : %{ completed? : true } } infer in_progress? : false end The predicate in_progress? is true if there's any Task associated that has completed?: true . Otherwise, if there's no Task associated that has completed?: true , in_progress? is false . Putting it all together, we can extend our state predicate on the Todo.List schema: defmodule Todo.List do # ... infer state : :archived , when : %{ archived? : true } infer state : :in_progress , when : %{ tasks : %{ completed? : true } } infer state : :ready , when : %{ tasks : %{ } } infer state : :empty end What does the :ready rule do? It checks whether there's any Task, without any condition on the Task. So if the List is not archived, and there are no completed tasks, but there is a Task, :state is :ready . Otherwise :state is :empty . This might be hard to grasp, but it will hopefully become clearer in the next guide...","ref":"02_associations.html","title":"Associations","type":"extras"},{"doc":"We've already seen some conditions nested using maps. And Using maps is the go-to way of writing conditions. If you're unsure about how to define a condition, use a Map . When using a Map with multiple elements in a condition, all of its elements must match for the whole condition to match. This is similar to pattern-matching in Elixir code. Say we want a Todo.List to only be archivable? if it's not archived yet and all of its tasks are completed. defmodule Todo.List do use Ecto.Schema use Dx.Ecto.Schema , repo : Todo.Repo schema &quot;lists&quot; do field :archived_at , :utc_datetime belongs_to :created_by , Todo.User end infer archived? : false , when : %{ archived_at : nil } infer archived? : true infer archivable? : true , when : %{ archived? : false , tasks : { :all? , %{ completed? : true } } } infer archivable? : false end Or A logical &quot;or&quot; is expressed by an Elixir List . This is the first major difference to pattern-matching. It might not feel intuitive at first, but gets familiar fast and becomes very useful once you got used to it. Say we want a Todo.List to be archivable? if its :state we defined in the previous chapter is either :completed or :ready . defmodule Todo.List do # ... infer state : :archived , when : %{ archived? : true } infer state : :completed , when : %{ tasks : { :all? , %{ completed? : true } } } infer state : :in_progress , when : %{ tasks : %{ completed? : true } } infer state : :ready , when : %{ tasks : %{ } } infer state : :empty infer archivable? : true , when : %{ state : [ :completed , :ready ] } infer archivable? : false end This is also a good example for defining predicates based on other predicates if they reflect how you actually think about them. Dx will find an efficient way to evaluate them. Not Negations can be expressed by wrapping a condition in a :not tuple. Another way of expressing the archived? predicate from the first guide would thus be: defmodule Todo.List do # ... infer archived? : true , when : %{ archived_at : { :not , nil } } infer archived? : false # previously: # infer archived?: false, when: %{archived_at: nil} # infer archived?: true end","ref":"03_conditions.html","title":"Conditions","type":"extras"},{"doc":"Often times, we need to compare values in different fields with each other, not with fixed values. This is where references come in. Say we want to add a by_owner? predicate to a Todo.Task : defmodule Todo.Task do use Ecto.Schema use Dx.Ecto.Schema , repo : Todo.Repo schema &quot;tasks&quot; do field :completed_at , :utc_datetime belongs_to :list , Todo.List belongs_to :created_by , Todo.User end infer by_owner? : true , when : %{ created_by_id : { :ref , [ :list , :created_by_id ] } } infer by_owner? : false end Operators By default, all comparisons need to match exactly. However, other comparisons are possible as well. Say we support completing tasks on an already archived list. And we want to add a predicate completed_later? to capture that. defmodule Todo.Task do use Ecto.Schema use Dx.Ecto.Schema , repo : Todo.Repo schema &quot;tasks&quot; do field :completed_at , :utc_datetime belongs_to :list , Todo.List belongs_to :created_by , Todo.User end infer completed_later? : false , when : %{ completed? : false } infer completed_later? : false , when : %{ list : %{ archived? : false } } infer completed_later? : true , when : %{ archived_at : { :gt , { :ref , [ :list , :archived_at ] } } } infer completed_later? : false end The Todo.Task must already by completed? and the Todo.List archived? . In particular, the Todo.Task must be completed_at after the Todo.List was archived. Operators can also compare to fixed values (not references). Supported operators Operators with all aliases: Greater than: :gt , :&gt; , :greater_than , :after Greater than or equal: :gte , :&gt;= , :greater_than_or_equal , :on_or_after , :at_or_after Less than: :lt , :&lt; , :less_than , :before Less than or equal: :lte , :&lt;= , :less_than_or_equal , :on_or_before , :at_or_before","ref":"04_references.html","title":"References","type":"extras"},{"doc":"To pass in data from the caller context and make it available in the rules, there's the args option. Any args passed to the Dx API function will be available in rules as if args was an association on the current root record. Say we implement some authorization, where a user can archive a Todo.List only if they are an admin, or they are the owner of the list. We pass in the currently logged-in user struct, which was already loaded as part of authentication. Dx . load! ( list , args : [ current_user : current_user ] ) The current_user is then available within args , including any fields, associations and predicates defined on it. defmodule Todo.List do use Ecto.Schema use Dx.Ecto.Schema , repo : Todo.Repo schema &quot;lists&quot; do field :archived_at , :utc_datetime belongs_to :created_by , Todo.User end infer can_archive? : true , when : %{ args : %{ current_user : %{ is_admin? : true } } } infer can_archive? : true , when : %{ created_by_id : { :ref , [ :args , :current_user , :id ] } } infer can_archive? : false end","ref":"05_arguments.html","title":"Arguments","type":"extras"},{"doc":"When working with Dx, we have to think top-down, as opposed to bottom-up. We always start from the end result, which we want to achieve. Any logic and inputs needed to get to the end result are defined within Dx. Example Say we have a complex requirement to implement: A user can archive a Todo list, but only if they created it, or if they have an &quot;admin&quot; role, and only if all tasks in the list are completed. Let's assume we only have the schema, and no other functions, helpers, or rules defined. defmodule Todo.User do use Ecto.Schema use Dx.Ecto.Schema , repo : Todo.Repo schema &quot;users&quot; do has_many :roles , Todo.UserRole end end defmodule Todo.UserRole do use Ecto.Schema use Dx.Ecto.Schema , repo : Todo.Repo schema &quot;user_roles&quot; do field :name , Ecto.Enum , values : [ :moderator , :admin , :super_admin ] belongs_to :user , Todo.User end end defmodule Todo.List do use Ecto.Schema use Dx.Ecto.Schema , repo : Todo.Repo schema &quot;lists&quot; do field :archived_at , :utc_datetime belongs_to :created_by , Todo.User end end defmodule Todo.Task do use Ecto.Schema use Dx.Ecto.Schema , repo : Todo.Repo schema &quot;tasks&quot; do field :completed_at , :utc_datetime belongs_to :list , Todo.List end end The inputs are the list to be archived and the current_user who tries to archive it. The end result is either the now archived list, or an error. Without Dx, we'd write a function that takes the list and the user who tries to archive it. We'd then have to think about how to load the data needed to compute the result, and implement it. With Dx, we don't have to think about how to load the data or compute the result. Instead, we focus entirely on what is relevant and write the rules to represent this logic. Dx then takes care of loading data as needed, in an efficient way. Thinking in Dx, we usually take the following steps: What are the possible end results that we need to continue in our other code, f.ex. a web request? In our example, the end result can be either &quot;archive the list&quot; or &quot;can't archive list&quot;. In code terms, we could return true or false , or we could return :ok or {:error, reason} . Note: We think of Dx as read-only; we don't perform an action (such as archiving a list), but prepare and compute all the data needed to do it. What is the primary data point, on which to operate on? In our example, it's rather easy: we operate on a list . In other cases, there might be multiple candidates; in these cases, it might help to ask what data type feels most intuitive to return the end results conceived in step 1. Define a predicate on the main data type from step 2 with the possible values from step 1. In the code where the outcome is used, f.ex. a web request, call Dx with the main data point and this predicate. We also add additional data needed as args . In our example: # in Todo.List infer archivable? : :ok infer archivable? : { :error , :unauthorized } infer archivable? : { :error , :pending_tasks } # in the List controller with :ok &lt;- Dx . load! ( list , :archivable? , args : [ current_user : current_user ] ) , { :ok , archived_list } &lt;- List . archive ( list ) do render ( conn , &quot;show.html&quot; , list : archived_list ) end Flesh out the conditions for the various cases. For each condition, think about what's needed and how it could be called. If there's a good answer, use the term in the condition as if it already existed. This way, it's easier to stay on the requirements level, using terms that make sense in the app's domain. In our example, we also reverse the order, checking all error cases first, and returning :ok otherwise: # in Todo.List infer archivable? : { :error , :unauthorized } , when : %{ can_archive? : false } infer archivable? : { :error , :pending_tasks } , when : %{ tasks : %{ completed? : false } } infer archivable? : :ok Define the predicates you used on the correct schema types, and continue the process until the requirements are fully defined using rules. In our example, the final set of rules might look like this: # in Todo.List infer archivable? : { :error , :unauthorized } , when : %{ can_archive? : false } infer archivable? : { :error , :pending_tasks } , when : %{ tasks : %{ completed? : false } } infer archivable? : :ok infer can_archive? : true , when : %{ args : %{ current_user : %{ is_admin? : true } } } infer can_archive? : true , when : %{ is_owner? : true } infer can_archive? : false infer is_owner? : true , when : %{ created_by_id : { :ref , [ :args , :current_user , :id ] } } infer is_owner? : false # in Todo.User infer is_admin? : true , when : %{ roles : %{ name : [ :admin , :super_admin ] } } infer is_admin? : false # in Todo.Task infer completed? : true , when : %{ completed_at : { :not , nil } } infer completed? : false Other use cases covered We could use the rules we defined to cover other use cases as well: Filtering archivable lists Say we have a list of Todo.List structs, and want to keep only the ones that can be archived, for example to implement a web request to archive multiple lists. We use Dx.filter/3 for it, which takes a list of data as well as a condition, just like the ones we use when defining rules: Dx . filter ( lists , %{ archivable? : :ok } , args : [ current_user : current_user ] ) Querying all archivable lists Say we want to query all lists that a given user can archive. We use Dx.query_all/3 for it, which takes a type as well as a condition, just like the ones we use when defining rules: Dx . query_all ( Todo.List , %{ archivable? : :ok } , args : [ current_user : current_user ] )","ref":"06_thinking_in_dx.html","title":"Thinking in Dx","type":"extras"},{"doc":"We've learnt all the basics about using Dx, and even thinking in it. This should be enough to get you started. We're currently writing guides on more advanced topics, so stay tuned! ðŸ™Œ","ref":"99_outro.html","title":"Done ðŸŽ‰","type":"extras"}]