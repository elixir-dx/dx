searchData={"content_type":"text/markdown","items":[{"doc":"This is the main entry for using the Dx API.\n\n- `get/3` evaluates the given predicate(s) using only the (pre)loaded data available, and returns the result(s)\n- `load/3` is like `get`, but loads any additional data as needed\n- `put/3` is like `load`, but puts the results into the `:inferred` field\n  (or virtual schema field) of the subject(s) as a map, and returns the subject(s)\n\nThese functions return a tuple, either `{:ok, result}`, `{:error, error}`, or `{:not_loaded, data_reqs}` (only `get`).\n\nThe corresponding `get!/3`, `load!/3` and `put!/3` functions return `result`\ndirectly, or otherwise raise an exception.\n\nArguments:\n- `subjects` can either be an individual subject (with the given predicates defined on it), or a list of subjects.\n  Passing an individual subject will return the predicates for the subject, passing a list will return a list of them.\n- `predicates` can either be a single predicate, or a list of predicates.\n  Passing a single predicate will return the resulting value, passing a list will return a `Map`\n  of the predicates and their resulting values.\n- `options` (optional) See below.\n\nOptions:\n- `args` (list or map) can be used to pass in data from the caller's context that can be used in\n  rules (see *Arguments* below). A classic example is the `current_user`, e.g.\n  ```elixir\n  put!(project, :can_edit?, args: [user: current_user])\n  ```\n- `extra_rules` (module or list of modules) can be used to add context-specific rules that are\n  not defined directly on the subject. This can be used to structure rules into their own modules\n  and use them only where needed.\n- `debug` (boolean) makes Dx print additional information to the console as rules are evaluated.\n  Should only be used while debugging.\n- `return_cache` (boolean) makes non-bang functions return `{:ok, result, cache}` instead of\n  `{:ok, result}` on success. This `cache` can be passed to other Dx functions (see `cache` option)\n- `cache` (`Dataloader` struct) can be used to pass in an existing cache, so data already loaded\n  doesn't need to be loaded again. Can be initialized using `Dx.Loaders.Dataloader.init/1`.\n- `loader` allows choosing a loader module. Defaults to `Dx.Loaders.Dataloader`.\n- `loader_options` are passed to `loader.init/1` function. See `Dx.Loaders.Dataloader` for options\n  supported by the default loader.","ref":"Dx.html","title":"Dx","type":"module"},{"doc":"Removes all elements not matching the given condition from the given list.","ref":"Dx.html#filter/3","title":"Dx.filter/3","type":"function"},{"doc":"Evaluates one or multiple predicates for one or multiple records and returns the results.\n\nDoes not load any additional data.","ref":"Dx.html#get/3","title":"Dx.get/3","type":"function"},{"doc":"Like `get/3` but returns the result value, or raises an error.","ref":"Dx.html#get!/3","title":"Dx.get!/3","type":"function"},{"doc":"Like `get/3`, but loads additional data if needed.","ref":"Dx.html#load/3","title":"Dx.load/3","type":"function"},{"doc":"Like `get!/3`, but loads additional data if needed.","ref":"Dx.html#load!/3","title":"Dx.load!/3","type":"function"},{"doc":"Loads the given predicate(s) for the given record(s) and merges the\nresults into the `inferred` map field of the record(s), returning them.","ref":"Dx.html#put/3","title":"Dx.put/3","type":"function"},{"doc":"Same as for `get/3`.","ref":"Dx.html#put/3-options","title":"Options - Dx.put/3","type":"function"},{"doc":"","ref":"Dx.html#put!/3","title":"Dx.put!/3","type":"function"},{"doc":"Returns all records matching the given condition.","ref":"Dx.html#query_all/3","title":"Dx.query_all/3","type":"function"},{"doc":"In general, as much work as possible is done in the database.\nIf possible, the condition is completely translated to an `Ecto.Query`\nso the database only returns matching records.\nAll condition parts that can not be translated to an `Ecto.Query`, will be\nevaluated by `loading all remaining records`, and associations as needed,\nand evaluating the rules on them.","ref":"Dx.html#query_all/3-caveat","title":"Caveat - Dx.query_all/3","type":"function"},{"doc":"Returns the first record matching the given condition.","ref":"Dx.html#query_one/3","title":"Dx.query_one/3","type":"function"},{"doc":"Same as for `query_all/3`.","ref":"Dx.html#query_one/3-options","title":"Options - Dx.query_one/3","type":"function"},{"doc":"Removes all elements matching the given condition from the given list.","ref":"Dx.html#reject/3","title":"Dx.reject/3","type":"function"},{"doc":"","ref":"Dx.Defd.html","title":"Dx.Defd","type":"module"},{"doc":"","ref":"Dx.Defd.html#defd/1","title":"Dx.Defd.defd/1","type":"macro"},{"doc":"","ref":"Dx.Defd.html#defd/2","title":"Dx.Defd.defd/2","type":"macro"},{"doc":"","ref":"Dx.Defd.html#get/2","title":"Dx.Defd.get/2","type":"macro"},{"doc":"","ref":"Dx.Defd.html#get!/2","title":"Dx.Defd.get!/2","type":"macro"},{"doc":"","ref":"Dx.Defd.html#load/2","title":"Dx.Defd.load/2","type":"macro"},{"doc":"","ref":"Dx.Defd.html#load!/2","title":"Dx.Defd.load!/2","type":"macro"},{"doc":"Used to wrap calls to non-Dx defined functions.\nIt doesn't run any code, but makes these calls explicit and mutes Dx compiler warnings.","ref":"Dx.Defd.html#non_dx/1","title":"Dx.Defd.non_dx/1","type":"function"},{"doc":"Determines which field to batch queries by.","ref":"Dx.Ecto.Query.Batches.html","title":"Dx.Ecto.Query.Batches","type":"module"},{"doc":"We have data requirements that need to be fulfilled by\nexecuting queries.\n\nEach data requirement consists of a group, for example\na set of fixed options for running a query, and a list\nof filters, each filter being a field + value to match on.\n\nEach query can only have one field to be batched on,\ni.e. one field takes a list of values to fulfill\nmultiple data requirements.\n\nThe goal is to minimize the number of queries.\nThis is trivial when filtering by 0 or 1 fields.\nWhen filtering by 2 or more fields, some work must be\ndone to determine the ideal field to batch by.","ref":"Dx.Ecto.Query.Batches.html#module-problem","title":"Problem - Dx.Ecto.Query.Batches","type":"module"},{"doc":"We basically count the filter combinations for each\npotential field to batch on.\nEach combination consists of the field to batch on + all\nother filters as a fixed set.","ref":"Dx.Ecto.Query.Batches.html#module-approach","title":"Approach - Dx.Ecto.Query.Batches","type":"module"},{"doc":"iex> add_filters(:query1, [color: \"red\", char: \"A\"])\n    ...> |> get_batches()\n    [\n      query1: [\n        {:char, [\"A\"], color: \"red\"}\n      ]\n    ]\n\n    iex> add_filters(:query1, [color: \"red\", char: \"A\"])\n    ...> |> add_filters(:query1, [color: \"blue\", char: \"A\"])\n    ...> |> get_batches()\n    [\n      query1: [\n        {:color, [\"blue\", \"red\"], char: \"A\"}\n      ]\n    ]\n\n    iex> add_filters(:query1, [color: \"red\", char: \"A\", size: \"L\"])\n    ...> |> add_filters(:query1, [color: \"blue\", size: \"S\", char: \"A\"])\n    ...> |> add_filters(:query1, [color: \"pink\", size: \"S\", char: \"B\"])\n    ...> |> add_filters(:query1, [color: \"pink\", size: \"S\", char: \"A\"])\n    ...> |> get_batches()\n    [\n      query1: [\n        {:char, [\"A\"], color: \"blue\", size: \"S\"},\n        {:char, [\"A\", \"B\"], color: \"pink\", size: \"S\"},\n        {:char, [\"A\"], color: \"red\", size: \"L\"}\n      ]\n    ]\n\n    iex> add_filters(:query1, [color: \"red\"])\n    ...> |> add_filters(:query1, [color: \"blue\"])\n    ...> |> get_batches()\n    [\n      query1: [\n        {:color, [\"blue\", \"red\"], []}\n      ]\n    ]\n\n    iex> add_filters(:query1, [])\n    ...> |> get_batches()\n    [\n      query1: [\n        {}\n      ]\n    ]","ref":"Dx.Ecto.Query.Batches.html#module-examples","title":"Examples - Dx.Ecto.Query.Batches","type":"module"},{"doc":"Adds one data requirement, consisting of a group + list of filters,\nto a given (or newly initialized) state","ref":"Dx.Ecto.Query.Batches.html#add_filters/3","title":"Dx.Ecto.Query.Batches.add_filters/3","type":"function"},{"doc":"Returns an optimal set of batches for the given state returned by the\nother functions.","ref":"Dx.Ecto.Query.Batches.html#get_batches/1","title":"Dx.Ecto.Query.Batches.get_batches/1","type":"function"},{"doc":"[\n      group1: [\n        {:batch_key, list_of_values, other_filters_keyword},\n        # ...\n      ],\n      # ...\n    ]","ref":"Dx.Ecto.Query.Batches.html#get_batches/1-format","title":"Format - Dx.Ecto.Query.Batches.get_batches/1","type":"function"},{"doc":"","ref":"Dx.Ecto.Query.Batches.html#map_put_in/3","title":"Dx.Ecto.Query.Batches.map_put_in/3","type":"function"},{"doc":"Initializes a new state to call other functions on","ref":"Dx.Ecto.Query.Batches.html#new/0","title":"Dx.Ecto.Query.Batches.new/0","type":"function"},{"doc":"See `Dx`.","ref":"Dx.Ecto.Schema.html","title":"Dx.Ecto.Schema","type":"module"},{"doc":"Result types and helpers to work with them.\n\nA result is either:\n\n  - `{:error, e}` if an error occurred\n  - `{:not_loaded, data_reqs}` if the result could not be determined without loading more data\n  - `{:ok, boolean, binds}` otherwise, in contexts where a boolean is expected (type `t:b()`)\n  - `{:ok, result, binds}` otherwise, where `result` can be any value (type `t:v()`)","ref":"Dx.Result.html","title":"Dx.Result","type":"module"},{"doc":"In general, `{:not_loaded, all_reqs}` only ever returns data requirements that are really needed.","ref":"Dx.Result.html#module-data-loading","title":"Data loading - Dx.Result","type":"module"},{"doc":"For example, using `all?/1` with 3 conditions A, B and C, where\n\n    iex> [\n    ...>   {:ok, true, %{}},   # A\n    ...>   {:not_loaded, [1]}, # B\n    ...>   {:ok, false, %{}},  # C\n    ...> ]\n    ...> |> Dx.Result.all?()\n    {:ok, false, %{}}\n\nThe overall result is `{:ok, false, %{}}`.\nWhile B would need more data to be loaded, C can already determined and is `false`,\nso and any additional data loaded will not change that.","ref":"Dx.Result.html#module-example-using-all","title":"Example using `all` - Dx.Result","type":"module"},{"doc":"Another example, using `find/1` with 5 conditions A, B, C, D and E, where\n\n    iex> [\n    ...>   {:ok, false, %{}},  # A\n    ...>   {:not_loaded, [1]}, # B\n    ...>   {:not_loaded, [2]}, # C\n    ...>   {:ok, true, %{}},   # D\n    ...>   {:not_loaded, [3]}, # E\n    ...> ]\n    ...> |> Dx.Result.find()\n    {:not_loaded, [1, 2]}\n\nThe overall result is `{:not_loaded, data_reqs1 + data_reqs2}`.\nWhile D can already be determined and is `{:ok, true, %{}}`, B and C come first and need more data\nto be loaded, so they can be determined and returned if either is `{:ok, true, %{}}` first.\nAll data requirements that might be needed are returned together in the result (those of B and C),\nwhile those of E can be ruled out, as D already returns `{:ok, true, %{}}` and comes first.","ref":"Dx.Result.html#module-example-using-find","title":"Example using `find` - Dx.Result","type":"module"},{"doc":"Returns `{:ok, true}` if `fun` evaluates to `{:ok, true}` for all elements in `enum`.\nOtherwise, returns `{:not_loaded, data_reqs}` if any yield that.\nOtherwise, returns `{:ok, false}`.","ref":"Dx.Result.html#all?/2","title":"Dx.Result.all?/2","type":"function"},{"doc":"iex> [\n    ...>   {:ok, true, %{}},\n    ...>   {:not_loaded, []},\n    ...>   {:ok, false, %{}},\n    ...> ]\n    ...> |> Dx.Result.all?()\n    {:ok, false, %{}}\n\n    iex> [\n    ...>   {:ok, true, %{}},\n    ...>   {:not_loaded, []},\n    ...>   {:ok, true, %{}},\n    ...> ]\n    ...> |> Dx.Result.all?()\n    {:not_loaded, []}\n\n    iex> [\n    ...>   {:ok, true, %{}},\n    ...>   {:ok, true, %{}},\n    ...> ]\n    ...> |> Dx.Result.all?()\n    {:ok, true, %{}}","ref":"Dx.Result.html#all?/2-examples","title":"Examples - Dx.Result.all?/2","type":"function"},{"doc":"Returns `{:ok, true, binds}` if `fun` evaluates to `{:ok, true, binds}` for any element in `enum`.\nOtherwise, returns `{:not_loaded, data_reqs}` if any yields that.\nOtherwise, returns `{:ok, false, %{}}`.","ref":"Dx.Result.html#any?/2","title":"Dx.Result.any?/2","type":"function"},{"doc":"iex> [\n    ...>   {:ok, true, %{a: 1}},\n    ...>   {:not_loaded, []},\n    ...>   {:ok, false, %{}},\n    ...> ]\n    ...> |> Dx.Result.any?()\n    {:ok, true, %{a: 1}}\n\n    iex> [\n    ...>   {:ok, false, %{}},\n    ...>   {:not_loaded, []},\n    ...>   {:ok, false, %{}},\n    ...> ]\n    ...> |> Dx.Result.any?()\n    {:not_loaded, []}\n\n    iex> [\n    ...>   {:ok, false, %{}},\n    ...>   {:ok, false, %{}},\n    ...> ]\n    ...> |> Dx.Result.any?()\n    {:ok, false, %{}}","ref":"Dx.Result.html#any?/2-examples","title":"Examples - Dx.Result.any?/2","type":"function"},{"doc":"If ok, binds the result to the given key and returns the updated tuple.\nOtherwise, returns first argument as is.","ref":"Dx.Result.html#bind/3","title":"Dx.Result.bind/3","type":"function"},{"doc":"Returns the number of elements for which `fun` evaluates to `{:ok, true}`.\nIf any elements return `{:not_loaded, data_reqs}`, returns all of them combined as `{:not_loaded, ...}`.\nOtherwise, returns `{:ok, default}`.","ref":"Dx.Result.html#count/2","title":"Dx.Result.count/2","type":"function"},{"doc":"iex> [\n    ...>   {:ok, true, %{}},\n    ...>   {:ok, false, %{}},\n    ...>   {:ok, true, %{}},\n    ...> ]\n    ...> |> Dx.Result.count()\n    {:ok, 2, %{}}\n\n    iex> [\n    ...>   {:ok, false, %{}},\n    ...>   {:not_loaded, [1]},\n    ...>   {:not_loaded, [2]},\n    ...>   {:ok, true, %{}},\n    ...>   {:not_loaded, [3]},\n    ...> ]\n    ...> |> Dx.Result.count()\n    {:not_loaded, [1, 2, 3]}\n\n    iex> [\n    ...>   {:ok, true, %{}},\n    ...>   {:ok, :skip, %{}},\n    ...>   {:ok, false, %{}},\n    ...>   {:ok, false, %{}},\n    ...> ]\n    ...> |> Dx.Result.count()\n    {:ok, 1, %{}}\n\n    iex> [\n    ...>   false,\n    ...>   false,\n    ...> ]\n    ...> |> Dx.Result.count(&{:ok, not &1, %{}})\n    {:ok, 2, %{}}","ref":"Dx.Result.html#count/2-examples","title":"Examples - Dx.Result.count/2","type":"function"},{"doc":"Returns the number of elements before `fun` evaluates to `{:ok, false}` or an element is `nil`.\nElements are skipped (not counted) whenever `fun` evaluates to `{:ok, :skip}`.\nIf any elements before that return `{:not_loaded, data_reqs}`, returns all of them combined as `{:not_loaded, ...}`.\nOtherwise, returns `{:ok, default}`.","ref":"Dx.Result.html#count_while/2","title":"Dx.Result.count_while/2","type":"function"},{"doc":"iex> [\n    ...>   {:ok, true, %{}},\n    ...>   {:not_loaded, []},\n    ...>   {:ok, false, %{}},\n    ...> ]\n    ...> |> Dx.Result.count_while()\n    {:not_loaded, []}\n\n    iex> [\n    ...>   {:ok, false, %{}},\n    ...>   {:not_loaded, [1]},\n    ...>   {:not_loaded, [2]},\n    ...>   {:ok, true, %{}},\n    ...>   {:not_loaded, [3]},\n    ...> ]\n    ...> |> Dx.Result.count_while()\n    {:ok, 0, %{}}\n\n    iex> [\n    ...>   {:ok, true, %{}},\n    ...>   {:ok, :skip, %{}},\n    ...>   {:ok, false, %{}},\n    ...>   {:ok, false, %{}},\n    ...> ]\n    ...> |> Dx.Result.count_while()\n    {:ok, 1, %{}}\n\n    iex> [\n    ...>   false,\n    ...>   false,\n    ...> ]\n    ...> |> Dx.Result.count_while(&{:ok, not &1, %{}})\n    {:ok, 2, %{}}","ref":"Dx.Result.html#count_while/2-examples","title":"Examples - Dx.Result.count_while/2","type":"function"},{"doc":"","ref":"Dx.Result.html#filter_map/3","title":"Dx.Result.filter_map/3","type":"function"},{"doc":"Returns `{:ok, elem}` for the first `elem` for which `fun` evaluates to `{:ok, true}`.\nIf any elements before that return `{:not_loaded, data_reqs}`, returns all of them combined as `{:not_loaded, ...}`.\nOtherwise, returns `{:ok, default}`.","ref":"Dx.Result.html#find/4","title":"Dx.Result.find/4","type":"function"},{"doc":"iex> [\n    ...>   {:ok, true, %{}},\n    ...>   {:not_loaded, []},\n    ...>   {:ok, false, %{}},\n    ...> ]\n    ...> |> Dx.Result.find()\n    {:ok, {:ok, true, %{}}, %{}}\n\n    iex> [\n    ...>   {:ok, false, %{}},\n    ...>   {:not_loaded, [1]},\n    ...>   {:not_loaded, [2]},\n    ...>   {:ok, true, %{}},\n    ...>   {:not_loaded, [3]},\n    ...> ]\n    ...> |> Dx.Result.find()\n    {:not_loaded, [1, 2]}\n\n    iex> [\n    ...>   {:ok, false, %{}},\n    ...>   {:ok, false, %{}},\n    ...> ]\n    ...> |> Dx.Result.find()\n    {:ok, nil, %{}}\n\n    iex> [\n    ...>   false,\n    ...>   false,\n    ...> ]\n    ...> |> Dx.Result.find(&{:ok, not &1, %{}})\n    {:ok, false, %{}}","ref":"Dx.Result.html#find/4-examples","title":"Examples - Dx.Result.find/4","type":"function"},{"doc":"Converts 2-tuples to the internal 3-tuple result format (type `t:v()` or `t:b()`).","ref":"Dx.Result.html#from_simple/1","title":"Dx.Result.from_simple/1","type":"function"},{"doc":"iex> {:ok, 5}\n    ...> |>Dx.Result.from_simple()\n    {:ok, 5, %{}}\n\n    iex> {:error, :err}\n    ...> |>Dx.Result.from_simple()\n    {:error, :err}","ref":"Dx.Result.html#from_simple/1-examples","title":"Examples - Dx.Result.from_simple/1","type":"function"},{"doc":"Returns `{:ok, mapped_results, binds}` if all elements map to `{:ok, result, binds}`.\nOtherwise, returns `{:error, e}` on error, or `{:not_loaded, data_reqs}` with all data requirements.","ref":"Dx.Result.html#map/2","title":"Dx.Result.map/2","type":"function"},{"doc":"iex> [\n    ...>   {:ok, 1, %{}},\n    ...>   {:ok, 2, %{}},\n    ...>   {:ok, 3, %{}},\n    ...> ]\n    ...> |> Dx.Result.map()\n    {:ok, [1, 2, 3], %{}}\n\n    iex> [\n    ...>   {:ok, 1, %{}},\n    ...>   {:not_loaded, [:x]},\n    ...>   {:ok, 3, %{}},\n    ...>   {:not_loaded, [:y]},\n    ...> ]\n    ...> |> Dx.Result.map()\n    {:not_loaded, [:x, :y]}\n\n    iex> [\n    ...>   {:ok, 1, %{}},\n    ...>   {:error, :x},\n    ...>   {:ok, 3, %{}},\n    ...>   {:not_loaded, [:y]},\n    ...> ]\n    ...> |> Dx.Result.map()\n    {:error, :x}","ref":"Dx.Result.html#map/2-examples","title":"Examples - Dx.Result.map/2","type":"function"},{"doc":"Returns `{:ok, new_keyword_list, binds}` with new values if all values map to `{:ok, new_value, binds}`.\nOtherwise, returns `{:error, e}` on error, or `{:not_loaded, data_reqs}` with all data requirements.","ref":"Dx.Result.html#map_keyword_values/2","title":"Dx.Result.map_keyword_values/2","type":"function"},{"doc":"iex> [\n    ...>   a: {:ok, 1, %{}},\n    ...>   b: {:ok, 2, %{}},\n    ...>   c: {:ok, 3, %{}},\n    ...> ]\n    ...> |> Dx.Result.map_keyword_values()\n    {:ok, [a: 1, b: 2, c: 3], %{}}\n\n    iex> [\n    ...>   a: {:ok, 1, %{}},\n    ...>   b: {:not_loaded, MapSet.new([:x])},\n    ...>   c: {:ok, 3, %{}},\n    ...>   d: {:not_loaded, MapSet.new([:y])},\n    ...> ]\n    ...> |> Dx.Result.map_keyword_values()\n    {:not_loaded, MapSet.new([:x, :y])}\n\n    iex> [\n    ...>   a: {:ok, 1, %{}},\n    ...>   b: {:error, :x},\n    ...>   c: {:ok, 3, %{}},\n    ...>   d: {:not_loaded, [:y]},\n    ...> ]\n    ...> |> Dx.Result.map_keyword_values()\n    {:error, :x}","ref":"Dx.Result.html#map_keyword_values/2-examples","title":"Examples - Dx.Result.map_keyword_values/2","type":"function"},{"doc":"Returns `{:ok, new_map, binds}` with new values if all values map to `{:ok, new_value, binds}`.\nOtherwise, returns `{:error, e}` on error, or `{:not_loaded, data_reqs}` with all data requirements.","ref":"Dx.Result.html#map_values/2","title":"Dx.Result.map_values/2","type":"function"},{"doc":"iex> %{\n    ...>   a: {:ok, 1, %{}},\n    ...>   b: {:ok, 2, %{}},\n    ...>   c: {:ok, 3, %{}},\n    ...> }\n    ...> |> Dx.Result.map_values()\n    {:ok, %{a: 1, b: 2, c: 3}, %{}}\n\n    iex> %{\n    ...>   a: {:ok, 1, %{}},\n    ...>   b: {:not_loaded, MapSet.new([:x])},\n    ...>   c: {:ok, 3, %{}},\n    ...>   d: {:not_loaded, MapSet.new([:y])},\n    ...> }\n    ...> |> Dx.Result.map_values()\n    {:not_loaded, MapSet.new([:x, :y])}\n\n    iex> %{\n    ...>   a: {:ok, 1, %{}},\n    ...>   b: {:error, :x},\n    ...>   c: {:ok, 3, %{}},\n    ...>   d: {:not_loaded, [:y]},\n    ...> }\n    ...> |> Dx.Result.map_values()\n    {:error, :x}","ref":"Dx.Result.html#map_values/2-examples","title":"Examples - Dx.Result.map_values/2","type":"function"},{"doc":"Wraps a value in an `:ok` result.","ref":"Dx.Result.html#ok/2","title":"Dx.Result.ok/2","type":"function"},{"doc":"When given `{:ok, value, binds}`, runs `fun` on `value` and returns the result.\nOtherwise, returns first argument as is.","ref":"Dx.Result.html#then/2","title":"Dx.Result.then/2","type":"function"},{"doc":"Converts the internal 3-tuple result format (type `t:v()` or `t:b()`) to a 2-tuple format.","ref":"Dx.Result.html#to_simple/1","title":"Dx.Result.to_simple/1","type":"function"},{"doc":"iex> {:ok, 5, %{}}\n    ...> |>Dx.Result.to_simple()\n    {:ok, 5}\n\n    iex> {:error, :err}\n    ...> |>Dx.Result.to_simple()\n    {:error, :err}","ref":"Dx.Result.html#to_simple/1-examples","title":"Examples - Dx.Result.to_simple/1","type":"function"},{"doc":"","ref":"Dx.Result.html#to_simple_if/2","title":"Dx.Result.to_simple_if/2","type":"function"},{"doc":"When given `{:ok, value, binds}`, runs `fun` on `value` and returns `{:ok, new_value, binds}`.\nOtherwise, returns first argument as is.","ref":"Dx.Result.html#transform/2","title":"Dx.Result.transform/2","type":"function"},{"doc":"When given `{:ok, value, binds}` or `{:ok, value}`, returns `value`.\nOtherwise, raises an exception.","ref":"Dx.Result.html#unwrap!/1","title":"Dx.Result.unwrap!/1","type":"function"},{"doc":"iex> Dx.Result.unwrap!({:error, %ArgumentError{}})\n    ** (ArgumentError) argument error\n\n    iex> Dx.Result.unwrap!({:error, :not_an_exception})\n    ** (Dx.Error.Generic) Error occurred: :not_an_exception","ref":"Dx.Result.html#unwrap!/1-examples","title":"Examples - Dx.Result.unwrap!/1","type":"function"},{"doc":"Wraps a value in a compatible tuple for use with this module, if it's not wrapped already.","ref":"Dx.Result.html#wrap/1","title":"Dx.Result.wrap/1","type":"function"},{"doc":"Possible return values from conditions.","ref":"Dx.Result.html#t:b/0","title":"Dx.Result.b/0","type":"type"},{"doc":"","ref":"Dx.Result.html#t:binds/0","title":"Dx.Result.binds/0","type":"type"},{"doc":"Possible return values from resolving predicates.","ref":"Dx.Result.html#t:v/0","title":"Dx.Result.v/0","type":"type"},{"doc":"","ref":"Dx.Scope.html","title":"Dx.Scope","type":"module"},{"doc":"","ref":"Dx.Scope.html#module-components","title":"Components - Dx.Scope","type":"module"},{"doc":"Each defd function also compiles to a meta function that's a middle ground between\nan AST representation and running the actual code.\n\nIt's usually called at runtime.\n\nIt has the same arguments as the actual function, but what gets passed in is different:\n\n- when the data it represents is already loaded (i.e. passed in from non-defd context,\n  incl. preloads), `type` is passed in\n- otherwise, a scope is passed in, e.g. `%Dx.Scope{}`\n\n#### Example\n\nThis simple function with a filter:\n\n```elixir\ndefd non_archived(lists) do\n  Enum.filter(lists, &is_nil(&1.archived_at))\nend\n```\n\ncan either be called on already loaded (i.e. passed in) data, e.g.\n\n```elixir\nlists = Repo.all(TodoList)\nload!(non_archived(lists))\n```\n\nthen the meta function gets called with `{:array, TodoList}` and returns the same term.\n\nOr it can be called on a scope, e.g.\n\n```elixir\ndefd all_non_archived_lists() do\n  TodoList\n  |> non_archived()\nend\n```\n\nthen the meta function gets called with `%Dx.Scope{type: TodoList}` and returns\n`%Dx.Scope{type: TodoList, query_conditions: [archived_at: nil]}`.","ref":"Dx.Scope.html#module-meta-function","title":"Meta function - Dx.Scope","type":"module"},{"doc":"Sometimes, a scope can cover only a subset of the not-loaded data.\n\nA meta function can thus return either\n\n- {:ok, scope} if it is fully scopable\n- :error if not","ref":"Dx.Scope.html#module-partial-scope-coverage","title":"Partial scope coverage - Dx.Scope","type":"module"},{"doc":"- {:error, loader} if none of it is scopable\n- {:partial, scope, loader} if a part of it is scopable\n\n`loader` is a function that can be called just like a defd function,\ni.e. it can return `{:ok, result}` or `{:not_loaded, data_reqs}`.","ref":"Dx.Scope.html#module-later","title":"later ... - Dx.Scope","type":"module"},{"doc":"","ref":"Dx.Scope.html#add_conditions/2","title":"Dx.Scope.add_conditions/2","type":"function"},{"doc":"","ref":"Dx.Scope.html#all/1","title":"Dx.Scope.all/1","type":"function"},{"doc":"","ref":"Dx.Scope.html#extract_main_condition_candidates/1","title":"Dx.Scope.extract_main_condition_candidates/1","type":"function"},{"doc":"","ref":"Dx.Scope.html#lookup/2","title":"Dx.Scope.lookup/2","type":"function"},{"doc":"","ref":"Dx.Scope.html#main_condition_candidates/1","title":"Dx.Scope.main_condition_candidates/1","type":"function"},{"doc":"","ref":"Dx.Scope.html#maybe_load/2","title":"Dx.Scope.maybe_load/2","type":"function"},{"doc":"","ref":"Dx.Scope.html#maybe_lookup/2","title":"Dx.Scope.maybe_lookup/2","type":"function"},{"doc":"","ref":"Dx.Scope.html#to_data_req/1","title":"Dx.Scope.to_data_req/1","type":"function"},{"doc":"","ref":"Dx.Ecto.Query.TranslationError.html","title":"Dx.Ecto.Query.TranslationError","type":"exception"},{"doc":"","ref":"Dx.Ecto.Query.TranslationError.html#message/1","title":"Dx.Ecto.Query.TranslationError.message/1","type":"function"},{"doc":"","ref":"Dx.Error.Generic.html","title":"Dx.Error.Generic","type":"exception"},{"doc":"","ref":"Dx.Error.Generic.html#message/1","title":"Dx.Error.Generic.message/1","type":"function"},{"doc":"","ref":"Dx.Error.NotLoaded.html","title":"Dx.Error.NotLoaded","type":"exception"},{"doc":"","ref":"Dx.Error.NotLoaded.html#message/1","title":"Dx.Error.NotLoaded.message/1","type":"function"},{"doc":"","ref":"Dx.Error.RulesNotFound.html","title":"Dx.Error.RulesNotFound","type":"exception"},{"doc":"","ref":"Dx.Error.RulesNotFound.html#message/1","title":"Dx.Error.RulesNotFound.message/1","type":"function"},{"doc":"","ref":"Dx.Error.Timeout.html","title":"Dx.Error.Timeout","type":"exception"},{"doc":"","ref":"Dx.Error.Timeout.html#message/1","title":"Dx.Error.Timeout.message/1","type":"function"},{"doc":"# Full Reference","ref":"full_reference.html","title":"Full Reference","type":"extras"},{"doc":"`use Dx.Ecto.Schema` enables a module to specify inferences, such as\n\n```elixir\nuse Dx.Ecto.Schema\n\ninfer has_children?: true, when: %{relatives: %{relation: \"parent_of\"}}\ninfer has_children?: false\n```\n\nUnlike full-fledged inference engines (such as [calypte](https://github.com/liveforeverx/calypte)\nor [retex](https://github.com/lorenzosinisi/retex)), all rules in Dx are bound to an individual\nrecord type as their subject. This, in turn, allows to utilize Ecto schemas and queries to their full extent.","ref":"full_reference.html#augment-ecto-schema","title":"Augment Ecto schema - Full Reference","type":"extras"},{"doc":"- `infer ...` defines a **rule** in a module. It applies to an instance of that module:\n  A struct, Ecto record, Ash resource, ...\n- This instance of a module, on which rules are evaluated, is the **subject**.\n- A rule can have a **condition**, or `:when` part, that must be met in order for it to apply,\n  e.g. `%{relatives: %{relation: \"parent_of\"}}`.\n- When the condition is met, a given **predicate** is assigned a given **value**,\n  e.g. `has_children?: true`. This is also called the **result** of the rule.\n- All rules are evaluated from top to bottom until the first one for each predicate matches,\n  similar to a `cond` statement.\n- A condition can make use of other predicates as well as **fields** defined on the schema or\n  struct of the underlying type.\n- An executed rule results in a (derived) **fact**: subject, predicate, value.","ref":"full_reference.html#terminology","title":"Terminology - Full Reference","type":"extras"},{"doc":"- `Dx.get/3` evaluates the given predicate(s) using only the (pre)loaded data available, and returns the result(s)\n- `Dx.load/3` is like `get`, but loads any additional data as needed\n- `Dx.put/3` is like `load`, but puts the results into the `:inferred` field\n  (or virtual schema field) of the subject(s) as a map, and returns the subject(s)\n\nThese functions return a tuple, either `{:ok, result}`, `{:error, error}`, or `{:not_loaded, data_reqs}` (only `get`).\n\nThe corresponding `Dx.get!/3`, `Dx.load!/3` and `Dx.put!/3` functions return `result`\ndirectly, or otherwise raise an exception.\n\nArguments:\n\n- **subjects** can either be an individual subject (with the given predicates defined on it), or a list of subjects.\n  Passing an individual subject will return the predicates for the subject, passing a list will return a list of them.\n- **predicates** can either be a single predicate, or a list of predicates.\n  Passing a single predicate will return the resulting value, passing a list will return a **map**\n  of the predicates and their resulting values.\n- **options** (optional) See below.\n\nOptions:\n\n- **args** (list or map) can be used to pass in data from the caller's context that can be used in\n  rules (see _Arguments_ below). A classic example is the `current_user`, e.g.\n  ```elixir\n  Dx.put!(project, :can_edit?, args: [user: current_user])\n  ```\n- **extra_rules** (module or list of modules) can be used to add context-specific rules that are\n  not defined directly on the subject. This can be used to structure rules into their own modules\n  and use them only where needed.\n- **debug?** (boolean) makes Dx print additional information to the console as rules are evaluated.\n  Should only be used while debugging.","ref":"full_reference.html#api-overview","title":"API overview - Full Reference","type":"extras"},{"doc":"In a rule condition, the part after `when: ...`,\n\n- **Maps** represent multiple conditions, of which **all** need to be satisfied (logical `AND`).\n- **Lists** represent multiple conditions, of which **at least one** needs to be satisfied (logical `OR`).\n- Values can be negated using `{:not, \"value\"}`.\n\nExamples:\n\n```elixir\n# :role must be \"admin\"\ninfer role: :admin, when: %{role: \"admin\"}\n\n# :role must be either \"admin\" or \"superadmin\"\ninfer role: :admin, when: %{role: [\"admin\", \"superadmin\"]}\n\n# :role must be \"admin\" and :verified? must be true\ninfer role: :admin, when: %{role: \"admin\", verified?: true}\n\n# :role must be \"admin\" and :verified_at must not be nil\ninfer role: :admin, when: %{role: \"admin\", verified_at: {:not, nil}}\n```","ref":"full_reference.html#conditions","title":"Conditions - Full Reference","type":"extras"},{"doc":"A single atom is a shorthand for `%{atom: true}`.","ref":"full_reference.html#boolean-shorthand-form","title":"Boolean shorthand form - Full Reference","type":"extras"},{"doc":"When conditions are tested against list data, e.g. a person's list of roles, the condition is satisfied\nif at least one element of the list matches the given conditions (like `Enum.any?/2`).\n\nAlthough they might look similar, it's important to differentiate between lists that appear in\nconditions, and lists that appear in the data, which are checked against a condition.\n\nWhen both occur together, i.e. a list in a condition is checked against a list of values, the condition\nis met if at least one of the condition list elements applies to at least one element of the value list.\n\nFor example:\n\n```elixir\ninfer :can_edit?, when: %{roles: [\"project_manager\", \"admin\"]}\n\niex> %Person{roles: [\"worker\", \"assistant\"]} |> Dx.get!(:can_edit?)\nnil\n\niex> %Person{roles: [\"assistant\", \"project_manager\"]} |> Dx.get!(:can_edit?)\ntrue\n\niex> %Person{roles: [\"admin\"]} |> Dx.get!(:can_edit?)\ntrue\n```\n\nThe same applies to complex conditions.","ref":"full_reference.html#conditions-on-list-data","title":"Conditions on list data - Full Reference","type":"extras"},{"doc":"The assigned value of a predicate is generally assigned as is.\n\nA few special tuples, however, will be replaced by Dx (see _Features_ below)\n\nExample:\n\n```elixir\ninfer d: 4\ninfer nested: %{a: 1, b: 2, c: {:ref, :d}}  # => %{a: 1, b: 2, c: 4}\n```","ref":"full_reference.html#rule-results","title":"Rule results - Full Reference","type":"extras"},{"doc":"Syntax:\n\n- `{:ref, path}` (in conditions and result values)\n\nArguments:\n\n- **path** is a list of fields or predicates, starting from the subject.\n  The brackets can be omitted (i.a. an atom passed), if the path consists of one element.\n  The last element can be a map or list (see _Branching_ below)\n\nExample:\n\n```elixir\ninfer ot_fields: %{editable: true},\n    when: %{\n      construction_bectu?: true,\n      roles: %{\n        user: {:ref, [:args, :user]},\n        type: [\"project_manager\", \"admin\"]\n      }\n    }\n```","ref":"full_reference.html#references","title":"References - Full Reference","type":"extras"},{"doc":"Any part of the `path` that represents an underlying **list of subjects**, such as referencing\na `has_many` association, will cause the result of the `:ref` to be a list as well.\nIt basically behaves similar to `Enum.map/2`.\n\nA **map** as last element of a `path` will branch the returned result out into this map.\nThe keys are returned as is, the values must be a list (or atom) continuing that path.\nThis is particularly powerful when used on a list of subjects (see above), because it\nwill return the given map with the values at the given paths for each underlying subject:\n\nA **list** as last element of a `path` behaves like a map where each value equals its key.\n\nExamples:\n\n```elixir\ninfer list: [%{a: 1, b: 2, c: %{d: 4}}, %{a: 9, b: 8, c: %{d: 6}}]\n\ninfer result1: {:ref, [:list, :a]}  # => [1, 9]\ninfer result2: {:ref, [:list, %{x: :a, y: [:c, :d]}]}  # => [%{x: 1, y: 4}, %{x: 9, y: 6}]\ninfer result3: {:ref, [:list, [:a, :b]]}  # => [%{a: 1, b: 2}, %{a: 9, b: 8}]\n```","ref":"full_reference.html#branching","title":"Branching - Full Reference","type":"extras"},{"doc":"Passing `:args` as an option to any of the Dx API functions enables referencing the passed data\nin conditions and values using `{:ref, [:args, ...]}`.","ref":"full_reference.html#arguments","title":"Arguments - Full Reference","type":"extras"},{"doc":"It's possible to give predicates the same name as existing fields in the schema.\nThis represents the fact that these fields are derived from other data, using rules.\n\nRules on these fields can even take into account the existing value of the underlying field.\nIn order to reference it, use `:fields` in between a path or condition, for example:\n\n```elixir\nschema \"blog_posts\" do\n  field :state\n  field :published_at\nend\n\n# nilify published_at when deleted, or when it's an old archived post\ninfer published_at: nil, when: %{state: \"deleted\"}\ninfer published_at: nil, when: %{state: \"archived\", fields: %{published_at: {:before, ~D[2020-02-20]}}}\ninfer published_at: {:ref, [:fields, :published_at]}\n```\n\nWhile it's always possible to achieve a similar behavior by giving the predicate a different\nname than the field, and then mapping the predicate to the field somewhere else,\nusing the field name in conjunction with `:fields` makes explicit that it's a conditional override.","ref":"full_reference.html#overriding-existing-fields","title":"Overriding existing fields - Full Reference","type":"extras"},{"doc":"Syntax:\n\n- `{:bind, key}` (in conditions)\n- `{:bind, key, subcondition}` (in conditions)\n- `{:bound, key}` (in result values)\n- `{:bound, key, default}` (in result values)\n\nWhen a condition is evaluated on a list of values, the **first value** satisfying\nthe condition can be bound to a variable using `{:bind, variable}`.\n\nThese bound values can be referenced using `{:bound, key}` with an optional default:\n`{:bound, key, default}`.\n\n```elixir\ninfer project_manager: {:bound, :person},\n    when: %{roles: %{type: \"project_manager\", person: {:bind, :person}}}\n```","ref":"full_reference.html#binding-subject-parts","title":"Binding subject parts - Full Reference","type":"extras"},{"doc":"Syntax:\n\n- `infer_alias key: ...` (in modules before using `key` in `infer ...`)\n\nIn order to create shorthands and avoid repetition, aliases can be defined.\nThese apply only to subsequent rules within the same module and are not exposed in any other way.\n\n```elixir\ninfer_alias pm?: %{roles: %{type: [\"project_manager\", admin]}}\n\ninfer ot_fields: %{editable: true}, when: [:pm?, %{construction_bectu?: true}]\n```","ref":"full_reference.html#local-aliases","title":"Local aliases - Full Reference","type":"extras"},{"doc":"Syntax:\n\n- `{&module.fun/n, [arg_1, ..., arg_n]}` (in result values)\n- `{&module.fun/1, arg_1}` (in result values)\n\nAny function can be called to map the given arguments to other values.\nThe function arguments must be passed as a list, except if it's only one.\nArguments can be fixed values or other Dx features (passed as is), such as references.\n\n```elixir\ninfer day_of_week: {&Date.day_of_week/1, {:ref, :date}}\n\ninfer duration: {&Timex.diff/3, [{:ref, :start_datetime}, {:ref, :end_datetime}, :hours]}\n```\n\nOnly pure functions with low overhead should be used.\nDx might call them very often during evaluation (once after each loading of data).","ref":"full_reference.html#calling-functions","title":"Calling functions - Full Reference","type":"extras"},{"doc":"Syntax:\n\n- `{:query_one, type, conditions}`\n- `{:query_one, type, conditions, options}`\n- `{:query_first, type, conditions}`\n- `{:query_first, type, conditions, options}`\n- `{:query_all, type, conditions}`\n- `{:query_all, type, conditions, options}`\n\nArguments:\n\n- `type` is a module name (or Ecto queryable), e.g. an Ecto schema\n- `conditions` is a **keyword list** of fields and their respective values, or lists of values, they must match\n- `options` is a subset of the options that Ecto queries support:\n  - `order_by`\n  - `limit`","ref":"full_reference.html#querying","title":"Querying - Full Reference","type":"extras"},{"doc":"The first key-value pair has a special behavior:\nIt is used as the main condition for `Dataloader`, and thus should have the highest cardinality.\nIt must be a single value, not a list of values.\n\n_Rule of thumb:_ Put a single field that has the most unique values as first condition.","ref":"full_reference.html#conditions","title":"Conditions - Full Reference","type":"extras"},{"doc":"Syntax:\n\n- `{:filter, source, condition}` (in result values)\n- `{:map, source, mapper}` (in result values)\n- `{:map, source, bind_key/condition, mapper}` (in result values)\n\nArguments:\n\n- `source` can either be a list literal, a field or predicate that evaluates to a list,\n  or another feature such as a query.\n- `condition` has the same form and functionality as any other rule condition.\n- `mapper` can either be a field or predicate (atom), or is otherwise treated as any other rule value.\n\nThere are 3 variants:\n\n- `{:filter, source, condition}` keeps only elements from `source`, for which the `condition` is met.\n- `{:map, source, mapper}` returns the result of `mapper` for each element in `source`.\n- `{:map, source, bind_key/condition, mapper}` is a special form of `:map`, where the `mapper` is based on the\n  subject of the rule, not the list element. The list element is referenced using the middle arg, which can be either:\n  - a `bind_key` (atom) - the current list element is referenced via `{:bound, bind_key}` in the `mapper`\n  - a `condition` - any values bound in the condition via `{:bind, key, ...}` can be accessed\n    via `{:bound, key}` in the `mapper`\n\nUse the special form of `:map` only when you need to reference both the list element (via `:bound`),\nand the subject of the rule (via `:ref`).\nUsing a combination of `:filter` and basic `:map` instead is always preferred, if possible.\n\nAny `nil` elements in the list are mapped to `nil`, when using `:map` without condition.\n\nExamples:\n\n```elixir\ninfer accepted_offers: {:filter, :offers, %{state: \"accepted\"}}\n\ninfer offer_ids: {:map, :offers, :id}\n\ninfer first_offer_of_same_user:\n        {:map, :offers, %{state: \"accepted\", user_id: {:bind, :uid, {:not, nil}}},\n         {:query_first, Offer, user_id: {:bound, :uid}, project_id: {:ref, :project_id}}}\n```","ref":"full_reference.html#transforming-lists","title":"Transforming lists - Full Reference","type":"extras"},{"doc":"Syntax:\n\n- `{:count, source, condition/predicate}` (in result values)\n- `{:count_while, source, condition/predicate}` (in result values)\n\nArguments:\n\n- `source` can either be a list literal, a field or predicate that evaluates to a list,\n  or another feature such as a query.\n- `condition` has the same form and functionality as any other rule condition.\n- `predicate` can either be a predicate (atom) that returns either `true`, `false`,\n  or `:skip` (only for `:count_while`)\n\nTakes the given list and counts the elements that evaluate to `true`.\n`:count_while` stops after the first element that returns `false`.\nTo not count an element, but not stop counting either, the given predicate may return `:skip`.\nAny `nil` elements in the list are treated as `false`.","ref":"full_reference.html#counting","title":"Counting - Full Reference","type":"extras"},{"doc":"# Welcome 👋\n\nWelcome to the documentation of `Dx`, a rule-based inference engine written in Elixir.\n\nIf you're new to `Dx`, we recommend starting with the [basics](basics/00_intro.md).","ref":"welcome.html","title":"Welcome 👋","type":"extras"},{"doc":"# Introduction\n\nIn the following sections, we'll learn...\n\n- what [predicates](01_predicates.md) are, and how to define rules to assign their values\n- how [associations](02_associations.md) are easily traversed when defining rules\n- combining [conditions](03_conditions.md) to define more complex rules\n- using [references](04_references.md) to compare multiple fields or predicates with each other\n- passing in [arguments](05_arguments.md) from the outside context in which rules are evaluated\n\nFinally, we close with a chapter on [Thinking in Dx](06_thinking_in_dx.md), learn to apply\nall the lessons learnt.","ref":"00_intro.html","title":"Introduction","type":"extras"},{"doc":"# Predicates\n\nDx allows you to add predicates to your schema.\nPredicates are like virtual fields, but instead of storing values,\nyou define what the value should be, based on conditions.","ref":"01_predicates.html","title":"Predicates","type":"extras"},{"doc":"Say we have a ToDo list app with a `Todo.List` schema type.\n\n```elixir\ndefmodule Todo.List do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"lists\" do\n    field :archived_at, :utc_datetime\n  end\n\n  infer archived?: false, when: %{archived_at: nil}\n  infer archived?: true\nend\n```\n\nHere, we define a predicate `archived?` on our `Todo.List` schema.\nIt has the value `false` when the field `archived_at` is `nil`.\nIf this condition doesn't match, Dx will look at the next rule\nand assign the value `true`. Since there is no condition for this\nlast rule, it will always match.\n\n> _Tip: It is a good practice to always have a last rule without\n> condition to define a fallback value._\n\n#### Usage\n\nThis predicate can now be used like a field, as long as you use an `Dx`\nto to evaluate it, such as `Dx.get!/2`:\n\n```elixir\n# loading a predicate\niex> %Todo.List{archived_at: nil}\n...> |> Dx.get!(:archived?)\nfalse\n\niex> %Todo.List{archived_at: ~U[2022-02-02 22:22:22Z]}\n...> |> Dx.get!(:archived?)\ntrue\n```","ref":"01_predicates.html#example-boolean-predicate","title":"Example: boolean predicate - Predicates","type":"extras"},{"doc":"Instead of assigning `true` or `false`, we might define a predicate\n`state` that can be easily extended later on.\nWe can even use the existing predicate and reference it in our new rule:\n\n```elixir\ndefmodule Todo.List do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"lists\" do\n    field :archived_at, :utc_datetime\n  end\n\n  infer archived?: false, when: %{archived_at: nil}\n  infer archived?: true\n\n  infer state: :archived, when: %{archived?: true}\n  infer state: :active\nend\n```\n\n#### Usage\n\nJust as with `archived?`, we can now use `state` as if it was a field when using `Dx`:\n\n```elixir\niex> %Todo.List{archived_at: nil}\n...> |> Dx.get!(:state)\n:active\n\niex> %Todo.List{archived_at: ~U[2022-02-02 22:22:22Z]}\n...> |> Dx.get!(:state)\n:archived\n```","ref":"01_predicates.html#example-multi-value-predicate","title":"Example: multi-value predicate - Predicates","type":"extras"},{"doc":"# Associations\n\nDx allows to easily traverse associations to access fields or even\npredicates defined on associated records.\n\nSay our `Todo.List` schema from the previous guide now `has_many` tasks:\n\n```elixir\ndefmodule Todo.List do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"lists\" do\n    field :archived_at, :utc_datetime\n\n    has_many :tasks, Todo.Task\n  end\n\n  infer archived?: false, when: %{archived_at: nil}\n  infer archived?: true\n\n  infer state: :archived, when: %{archived?: true}\n  infer state: :active\nend\n```\n\nIn return, we add a Task schema that `belongs_to` a List:\n\n```elixir\ndefmodule Todo.Task do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"tasks\" do\n    field :completed_at, :utc_datetime\n\n    belongs_to :list, Todo.List\n  end\n\n  infer completed?: false, when: %{completed_at: nil}\n  infer completed?: true\nend\n```","ref":"02_associations.html","title":"Associations","type":"extras"},{"doc":"Say we want a Task to be `archived?` when the List it belongs to is archived.\nWe could write a similar rule on the `Todo.Task` schema as we have on the List:\n\n```elixir\n  infer archived?: false, when: %{list: %{archived_at: nil}}\n  infer archived?: true\n```\n\nThe `archived?` predicate looks at the associated `list` (defined using `belongs_to`)\nand its field `archived_at`, and compares that to `nil`.\nIf it's `nil` then the Task's predicate `archived?` is `false`, otherwise it's `true`.\n\nHowever, since we've already defined this logic on the List, we can also use the predicate\non the associated List instead, and change things around a bit:\n\n```elixir\n  infer archived?: true, when: %{list: %{archived?: true}}\n  infer archived?: false\n```\n\n#### Usage\n\nLike before, we can use `Dx.get!/2` to evaluate the predicate,\nbut only if the association is (pre)loaded:\n\n```elixir\niex> list = %Todo.List{archived_at: ~U[2022-02-02 22:22:22Z]} |> Todo.Repo.insert!()\n...> %Todo.Task{completed_at: nil, list: list}\n...> |> Dx.get!(:archived?)\ntrue\n```\n\nIf the association is not (pre)loaded, `Dx.get!/2` will raise an error:\n\n```elixir\niex> list = %Todo.List{archived_at: ~U[2022-02-02 22:22:22Z]} |> Todo.Repo.insert!()\n...> %Todo.Task{completed_at: nil, list: list}\n...> |> Todo.Repo.insert!() |> Todo.Repo.reload!()  # insert and reload without associations\n...> |> Dx.get!(:archived?)\n** (Dx.Error.NotLoaded) Association list is not loaded on nil. Cannot get path: nil\n```\n\nTo allow Dx to load associations as needed, use `Dx.load!/2` instead:\n\n```elixir\niex> list = %Todo.List{archived_at: ~U[2022-02-02 22:22:22Z]} |> Todo.Repo.insert!()\n...> %Todo.Task{completed_at: nil, list: list}\n...> |> Todo.Repo.insert!() |> Todo.Repo.reload!()  # insert and reload without associations\n...> |> Dx.load!(:archived?)\n# loads the associated list\ntrue\n```","ref":"02_associations.html#belongs_to","title":"belongs_to - Associations","type":"extras"},{"doc":"We can also define predicates based on a `has_many` association.\nDx generally treats conditions on a list of records like an `Enum.any?` condition:\n\n```elixir\ndefmodule Todo.List do\n  # ...\n\n  infer in_progress?: true, when: %{tasks: %{completed?: true}}\n  infer in_progress?: false\nend\n```\n\nThe predicate `in_progress?` is `true` if there's any Task associated that has `completed?: true`.\nOtherwise, if there's no Task associated that has `completed?: true`, `in_progress?` is `false`.\n\nPutting it all together, we can extend our `state` predicate on the `Todo.List` schema:\n\n```elixir\ndefmodule Todo.List do\n  # ...\n\n  infer state: :archived, when: %{archived?: true}\n  infer state: :in_progress, when: %{tasks: %{completed?: true}}\n  infer state: :ready, when: %{tasks: %{}}\n  infer state: :empty\nend\n```\n\nWhat does the `:ready` rule do?\nIt checks whether there's any Task, without any condition on the Task.\nSo if the List is not archived, and there are no completed tasks, but there is a Task,\n`:state` is `:ready`. Otherwise `:state` is `:empty`.\n\n_This might be hard to grasp, but it will hopefully become clearer in the next guide..._","ref":"02_associations.html#has_many","title":"has_many - Associations","type":"extras"},{"doc":"# Conditions\n\nWe've already seen some conditions nested using maps.","ref":"03_conditions.html","title":"Conditions","type":"extras"},{"doc":"Using maps is the go-to way of writing conditions. If you're unsure\nabout how to define a condition, use a `Map`.\n\nWhen using a `Map` with multiple elements in a condition, all of its\nelements must match for the whole condition to match. This is\nsimilar to pattern-matching in Elixir code.\n\nSay we want a `Todo.List` to only be `archivable?` if it's not\narchived yet **and** all of its tasks are completed.\n\n```elixir\ndefmodule Todo.List do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"lists\" do\n    field :archived_at, :utc_datetime\n\n    belongs_to :created_by, Todo.User\n  end\n\n  infer archived?: false, when: %{archived_at: nil}\n  infer archived?: true\n\n  infer archivable?: true,\n        when: %{\n          archived?: false,\n          tasks: {:all?, %{completed?: true}}\n        }\n\n  infer archivable?: false\nend\n```","ref":"03_conditions.html#and","title":"And - Conditions","type":"extras"},{"doc":"A logical \"or\" is expressed by an Elixir `List`. This is the first\nmajor difference to pattern-matching. It might not feel intuitive\nat first, but gets familiar fast and becomes very useful once you\ngot used to it.\n\nSay we want a `Todo.List` to be `archivable?` if its `:state` we\ndefined in the previous chapter is either `:completed` or `:ready`.\n\n```elixir\ndefmodule Todo.List do\n  # ...\n\n  infer state: :archived, when: %{archived?: true}\n  infer state: :completed, when: %{tasks: {:all?, %{completed?: true}}}\n  infer state: :in_progress, when: %{tasks: %{completed?: true}}\n  infer state: :ready, when: %{tasks: %{}}\n  infer state: :empty\n\n  infer archivable?: true, when: %{state: [:completed, :ready]}\n  infer archivable?: false\nend\n```\n\nThis is also a good example for defining predicates based on other\npredicates if they reflect how you actually think about them.\nDx will find an efficient way to evaluate them.","ref":"03_conditions.html#or","title":"Or - Conditions","type":"extras"},{"doc":"Negations can be expressed by wrapping a condition in a `:not` tuple.\n\nAnother way of expressing the `archived?` predicate from the first\nguide would thus be:\n\n```elixir\ndefmodule Todo.List do\n  # ...\n\n  infer archived?: true, when: %{archived_at: {:not, nil}}\n  infer archived?: false\n\n  # previously:\n  # infer archived?: false, when: %{archived_at: nil}\n  # infer archived?: true\nend\n```","ref":"03_conditions.html#not","title":"Not - Conditions","type":"extras"},{"doc":"# References\n\nOften times, we need to compare values in different fields with\neach other, not with fixed values. This is where references come in.\n\nSay we want to add a `by_owner?` predicate to a `Todo.Task`:\n\n```elixir\ndefmodule Todo.Task do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"tasks\" do\n    field :completed_at, :utc_datetime\n\n    belongs_to :list, Todo.List\n    belongs_to :created_by, Todo.User\n  end\n\n  infer by_owner?: true, when: %{created_by_id: {:ref, [:list, :created_by_id]}}\n  infer by_owner?: false\nend\n```","ref":"04_references.html","title":"References","type":"extras"},{"doc":"By default, all comparisons need to match exactly. However, other comparisons are possible as well.\n\nSay we support completing tasks on an already archived list.\nAnd we want to add a predicate `completed_later?` to capture that.\n\n```elixir\ndefmodule Todo.Task do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"tasks\" do\n    field :completed_at, :utc_datetime\n\n    belongs_to :list, Todo.List\n    belongs_to :created_by, Todo.User\n  end\n\n  infer completed_later?: false, when: %{completed?: false}\n  infer completed_later?: false, when: %{list: %{archived?: false}}\n  infer completed_later?: true, when: %{archived_at: {:gt, {:ref, [:list, :archived_at]}}}\n  infer completed_later?: false\nend\n```\n\nThe `Todo.Task` must already by `completed?` and the `Todo.List` `archived?`.\nIn particular, the `Todo.Task` must be `completed_at` after the `Todo.List` was archived.\n\nOperators can also compare to fixed values (not references).\n\n#### Supported operators\n\nOperators with all aliases:\n\n- Greater than: `:gt`, `:>`, `:greater_than`, `:after`\n- Greater than or equal: `:gte`, `:>=`, `:greater_than_or_equal`, `:on_or_after`, `:at_or_after`\n- Less than: `:lt`, `:<`, `:less_than`, `:before`\n- Less than or equal: `:lte`, `:<=`, `:less_than_or_equal`, `:on_or_before`, `:at_or_before`","ref":"04_references.html#operators","title":"Operators - References","type":"extras"},{"doc":"# Arguments\n\nTo pass in data from the caller context and make it available in the rules, there's the `args` option.\nAny `args` passed to the `Dx` API function will be available in rules as if `args` was\nan association on the current root record.\n\nSay we implement some authorization, where a user can archive a `Todo.List` only if they are an admin, or they are the owner of the list.\nWe pass in the currently logged-in user struct, which was already loaded as part of authentication.\n\n```elixir\nDx.load!(list, args: [current_user: current_user])\n```\n\nThe `current_user` is then available within `args`, including any\nfields, associations and predicates defined on it.\n\n```elixir\ndefmodule Todo.List do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"lists\" do\n    field :archived_at, :utc_datetime\n\n    belongs_to :created_by, Todo.User\n  end\n\n  infer can_archive?: true, when: %{args: %{current_user: %{is_admin?: true}}}\n  infer can_archive?: true, when: %{created_by_id: {:ref, [:args, :current_user, :id]}}\n  infer can_archive?: false\nend\n```","ref":"05_arguments.html","title":"Arguments","type":"extras"},{"doc":"# Thinking in Dx\n\nWhen working with Dx, we have to think top-down, as opposed to bottom-up.\nWe always start from the end result, which we want to achieve.\nAny logic and inputs needed to get to the end result are defined within Dx.","ref":"06_thinking_in_dx.html","title":"Thinking in Dx","type":"extras"},{"doc":"Say we have a complex requirement to implement:\n\n> A user can archive a Todo list, but only if they created it, or if they have an \"admin\" role,\n> and only if all tasks in the list are completed.\n\nLet's assume we only have the schema, and no other functions, helpers, or rules defined.\n\n```elixir\ndefmodule Todo.User do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"users\" do\n    has_many :roles, Todo.UserRole\n  end\nend\n\ndefmodule Todo.UserRole do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"user_roles\" do\n    field :name, Ecto.Enum, values: [:moderator, :admin, :super_admin]\n\n    belongs_to :user, Todo.User\n  end\nend\n\ndefmodule Todo.List do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"lists\" do\n    field :archived_at, :utc_datetime\n\n    belongs_to :created_by, Todo.User\n  end\nend\n\ndefmodule Todo.Task do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"tasks\" do\n    field :completed_at, :utc_datetime\n\n    belongs_to :list, Todo.List\n  end\nend\n```\n\nThe inputs are the `list` to be archived and the `current_user` who tries to archive it.\nThe end result is either the now archived list, or an error.\n\nWithout Dx, we'd write a function that takes the `list` and the `user` who tries to archive it.\nWe'd then have to think about **how** to load the data needed to compute the result, and implement it.\n\nWith Dx, we don't have to think about **how** to load the data or compute the result.\nInstead, we focus entirely on **what** is relevant and write the rules to represent this logic.\nDx then takes care of loading data as needed, in an efficient way.\n\nThinking in Dx, we usually take the following steps:\n\n1.  What are the possible end results that we need to continue in our other code, f.ex. a web request?\n    In our example, the end result can be either \"archive the list\" or \"can't archive list\".\n    In code terms, we could return `true` or `false`, or we could return `:ok` or `{:error, reason}`.\n\n    _Note:_ We think of Dx as read-only; we don't perform an action (such as archiving a list),\n    but prepare and compute all the data needed to do it.\n\n2.  What is the primary data point, on which to operate on?\n    In our example, it's rather easy: we operate on a `list`.\n    In other cases, there might be multiple candidates; in these cases, it might help to ask\n    what data type feels most intuitive to return the end results conceived in step 1.\n\n3.  Define a predicate on the main data type from step 2 with the possible values from step 1.\n    In the code where the outcome is used, f.ex. a web request, call `Dx` with the main data point\n    and this predicate. We also add additional data needed as `args`.\n\n    In our example:\n\n        # in Todo.List\n        infer archivable?: :ok\n        infer archivable?: {:error, :unauthorized}\n        infer archivable?: {:error, :pending_tasks}\n\n        # in the List controller\n        with :ok <- Dx.load!(list, :archivable?, args: [current_user: current_user]),\n             {:ok, archived_list} <- List.archive(list) do\n          render(conn, \"show.html\", list: archived_list)\n        end\n\n4.  Flesh out the conditions for the various cases. For each condition, think about what's needed\n    and how it could be called. If there's a good answer, use the term in the condition as if it\n    already existed. This way, it's easier to stay on the requirements level, using terms that make\n    sense in the app's domain.\n\n    In our example, we also reverse the order, checking all error cases first,\n    and returning `:ok` otherwise:\n\n        # in Todo.List\n        infer archivable?: {:error, :unauthorized}, when: %{can_archive?: false}\n        infer archivable?: {:error, :pending_tasks}, when: %{tasks: %{completed?: false}}\n        infer archivable?: :ok\n\n5.  Define the predicates you used on the correct schema types, and continue the process until the\n    requirements are fully defined using rules.\n\n    In our example, the final set of rules might look like this:\n\n        # in Todo.List\n        infer archivable?: {:error, :unauthorized}, when: %{can_archive?: false}\n        infer archivable?: {:error, :pending_tasks}, when: %{tasks: %{completed?: false}}\n        infer archivable?: :ok\n\n        infer can_archive?: true, when: %{args: %{current_user: %{is_admin?: true}}}\n        infer can_archive?: true, when: %{is_owner?: true}\n        infer can_archive?: false\n\n        infer is_owner?: true, when: %{created_by_id: {:ref, [:args, :current_user, :id]}}\n        infer is_owner?: false\n\n        # in Todo.User\n        infer is_admin?: true, when: %{roles: %{name: [:admin, :super_admin]}}\n        infer is_admin?: false\n\n        # in Todo.Task\n        infer completed?: true, when: %{completed_at: {:not, nil}}\n        infer completed?: false","ref":"06_thinking_in_dx.html#example","title":"Example - Thinking in Dx","type":"extras"},{"doc":"We could use the rules we defined to cover other use cases as well:\n\n#### Filtering archivable lists\n\nSay we have a list of `Todo.List` structs, and want to keep only the ones that can be archived,\nfor example to implement a web request to archive multiple lists. We use `Dx.filter/3` for it,\nwhich takes a list of data as well as a condition, just like the ones we use when defining rules:\n\n```elixir\nDx.filter(lists, %{archivable?: :ok}, args: [current_user: current_user])\n```\n\n#### Querying all archivable lists\n\nSay we want to query all lists that a given user can archive. We use `Dx.query_all/3` for it,\nwhich takes a type as well as a condition, just like the ones we use when defining rules:\n\n```elixir\nDx.query_all(Todo.List, %{archivable?: :ok}, args: [current_user: current_user])\n```","ref":"06_thinking_in_dx.html#other-use-cases-covered","title":"Other use cases covered - Thinking in Dx","type":"extras"},{"doc":"# Done 🎉\n\nWe've learnt all the basics about using Dx, and even thinking in it.\n\nThis should be enough to get you started.\n\nWe're currently writing guides on more advanced topics, so stay tuned! 🙌","ref":"99_outro.html","title":"Done 🎉","type":"extras"}],"producer":{"name":"ex_doc","version":[48,46,51,50,46,50]}}