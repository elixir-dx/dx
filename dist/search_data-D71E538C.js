searchData={"content_type":"text/markdown","items":[{"doc":"This module used to be the main entry for using the Dx API. It is now deprecated.\nPlease use `Dx.Defd` instead.\n\n- `get/3` evaluates the given predicate(s) using only the (pre)loaded data available, and returns the result(s)\n- `load/3` is like `get`, but loads any additional data as needed\n- `put/3` is like `load`, but puts the results into the `:inferred` field\n  (or virtual schema field) of the subject(s) as a map, and returns the subject(s)\n\nThese functions return a tuple, either `{:ok, result}`, `{:error, error}`, or `{:not_loaded, data_reqs}` (only `get`).\n\nThe corresponding `get!/3`, `load!/3` and `put!/3` functions return `result`\ndirectly, or otherwise raise an exception.\n\nArguments:\n- `subjects` can either be an individual subject (with the given predicates defined on it), or a list of subjects.\n  Passing an individual subject will return the predicates for the subject, passing a list will return a list of them.\n- `predicates` can either be a single predicate, or a list of predicates.\n  Passing a single predicate will return the resulting value, passing a list will return a `Map`\n  of the predicates and their resulting values.\n- `options` (optional) See below.\n\nOptions:\n- `args` (list or map) can be used to pass in data from the caller's context that can be used in\n  rules (see *Arguments* below). A classic example is the `current_user`, e.g.\n  ```elixir\n  put!(project, :can_edit?, args: [user: current_user])\n  ```\n- `extra_rules` (module or list of modules) can be used to add context-specific rules that are\n  not defined directly on the subject. This can be used to structure rules into their own modules\n  and use them only where needed.\n- `debug` (boolean) makes Dx print additional information to the console as rules are evaluated.\n  Should only be used while debugging.\n- `return_cache` (boolean) makes non-bang functions return `{:ok, result, cache}` instead of\n  `{:ok, result}` on success. This `cache` can be passed to other Dx functions (see `cache` option)\n- `cache` (`Dataloader` struct) can be used to pass in an existing cache, so data already loaded\n  doesn't need to be loaded again. Can be initialized using `Dx.Loaders.Dataloader.init/1`.\n- `loader` allows choosing a loader module. Defaults to `Dx.Loaders.Dataloader`.\n- `loader_options` are passed to `loader.init/1` function. See `Dx.Loaders.Dataloader` for options\n  supported by the default loader.","ref":"Dx.html","title":"Dx","type":"module"},{"doc":"Removes all elements not matching the given condition from the given list.","ref":"Dx.html#filter/3","title":"Dx.filter/3","type":"function"},{"doc":"Evaluates one or multiple predicates for one or multiple records and returns the results.\n\nDoes not load any additional data.","ref":"Dx.html#get/3","title":"Dx.get/3","type":"function"},{"doc":"Like `get/3` but returns the result value, or raises an error.","ref":"Dx.html#get!/3","title":"Dx.get!/3","type":"function"},{"doc":"Like `get/3`, but loads additional data if needed.","ref":"Dx.html#load/3","title":"Dx.load/3","type":"function"},{"doc":"Like `get!/3`, but loads additional data if needed.","ref":"Dx.html#load!/3","title":"Dx.load!/3","type":"function"},{"doc":"Loads the given predicate(s) for the given record(s) and merges the\nresults into the `inferred` map field of the record(s), returning them.","ref":"Dx.html#put/3","title":"Dx.put/3","type":"function"},{"doc":"Same as for `get/3`.","ref":"Dx.html#put/3-options","title":"Options - Dx.put/3","type":"function"},{"doc":"","ref":"Dx.html#put!/3","title":"Dx.put!/3","type":"function"},{"doc":"Returns all records matching the given condition.","ref":"Dx.html#query_all/3","title":"Dx.query_all/3","type":"function"},{"doc":"In general, as much work as possible is done in the database.\nIf possible, the condition is completely translated to an `Ecto.Query`\nso the database only returns matching records.\nAll condition parts that can not be translated to an `Ecto.Query`, will be\nevaluated by `loading all remaining records`, and associations as needed,\nand evaluating the rules on them.","ref":"Dx.html#query_all/3-caveat","title":"Caveat - Dx.query_all/3","type":"function"},{"doc":"Returns the first record matching the given condition.","ref":"Dx.html#query_one/3","title":"Dx.query_one/3","type":"function"},{"doc":"Same as for `query_all/3`.","ref":"Dx.html#query_one/3-options","title":"Options - Dx.query_one/3","type":"function"},{"doc":"Removes all elements matching the given condition from the given list.","ref":"Dx.html#reject/3","title":"Dx.reject/3","type":"function"},{"doc":"Dx enables you to write Elixir code as if all your Ecto data is already (pre)loaded.","ref":"Dx.Defd.html","title":"Dx.Defd","type":"module"},{"doc":"```elixir\ndefmodule MyApp.Core.Authorization do\n  import Dx.Defd\n\n  defd visible_lists(user) do\n    if admin?(user) do\n      Enum.filter(Schema.List, &(&1.title == \"Main list\"))\n    else\n      user.lists\n    end\n  end\n\n  defd admin?(user) do\n    user.role.name == \"Admin\"\n  end\nend\n```\n\nThis can be called using\n\n```elixir\nDx.Defd.load!(MyApp.Core.Authorization.visible_lists(user))\n```\n\n`Dx.Defd.load!/2` loads all required data automatically: The association `role`, and either all\n`Schema.List` matching the filter (translated to a single SQL query) or the user's associated lists,\ndepending on whether it's an admin.\n\nThese function can just as well be called for many users, and Dx will load data efficiently (with batching and concurrently).","ref":"Dx.Defd.html#module-example","title":"Example - Dx.Defd","type":"module"},{"doc":"Most server backends for web and mobile applications are split between\nthe actual application and at least one database. In their day-to-day\nprogramming, most Elixir developers have to keep that in mind and think\nabout how to store data in the database, and when and how to load it.\nIt's so deeply engrained that we often take this problem for granted,\nhaving integrated it in how we think about code and code architecture.\nFor example, Phoenix (the most popular web framework for Elixir) has\nAPI contexts that suggest structuring apps into modules that act as a\nboundary (or interface) to the rest of the code. Within these, data is\nloaded and returned. Since it's a generic interface, the simplest\napproach is to load all data that's possibly needed, and return it.\nHowever, as the app grows in functionality and thus complexity, this\nmay become a lot of data. And it's still necessary to think about what\nto return, where it's needed, and how to slice it.\n\nImagine this problem would not exist. Enter Dx.\n\nWith Dx, Elixir developers don't have to think about loading data from\nthe database at all. You just write Elixir code, as if all data is\nalready loaded and readily available.","ref":"Dx.Defd.html#module-background","title":"Background - Dx.Defd","type":"module"},{"doc":"When working with data in the database, you define Elixir functions\nusing `defd` instead of `def` (the regular Elixir function definition).\nThe `defd` function must be imported from the `Dx.Defd` module.\nWithin `defd` functions, you can write regular Elixir code, accessing\nall fields and associations as if they're already loaded. You can also\ncall other `defd` functions and structure your code in modules as usual.\n\nWhen the app is compiled, Dx translates your `defd` code into multiple\nversions with different ways to load data:\n\n- **Data loading**: Any data that might need to be loaded is wrapped in a\n  check that either returns the already loaded data, or returns a \"data\n  requirement\". Dx runs the code at the entry point (the first function\n  that's a `defd` function) and either receives the result, or receives\n  a number of data requirements. These are loaded, using the dataloader\n  library under the hood. Then the code is run again, this time either\n  returning the result, or more data requirements, and so on.\n- **Data querying**: Parts of the code may be translated to \"data scopes\",\n  which are used to generate database queries out of your code. For\n  example, using the standard library function `Enum.filter` in a `defd`\n  function will try to translate the condition (the anonymous function\n  passed as second argument) into a database query. When successful, the\n  data will not be loaded and then filtered in Elixir, but will already\n  be filtered in the database.\n\nAll this happens automatically in the background. Parts of the work are\ndone when compiling your code. Other parts are done when running it.","ref":"Dx.Defd.html#module-how-it-works","title":"How it works - Dx.Defd","type":"module"},{"doc":"Dx is designed with great care for developer experience. You can just start\nusing it, and will get warnings with explanations if something should or must\nbe done differently. It still helps to understand the main limitations:","ref":"Dx.Defd.html#module-caveats","title":"Caveats - Dx.Defd","type":"module"},{"doc":"Dx translates your code into different other versions of it. The translated\nversions may then be run any number of times, more or less often than the\noriginal would have been run. Thus, that any code defined using `defd` should\nbe **functionally pure**. This means, it should not have any side effects.\n\n- When the same code is run with the same arguments, it must always return\n  the same result. Examples for non-pure code are using date and time, or\n  random numbers.\n- `defd` functions should also not modify any external state, such as\n  modifying data in the database, or printing text to the console.\n  Except if it's fine that the modification is applied multiple times.","ref":"Dx.Defd.html#module-pure-functions","title":"Pure functions - Dx.Defd","type":"module"},{"doc":"You can call non-defd functions from within `defd` functions. However, Dx\ncan't \"look into\" them. No data inside them will be loaded, and they can\nnever be translated to database queries. They will also be run any number\nof times, so they should be pure functions as well.\n\nDx will ask you to wrap the call in a `non_dx/1` function call. This is\njust to make clear that the called function is not defined using `defd`\nwhen reading the code.","ref":"Dx.Defd.html#module-calling-non-defd-functions","title":"Calling non-defd functions - Dx.Defd","type":"module"},{"doc":"Any time a `defd` function is called from a regular Elixir function,\nthat's an **entry point**. That's where any needed data will be loaded.\n\nDx will ask you to wrap the call in a `Dx.Defd.load!/1` function call.\nThis is just to make clear that the called function is an entry point\nto `defd` land and data may be loaded here.\n\nIt may help to create dedicated modules for all `defd` functions. They\nare usually the core of the application, with much of the (business) logic.\nAny code calling into them - the entry points - in contrast, are outside\nthese modules, for example in a API function, a Phoenix controller, or an\nOban worker. This is where the data is loaded, whereas the `defd` modules\nconsist only of pure functions with (business) logic.","ref":"Dx.Defd.html#module-finding-good-entry-points","title":"Finding good entry points - Dx.Defd","type":"module"},{"doc":"Conditions can behave quite differently in SQL vs. Elixir.\nIn the future, Dx will fully translate all nuances correctly, but for now,\nyou have to keep that in mind yourself.\n\n- `NULL` never matches anything in SQL, but it does in Elixir.\n  For example, `title != \"TODO\"` when `title = nil` will match in Elixir,\n  but not match in SQL. Thus, `nil` cases must be handled individually:\n  `is_nil(title) or title != \"TODO\"`\n- Dx joins `has_one` and `belongs_to` associations using `LEFT JOIN` in\n  SQL. This means, you can happily access association chains, even if\n  interim assocation parts do not exist. This would crash in Elixir, but\n  in SQL, all fields just appear as `NULL`. Thus, the presence of\n  associations should be checked individually:\n  `not is_nil (list.creator) and is_nil(list.creator.deleted_at)`","ref":"Dx.Defd.html#module-filter-conditions-in-elixir-vs-sql","title":"Filter conditions in Elixir vs. SQL - Dx.Defd","type":"module"},{"doc":"","ref":"Dx.Defd.html#module-currently-supported","title":"Currently supported - Dx.Defd","type":"module"},{"doc":"All syntax except `for` and `with` is supported in `defd` and (private) `defdp` functions.","ref":"Dx.Defd.html#module-syntax","title":"Syntax - Dx.Defd","type":"module"},{"doc":"- All `Enum` functions\n- All `Kernel` functions **except**:\n  - `apply/2`, `apply/3`\n  - `spawn/1`, `spawn_link/1`, `spawn_monitor/1`\n  - `tap/2`\n  - `then/2`","ref":"Dx.Defd.html#module-standard-library","title":"Standard library - Dx.Defd","type":"module"},{"doc":"#### Functions\n\n- `Enum.count/1`\n- `Enum.filter/2`\n- `Enum.find/2`\n\nwill be translated to database queries, if both\n\n- the first argument is either\n  - a schema module, f.ex. `Enum.filter(Todo.Task, fn task -> task.priority == \"high\")`\n  - the result of another function listed above\n- the function passed as second argument (if any) consists only of functions listed above or:\n  - `==`, `<`, `>`\n  - `and`, `or`, `&&`\n  - `Enum.any?/2`, `Enum.all?/2`\n  - `DateTime.compare/2`","ref":"Dx.Defd.html#module-translatable-to-database-queries","title":"Translatable to database queries - Dx.Defd","type":"module"},{"doc":"Defines a function that automatically loads required data.\n\n`defd` functions are similar to regular Elixir functions defined with `def`,\nbut they allow you to write code as if all data is already loaded.\nDx will automatically handle loading the necessary data from the database\nwhen the function is called.","ref":"Dx.Defd.html#defd/2","title":"Dx.Defd.defd/2","type":"macro"},{"doc":"```elixir\ndefmodule MyApp.Core.Authorization do\n  import Dx.Defd\n\n  defd visible_lists(user) do\n    if admin?(user) do\n      Enum.filter(Schema.List, &(&1.title == \"Main list\"))\n    else\n      user.lists\n    end\n  end\n\n  defd admin?(user) do\n    user.role.name == \"Admin\"\n  end\nend\n```\n\nThis can be called using\n\n```elixir\nDx.Defd.load!(MyApp.Core.Authorization.visible_lists(user))\n```","ref":"Dx.Defd.html#defd/2-usage","title":"Usage - Dx.Defd.defd/2","type":"macro"},{"doc":"- `defd` functions should be pure and not have side effects.\n- They should not rely on external state or perform I/O operations.\n- Calls to non-`defd` functions should be wrapped in `non_dx/1`.\n- To call a `defd` function from regular Elixir code, wrap it in `Dx.Defd.load!/1`.","ref":"Dx.Defd.html#defd/2-important-notes","title":"Important notes - Dx.Defd.defd/2","type":"macro"},{"doc":"Additional options can be passed via a `@dx` attribute right before the `defd` definition:\n\n```elixir\n@dx def: :original\ndefd visible_lists(user) do\n  # ...\nend\n```\n\nAvailable options:\n\n- `def:` - Determines what the generated non-defd function should do.\n  - `:warn` (default) - Call the `defd` function wrapped in `Dx.Defd.load!/1` and emit a warning\n    asking to make the wrapping explicit.\n  - `:no_warn` - Call the `defd` function wrapped in `Dx.Defd.load!/1` without emitting a warning.\n  - `:original` - Keep the original function definition. This means, the original function can still\n    be called directly without being changed by Dx. The `defd` version *must* be called from other\n    `defd` functions or by wrapping the call in `Dx.Defd.load!/1`. This can be useful when migrating\n    existing code to Dx.\n- `debug:` - Takes one or multiple flags for printing generated code to the console. These *can* get\n  *very* verbose, because Dx generates code for many combinations of cases. All flags have a `_raw`\n  variant that prints the code without syntax highlighting.\n  - `:original` - Prints the original function definition as passed to defd. All macros are already\n    expanded at this point.\n  - `:def` - Prints the `def` version, which is the generated non-defd function. See the `def:` option.\n  - `:defd` - Prints the `defd` function definition.\n  - `:final_args` - Prints the `final_args` version, which is similar to the `defd` version but\n    can be slightly shorter for some internal optimizations. This is also the version used\n    as the entrypoint when calling `Dx.Defd.load!/1`.\n  - `:scope` - Prints the `scope` version, which is used to translate the function to SQL.\n    It returns AST-like data structures with embedded `defd` code fallbacks.\n  - `:all` - Enables all the flags.","ref":"Dx.Defd.html#defd/2-options","title":"Options - Dx.Defd.defd/2","type":"macro"},{"doc":"Private version of `defd/2`.","ref":"Dx.Defd.html#defdp/2","title":"Dx.Defd.defdp/2","type":"macro"},{"doc":"Like `load!/2` but returns a result tuple and evaluates without loading any data.\n\nReturns either\n  - `{:ok, result}` on success\n  - `{:error, error}` on failure\n  - `{:not_loaded, data_reqs}` if required data is missing\n\nSee `get!/2` for a raising alternative, and `load!/2` and `load/2` for loading alternatives.","ref":"Dx.Defd.html#get/2","title":"Dx.Defd.get/2","type":"macro"},{"doc":"Like `load!/2` but evaluates without loading any data.\n\nSee `get/2` for a non-raising alternative, and `load!/2` and `load/2` for loading alternatives.","ref":"Dx.Defd.html#get!/2","title":"Dx.Defd.get!/2","type":"macro"},{"doc":"Like `load!/2` but returns `{:ok, result}` on success, `{:error, error}` on failure.\n\nSee `load!/2` for a raising alternative, and `get!/2` and `get/2` for non-loading alternatives.","ref":"Dx.Defd.html#load/2","title":"Dx.Defd.load/2","type":"macro"},{"doc":"Wrap a `defd` function call to run it repeatedly, loading all required data.\nRaises an error if unsuccessful.\n\nSee `load/2`, `get!/2` and `get/2` for non-raising and/or non-loading alternatives.","ref":"Dx.Defd.html#load!/2","title":"Dx.Defd.load!/2","type":"macro"},{"doc":"defmodule MyApp.Core.Authorization do\n      import Dx.Defd\n\n      defd visible_lists(user) do\n        if user.role.name == \"Admin\" do\n          Enum.filter(Schema.List, &(&1.title == \"Main list\"))\n        else\n          user.lists\n        end\n      end\n    end\n\n    # Will raise if data loading fails\n    Dx.Defd.load!(MyApp.Core.Authorization.visible_lists(user))","ref":"Dx.Defd.html#load!/2-example","title":"Example - Dx.Defd.load!/2","type":"macro"},{"doc":"Used to wrap calls to non-Dx defined functions within a `defd` function.\n\nWhen writing `defd` functions, any calls to regular Elixir functions (non-`defd` functions)\nshould be wrapped with `non_dx/1`. This makes the external calls explicit and suppresses\nDx compiler warnings.","ref":"Dx.Defd.html#non_dx/1","title":"Dx.Defd.non_dx/1","type":"function"},{"doc":"defmodule MyApp.Core.Stats do\n      import Dx.Defd\n\n      def calculate_percentage(value, total) do\n        (value / total) * 100\n      end\n\n      defd user_completion_rate(user) do\n        completed = length(user.completed_tasks)\n        total = length(user.all_tasks)\n\n        # Wrap the regular def function call with non_dx\n        non_dx(calculate_percentage(completed, total))\n      end\n    end","ref":"Dx.Defd.html#non_dx/1-example","title":"Example - Dx.Defd.non_dx/1","type":"function"},{"doc":"Determines which field to batch queries by.","ref":"Dx.Ecto.Query.Batches.html","title":"Dx.Ecto.Query.Batches","type":"module"},{"doc":"We have data requirements that need to be fulfilled by\nexecuting queries.\n\nEach data requirement consists of a group, for example\na set of fixed options for running a query, and a list\nof filters, each filter being a field + value to match on.\n\nEach query can only have one field to be batched on,\ni.e. one field takes a list of values to fulfill\nmultiple data requirements.\n\nThe goal is to minimize the number of queries.\nThis is trivial when filtering by 0 or 1 fields.\nWhen filtering by 2 or more fields, some work must be\ndone to determine the ideal field to batch by.","ref":"Dx.Ecto.Query.Batches.html#module-problem","title":"Problem - Dx.Ecto.Query.Batches","type":"module"},{"doc":"We basically count the filter combinations for each\npotential field to batch on.\nEach combination consists of the field to batch on + all\nother filters as a fixed set.","ref":"Dx.Ecto.Query.Batches.html#module-approach","title":"Approach - Dx.Ecto.Query.Batches","type":"module"},{"doc":"iex> add_filters(:query1, [color: \"red\", char: \"A\"])\n    ...> |> get_batches()\n    [\n      query1: [\n        {:char, [\"A\"], color: \"red\"}\n      ]\n    ]\n\n    iex> add_filters(:query1, [color: \"red\", char: \"A\"])\n    ...> |> add_filters(:query1, [color: \"blue\", char: \"A\"])\n    ...> |> get_batches()\n    [\n      query1: [\n        {:color, [\"blue\", \"red\"], char: \"A\"}\n      ]\n    ]\n\n    iex> add_filters(:query1, [color: \"red\", char: \"A\", size: \"L\"])\n    ...> |> add_filters(:query1, [color: \"blue\", size: \"S\", char: \"A\"])\n    ...> |> add_filters(:query1, [color: \"pink\", size: \"S\", char: \"B\"])\n    ...> |> add_filters(:query1, [color: \"pink\", size: \"S\", char: \"A\"])\n    ...> |> get_batches()\n    [\n      query1: [\n        {:char, [\"A\"], color: \"blue\", size: \"S\"},\n        {:char, [\"A\", \"B\"], color: \"pink\", size: \"S\"},\n        {:char, [\"A\"], color: \"red\", size: \"L\"}\n      ]\n    ]\n\n    iex> add_filters(:query1, [color: \"red\"])\n    ...> |> add_filters(:query1, [color: \"blue\"])\n    ...> |> get_batches()\n    [\n      query1: [\n        {:color, [\"blue\", \"red\"], []}\n      ]\n    ]\n\n    iex> add_filters(:query1, [])\n    ...> |> get_batches()\n    [\n      query1: [\n        {}\n      ]\n    ]","ref":"Dx.Ecto.Query.Batches.html#module-examples","title":"Examples - Dx.Ecto.Query.Batches","type":"module"},{"doc":"Adds one data requirement, consisting of a group + list of filters,\nto a given (or newly initialized) state","ref":"Dx.Ecto.Query.Batches.html#add_filters/3","title":"Dx.Ecto.Query.Batches.add_filters/3","type":"function"},{"doc":"Returns an optimal set of batches for the given state returned by the\nother functions.","ref":"Dx.Ecto.Query.Batches.html#get_batches/1","title":"Dx.Ecto.Query.Batches.get_batches/1","type":"function"},{"doc":"[\n      group1: [\n        {:batch_key, list_of_values, other_filters_keyword},\n        # ...\n      ],\n      # ...\n    ]","ref":"Dx.Ecto.Query.Batches.html#get_batches/1-format","title":"Format - Dx.Ecto.Query.Batches.get_batches/1","type":"function"},{"doc":"","ref":"Dx.Ecto.Query.Batches.html#map_put_in/3","title":"Dx.Ecto.Query.Batches.map_put_in/3","type":"function"},{"doc":"Initializes a new state to call other functions on","ref":"Dx.Ecto.Query.Batches.html#new/0","title":"Dx.Ecto.Query.Batches.new/0","type":"function"},{"doc":"See `Dx`.","ref":"Dx.Ecto.Schema.html","title":"Dx.Ecto.Schema","type":"module"},{"doc":"Result types and helpers to work with them.\n\nA result is either:\n\n  - `{:error, e}` if an error occurred\n  - `{:not_loaded, data_reqs}` if the result could not be determined without loading more data\n  - `{:ok, boolean, binds}` otherwise, in contexts where a boolean is expected (type `t:b()`)\n  - `{:ok, result, binds}` otherwise, where `result` can be any value (type `t:v()`)","ref":"Dx.Result.html","title":"Dx.Result","type":"module"},{"doc":"In general, `{:not_loaded, all_reqs}` only ever returns data requirements that are really needed.","ref":"Dx.Result.html#module-data-loading","title":"Data loading - Dx.Result","type":"module"},{"doc":"For example, using `all?/1` with 3 conditions A, B and C, where\n\n    iex> [\n    ...>   {:ok, true, %{}},   # A\n    ...>   {:not_loaded, [1]}, # B\n    ...>   {:ok, false, %{}},  # C\n    ...> ]\n    ...> |> Dx.Result.all?()\n    {:ok, false, %{}}\n\nThe overall result is `{:ok, false, %{}}`.\nWhile B would need more data to be loaded, C can already determined and is `false`,\nso and any additional data loaded will not change that.","ref":"Dx.Result.html#module-example-using-all","title":"Example using `all` - Dx.Result","type":"module"},{"doc":"Another example, using `find/1` with 5 conditions A, B, C, D and E, where\n\n    iex> [\n    ...>   {:ok, false, %{}},  # A\n    ...>   {:not_loaded, [1]}, # B\n    ...>   {:not_loaded, [2]}, # C\n    ...>   {:ok, true, %{}},   # D\n    ...>   {:not_loaded, [3]}, # E\n    ...> ]\n    ...> |> Dx.Result.find()\n    {:not_loaded, [1, 2]}\n\nThe overall result is `{:not_loaded, data_reqs1 + data_reqs2}`.\nWhile D can already be determined and is `{:ok, true, %{}}`, B and C come first and need more data\nto be loaded, so they can be determined and returned if either is `{:ok, true, %{}}` first.\nAll data requirements that might be needed are returned together in the result (those of B and C),\nwhile those of E can be ruled out, as D already returns `{:ok, true, %{}}` and comes first.","ref":"Dx.Result.html#module-example-using-find","title":"Example using `find` - Dx.Result","type":"module"},{"doc":"Returns `{:ok, true}` if `fun` evaluates to `{:ok, true}` for all elements in `enum`.\nOtherwise, returns `{:not_loaded, data_reqs}` if any yield that.\nOtherwise, returns `{:ok, false}`.","ref":"Dx.Result.html#all?/2","title":"Dx.Result.all?/2","type":"function"},{"doc":"iex> [\n    ...>   {:ok, true, %{}},\n    ...>   {:not_loaded, []},\n    ...>   {:ok, false, %{}},\n    ...> ]\n    ...> |> Dx.Result.all?()\n    {:ok, false, %{}}\n\n    iex> [\n    ...>   {:ok, true, %{}},\n    ...>   {:not_loaded, []},\n    ...>   {:ok, true, %{}},\n    ...> ]\n    ...> |> Dx.Result.all?()\n    {:not_loaded, []}\n\n    iex> [\n    ...>   {:ok, true, %{}},\n    ...>   {:ok, true, %{}},\n    ...> ]\n    ...> |> Dx.Result.all?()\n    {:ok, true, %{}}","ref":"Dx.Result.html#all?/2-examples","title":"Examples - Dx.Result.all?/2","type":"function"},{"doc":"Returns `{:ok, true, binds}` if `fun` evaluates to `{:ok, true, binds}` for any element in `enum`.\nOtherwise, returns `{:not_loaded, data_reqs}` if any yields that.\nOtherwise, returns `{:ok, false, %{}}`.","ref":"Dx.Result.html#any?/2","title":"Dx.Result.any?/2","type":"function"},{"doc":"iex> [\n    ...>   {:ok, true, %{a: 1}},\n    ...>   {:not_loaded, []},\n    ...>   {:ok, false, %{}},\n    ...> ]\n    ...> |> Dx.Result.any?()\n    {:ok, true, %{a: 1}}\n\n    iex> [\n    ...>   {:ok, false, %{}},\n    ...>   {:not_loaded, []},\n    ...>   {:ok, false, %{}},\n    ...> ]\n    ...> |> Dx.Result.any?()\n    {:not_loaded, []}\n\n    iex> [\n    ...>   {:ok, false, %{}},\n    ...>   {:ok, false, %{}},\n    ...> ]\n    ...> |> Dx.Result.any?()\n    {:ok, false, %{}}","ref":"Dx.Result.html#any?/2-examples","title":"Examples - Dx.Result.any?/2","type":"function"},{"doc":"If ok, binds the result to the given key and returns the updated tuple.\nOtherwise, returns first argument as is.","ref":"Dx.Result.html#bind/3","title":"Dx.Result.bind/3","type":"function"},{"doc":"Returns the number of elements for which `fun` evaluates to `{:ok, true}`.\nIf any elements return `{:not_loaded, data_reqs}`, returns all of them combined as `{:not_loaded, ...}`.\nOtherwise, returns `{:ok, default}`.","ref":"Dx.Result.html#count/2","title":"Dx.Result.count/2","type":"function"},{"doc":"iex> [\n    ...>   {:ok, true, %{}},\n    ...>   {:ok, false, %{}},\n    ...>   {:ok, true, %{}},\n    ...> ]\n    ...> |> Dx.Result.count()\n    {:ok, 2, %{}}\n\n    iex> [\n    ...>   {:ok, false, %{}},\n    ...>   {:not_loaded, [1]},\n    ...>   {:not_loaded, [2]},\n    ...>   {:ok, true, %{}},\n    ...>   {:not_loaded, [3]},\n    ...> ]\n    ...> |> Dx.Result.count()\n    {:not_loaded, [1, 2, 3]}\n\n    iex> [\n    ...>   {:ok, true, %{}},\n    ...>   {:ok, :skip, %{}},\n    ...>   {:ok, false, %{}},\n    ...>   {:ok, false, %{}},\n    ...> ]\n    ...> |> Dx.Result.count()\n    {:ok, 1, %{}}\n\n    iex> [\n    ...>   false,\n    ...>   false,\n    ...> ]\n    ...> |> Dx.Result.count(&{:ok, not &1, %{}})\n    {:ok, 2, %{}}","ref":"Dx.Result.html#count/2-examples","title":"Examples - Dx.Result.count/2","type":"function"},{"doc":"Returns the number of elements before `fun` evaluates to `{:ok, false}` or an element is `nil`.\nElements are skipped (not counted) whenever `fun` evaluates to `{:ok, :skip}`.\nIf any elements before that return `{:not_loaded, data_reqs}`, returns all of them combined as `{:not_loaded, ...}`.\nOtherwise, returns `{:ok, default}`.","ref":"Dx.Result.html#count_while/2","title":"Dx.Result.count_while/2","type":"function"},{"doc":"iex> [\n    ...>   {:ok, true, %{}},\n    ...>   {:not_loaded, []},\n    ...>   {:ok, false, %{}},\n    ...> ]\n    ...> |> Dx.Result.count_while()\n    {:not_loaded, []}\n\n    iex> [\n    ...>   {:ok, false, %{}},\n    ...>   {:not_loaded, [1]},\n    ...>   {:not_loaded, [2]},\n    ...>   {:ok, true, %{}},\n    ...>   {:not_loaded, [3]},\n    ...> ]\n    ...> |> Dx.Result.count_while()\n    {:ok, 0, %{}}\n\n    iex> [\n    ...>   {:ok, true, %{}},\n    ...>   {:ok, :skip, %{}},\n    ...>   {:ok, false, %{}},\n    ...>   {:ok, false, %{}},\n    ...> ]\n    ...> |> Dx.Result.count_while()\n    {:ok, 1, %{}}\n\n    iex> [\n    ...>   false,\n    ...>   false,\n    ...> ]\n    ...> |> Dx.Result.count_while(&{:ok, not &1, %{}})\n    {:ok, 2, %{}}","ref":"Dx.Result.html#count_while/2-examples","title":"Examples - Dx.Result.count_while/2","type":"function"},{"doc":"","ref":"Dx.Result.html#filter_map/3","title":"Dx.Result.filter_map/3","type":"function"},{"doc":"Returns `{:ok, elem}` for the first `elem` for which `fun` evaluates to `{:ok, true}`.\nIf any elements before that return `{:not_loaded, data_reqs}`, returns all of them combined as `{:not_loaded, ...}`.\nOtherwise, returns `{:ok, default}`.","ref":"Dx.Result.html#find/4","title":"Dx.Result.find/4","type":"function"},{"doc":"iex> [\n    ...>   {:ok, true, %{}},\n    ...>   {:not_loaded, []},\n    ...>   {:ok, false, %{}},\n    ...> ]\n    ...> |> Dx.Result.find()\n    {:ok, {:ok, true, %{}}, %{}}\n\n    iex> [\n    ...>   {:ok, false, %{}},\n    ...>   {:not_loaded, [1]},\n    ...>   {:not_loaded, [2]},\n    ...>   {:ok, true, %{}},\n    ...>   {:not_loaded, [3]},\n    ...> ]\n    ...> |> Dx.Result.find()\n    {:not_loaded, [1, 2]}\n\n    iex> [\n    ...>   {:ok, false, %{}},\n    ...>   {:ok, false, %{}},\n    ...> ]\n    ...> |> Dx.Result.find()\n    {:ok, nil, %{}}\n\n    iex> [\n    ...>   false,\n    ...>   false,\n    ...> ]\n    ...> |> Dx.Result.find(&{:ok, not &1, %{}})\n    {:ok, false, %{}}","ref":"Dx.Result.html#find/4-examples","title":"Examples - Dx.Result.find/4","type":"function"},{"doc":"Converts 2-tuples to the internal 3-tuple result format (type `t:v()` or `t:b()`).","ref":"Dx.Result.html#from_simple/1","title":"Dx.Result.from_simple/1","type":"function"},{"doc":"iex> {:ok, 5}\n    ...> |>Dx.Result.from_simple()\n    {:ok, 5, %{}}\n\n    iex> {:error, :err}\n    ...> |>Dx.Result.from_simple()\n    {:error, :err}","ref":"Dx.Result.html#from_simple/1-examples","title":"Examples - Dx.Result.from_simple/1","type":"function"},{"doc":"Returns `{:ok, mapped_results, binds}` if all elements map to `{:ok, result, binds}`.\nOtherwise, returns `{:error, e}` on error, or `{:not_loaded, data_reqs}` with all data requirements.","ref":"Dx.Result.html#map/2","title":"Dx.Result.map/2","type":"function"},{"doc":"iex> [\n    ...>   {:ok, 1, %{}},\n    ...>   {:ok, 2, %{}},\n    ...>   {:ok, 3, %{}},\n    ...> ]\n    ...> |> Dx.Result.map()\n    {:ok, [1, 2, 3], %{}}\n\n    iex> [\n    ...>   {:ok, 1, %{}},\n    ...>   {:not_loaded, [:x]},\n    ...>   {:ok, 3, %{}},\n    ...>   {:not_loaded, [:y]},\n    ...> ]\n    ...> |> Dx.Result.map()\n    {:not_loaded, [:x, :y]}\n\n    iex> [\n    ...>   {:ok, 1, %{}},\n    ...>   {:error, :x},\n    ...>   {:ok, 3, %{}},\n    ...>   {:not_loaded, [:y]},\n    ...> ]\n    ...> |> Dx.Result.map()\n    {:error, :x}","ref":"Dx.Result.html#map/2-examples","title":"Examples - Dx.Result.map/2","type":"function"},{"doc":"Returns `{:ok, new_keyword_list, binds}` with new values if all values map to `{:ok, new_value, binds}`.\nOtherwise, returns `{:error, e}` on error, or `{:not_loaded, data_reqs}` with all data requirements.","ref":"Dx.Result.html#map_keyword_values/2","title":"Dx.Result.map_keyword_values/2","type":"function"},{"doc":"iex> [\n    ...>   a: {:ok, 1, %{}},\n    ...>   b: {:ok, 2, %{}},\n    ...>   c: {:ok, 3, %{}},\n    ...> ]\n    ...> |> Dx.Result.map_keyword_values()\n    {:ok, [a: 1, b: 2, c: 3], %{}}\n\n    iex> [\n    ...>   a: {:ok, 1, %{}},\n    ...>   b: {:not_loaded, MapSet.new([:x])},\n    ...>   c: {:ok, 3, %{}},\n    ...>   d: {:not_loaded, MapSet.new([:y])},\n    ...> ]\n    ...> |> Dx.Result.map_keyword_values()\n    {:not_loaded, MapSet.new([:x, :y])}\n\n    iex> [\n    ...>   a: {:ok, 1, %{}},\n    ...>   b: {:error, :x},\n    ...>   c: {:ok, 3, %{}},\n    ...>   d: {:not_loaded, [:y]},\n    ...> ]\n    ...> |> Dx.Result.map_keyword_values()\n    {:error, :x}","ref":"Dx.Result.html#map_keyword_values/2-examples","title":"Examples - Dx.Result.map_keyword_values/2","type":"function"},{"doc":"Returns `{:ok, new_map, binds}` with new values if all values map to `{:ok, new_value, binds}`.\nOtherwise, returns `{:error, e}` on error, or `{:not_loaded, data_reqs}` with all data requirements.","ref":"Dx.Result.html#map_values/2","title":"Dx.Result.map_values/2","type":"function"},{"doc":"iex> %{\n    ...>   a: {:ok, 1, %{}},\n    ...>   b: {:ok, 2, %{}},\n    ...>   c: {:ok, 3, %{}},\n    ...> }\n    ...> |> Dx.Result.map_values()\n    {:ok, %{a: 1, b: 2, c: 3}, %{}}\n\n    iex> %{\n    ...>   a: {:ok, 1, %{}},\n    ...>   b: {:not_loaded, MapSet.new([:x])},\n    ...>   c: {:ok, 3, %{}},\n    ...>   d: {:not_loaded, MapSet.new([:y])},\n    ...> }\n    ...> |> Dx.Result.map_values()\n    {:not_loaded, MapSet.new([:x, :y])}\n\n    iex> %{\n    ...>   a: {:ok, 1, %{}},\n    ...>   b: {:error, :x},\n    ...>   c: {:ok, 3, %{}},\n    ...>   d: {:not_loaded, [:y]},\n    ...> }\n    ...> |> Dx.Result.map_values()\n    {:error, :x}","ref":"Dx.Result.html#map_values/2-examples","title":"Examples - Dx.Result.map_values/2","type":"function"},{"doc":"Wraps a value in an `:ok` result.","ref":"Dx.Result.html#ok/2","title":"Dx.Result.ok/2","type":"function"},{"doc":"When given `{:ok, value, binds}`, runs `fun` on `value` and returns the result.\nOtherwise, returns first argument as is.","ref":"Dx.Result.html#then/2","title":"Dx.Result.then/2","type":"function"},{"doc":"Converts the internal 3-tuple result format (type `t:v()` or `t:b()`) to a 2-tuple format.","ref":"Dx.Result.html#to_simple/1","title":"Dx.Result.to_simple/1","type":"function"},{"doc":"iex> {:ok, 5, %{}}\n    ...> |>Dx.Result.to_simple()\n    {:ok, 5}\n\n    iex> {:error, :err}\n    ...> |>Dx.Result.to_simple()\n    {:error, :err}","ref":"Dx.Result.html#to_simple/1-examples","title":"Examples - Dx.Result.to_simple/1","type":"function"},{"doc":"","ref":"Dx.Result.html#to_simple_if/2","title":"Dx.Result.to_simple_if/2","type":"function"},{"doc":"When given `{:ok, value, binds}`, runs `fun` on `value` and returns `{:ok, new_value, binds}`.\nOtherwise, returns first argument as is.","ref":"Dx.Result.html#transform/2","title":"Dx.Result.transform/2","type":"function"},{"doc":"When given `{:ok, value, binds}` or `{:ok, value}`, returns `value`.\nOtherwise, raises an exception.","ref":"Dx.Result.html#unwrap!/1","title":"Dx.Result.unwrap!/1","type":"function"},{"doc":"iex> Dx.Result.unwrap!({:error, %ArgumentError{}})\n    ** (ArgumentError) argument error\n\n    iex> Dx.Result.unwrap!({:error, :not_an_exception})\n    ** (Dx.Error.Generic) Error occurred: :not_an_exception","ref":"Dx.Result.html#unwrap!/1-examples","title":"Examples - Dx.Result.unwrap!/1","type":"function"},{"doc":"Wraps a value in a compatible tuple for use with this module, if it's not wrapped already.","ref":"Dx.Result.html#wrap/1","title":"Dx.Result.wrap/1","type":"function"},{"doc":"Possible return values from conditions.","ref":"Dx.Result.html#t:b/0","title":"Dx.Result.b/0","type":"type"},{"doc":"","ref":"Dx.Result.html#t:binds/0","title":"Dx.Result.binds/0","type":"type"},{"doc":"Possible return values from resolving predicates.","ref":"Dx.Result.html#t:v/0","title":"Dx.Result.v/0","type":"type"},{"doc":"Used to make existing libraries compatible with `Dx.Defd`.","ref":"Dx.Defd.Ext.html","title":"Dx.Defd.Ext","type":"behaviour"},{"doc":"```elixir\ndefmodule MyExt do\n  use Dx.Defd.Ext\n\n  @impl true\n  def __fun_info(fun_name, arity) do\n    %FunInfo{args: [:preload_scope, %{}, :final_args_fn]}\n  end\nend\n```","ref":"Dx.Defd.Ext.html#module-usage","title":"Usage - Dx.Defd.Ext","type":"behaviour"},{"doc":"Return a map with the following keys:\n\n- `args` - list or map of argument indexes mapping to argument information\n  - `:atom_to_scope` - whether to wrap atoms in `Dx.Scope.all/1`\n  - `:preload_scope` - tells the compiler to load any scopes passed via this argument\n  - `:fn` - tells the compiler to unwrap any Dx-specific function definitions\n  - `{:fn, arity: 2, warn_not_ok: \"Can't load data here\"}` - pass more information about the function\n  - `:final_args_fn` - like `fn` but assumes that no scopes can be passed to the function in this argument\n  - `{:final_args_fn, arity: 2, warn_always: \"Don't use this function\"}` - pass more information about the function\n  - `%{}` - placeholder for an argument without any special information\n- `warn_not_ok` - compiler warning to display when the function possibly loads data\n- `warn_always` - compiler warning to display when the function is used","ref":"Dx.Defd.Ext.html#module-options","title":"Options - Dx.Defd.Ext","type":"behaviour"},{"doc":"This callback is used to provide information about a function to `Dx.Defd`.","ref":"Dx.Defd.Ext.html#c:__fun_info/2","title":"Dx.Defd.Ext.__fun_info/2","type":"callback"},{"doc":"","ref":"Dx.Defd.Ext.html#defd_/1","title":"Dx.Defd.Ext.defd_/1","type":"macro"},{"doc":"","ref":"Dx.Defd.Ext.html#defd_/2","title":"Dx.Defd.Ext.defd_/2","type":"macro"},{"doc":"","ref":"Dx.Defd.Ext.html#defscope/1","title":"Dx.Defd.Ext.defscope/1","type":"macro"},{"doc":"","ref":"Dx.Defd.Ext.html#defscope/2","title":"Dx.Defd.Ext.defscope/2","type":"macro"},{"doc":"Internal wrapper for a function.\n\nThis includes multiple compiled versions of the function, plus some meta information on whether\nthe function can ever load any data (i.e. return `{:not_loaded, ...}` instead of `{:ok, ...}`).\n\nThe `final_args` versions assume that arguments are already finalized, i.e. hold no `Dx.Scope` or\n`Dx.Defd.Fn` structs.","ref":"Dx.Defd.Fn.html","title":"Dx.Defd.Fn","type":"module"},{"doc":"Extracts the defd-compatible function from a `Dx.Defd.Fn` struct if given one, otherwise returns the input unchanged.","ref":"Dx.Defd.Fn.html#maybe_unwrap/1","title":"Dx.Defd.Fn.maybe_unwrap/1","type":"function"},{"doc":"Extracts the `final_args_ok_fun` from a `Dx.Defd.Fn` struct if given one, otherwise returns the input unchanged.\nThe `final_args_ok_fun` assumes final arguments and is guaranteed to return `{:ok, result}`.","ref":"Dx.Defd.Fn.html#maybe_unwrap_final_args_ok/1","title":"Dx.Defd.Fn.maybe_unwrap_final_args_ok/1","type":"function"},{"doc":"Extracts the `ok_fun` from a `Dx.Defd.Fn` struct if given one, otherwise returns the input unchanged.\nThe `ok_fun` is guaranteed to return `{:ok, result}`.","ref":"Dx.Defd.Fn.html#maybe_unwrap_ok/1","title":"Dx.Defd.Fn.maybe_unwrap_ok/1","type":"function"},{"doc":"Convert a function or `Dx.Defd.Fn` struct to a function returning a `Dx.Defd.Result`.","ref":"Dx.Defd.Fn.html#to_defd_fun/1","title":"Dx.Defd.Fn.to_defd_fun/1","type":"function"},{"doc":"A wrapper struct for a function with multiple compiled versions and metadata.\n\nFields:\n- `:ok?` - Whether the function can be guaranteed to return `{:ok, result}`\n- `:final_args_ok?` - Whether the function can be guaranteed to return `{:ok, result}` when given final arguments\n- `:fun` - defd-compatible function that may return `{:not_loaded, ...}` or `{:ok, ...}`\n- `:ok_fun` - Version of function guaranteed to return `{:ok, ...}` (can be nil)\n- `:final_args_fun` - Version of function that assumes final arguments\n- `:final_args_ok_fun` - Version of function that assumes final arguments and returns `{:ok, ...}` (can be nil)\n- `:scope` - scope version of the function. See `Dx.Scope`.","ref":"Dx.Defd.Fn.html#t:t/0","title":"Dx.Defd.Fn.t/0","type":"type"},{"doc":"Collection of functions to work with Dx-internal result types.\n\nA result is either:\n\n  - `{:error, e}` if an error occurred\n  - `{:not_loaded, data_reqs}` if the result could not be determined without loading more data\n  - `{:ok, result}` otherwise\n    - `result` can also be a `Dx.Scope` or a `Dx.Defd.Fn`","ref":"Dx.Defd.Result.html","title":"Dx.Defd.Result","type":"module"},{"doc":"In general, `{:not_loaded, all_reqs}` only ever returns data requirements that are really needed.","ref":"Dx.Defd.Result.html#module-data-loading","title":"Data loading - Dx.Defd.Result","type":"module"},{"doc":"For example, using `all?/1` with 3 conditions A, B and C, where\n\n    iex> [\n    ...>   {:ok, true},   # A\n    ...>   {:not_loaded, [1]}, # B\n    ...>   {:ok, false},  # C\n    ...> ]\n    ...> |> Dx.Defd.Result.all?()\n    {:ok, false}\n\nThe overall result is `{:ok, false}`.\nWhile B would need more data to be loaded, C can already determined and is `false`,\nso and any additional data loaded will not change that.","ref":"Dx.Defd.Result.html#module-example-using-all","title":"Example using `all` - Dx.Defd.Result","type":"module"},{"doc":"Another example, using `find/1` with 5 conditions A, B, C, D and E, where\n\n    iex> [\n    ...>   {:ok, false},  # A\n    ...>   {:not_loaded, [1]}, # B\n    ...>   {:not_loaded, [2]}, # C\n    ...>   {:ok, true},   # D\n    ...>   {:not_loaded, [3]}, # E\n    ...> ]\n    ...> |> Dx.Defd.Result.find()\n    {:not_loaded, [1, 2]}\n\nThe overall result is `{:not_loaded, data_reqs1 + data_reqs2}`.\nWhile D can already be determined and is `{:ok, true}`, B and C come first and need more data\nto be loaded, so they can be determined and returned if either is `{:ok, true}` first.\nAll data requirements that might be needed are returned together in the result (those of B and C),\nwhile those of E can be ruled out, as D already returns `{:ok, true}` and comes first.","ref":"Dx.Defd.Result.html#module-example-using-find","title":"Example using `find` - Dx.Defd.Result","type":"module"},{"doc":"Returns `{:ok, true}` if `fun` evaluates to `{:ok, true}` for all elements in `enum`.\nOtherwise, returns `{:not_loaded, data_reqs}` if any yield that.\nOtherwise, returns `{:ok, false}`.","ref":"Dx.Defd.Result.html#all?/2","title":"Dx.Defd.Result.all?/2","type":"function"},{"doc":"iex> [\n    ...>   {:ok, true},\n    ...>   {:not_loaded, []},\n    ...>   {:ok, false},\n    ...> ]\n    ...> |> Dx.Defd.Result.all?()\n    {:ok, false}\n\n    iex> [\n    ...>   {:ok, true},\n    ...>   {:not_loaded, []},\n    ...>   {:ok, true},\n    ...> ]\n    ...> |> Dx.Defd.Result.all?()\n    {:not_loaded, []}\n\n    iex> [\n    ...>   {:ok, true},\n    ...>   {:ok, true},\n    ...> ]\n    ...> |> Dx.Defd.Result.all?()\n    {:ok, true}","ref":"Dx.Defd.Result.html#all?/2-examples","title":"Examples - Dx.Defd.Result.all?/2","type":"function"},{"doc":"Returns `{:ok, true}` if `fun` evaluates to `{:ok, true}` for any element in `enum`.\nOtherwise, returns `{:not_loaded, data_reqs}` if any yields that.\nOtherwise, returns `{:ok, false}`.","ref":"Dx.Defd.Result.html#any?/2","title":"Dx.Defd.Result.any?/2","type":"function"},{"doc":"iex> [\n    ...>   {:ok, true},\n    ...>   {:not_loaded, []},\n    ...>   {:ok, false},\n    ...> ]\n    ...> |> Dx.Defd.Result.any?()\n    {:ok, true}\n\n    iex> [\n    ...>   {:ok, false},\n    ...>   {:not_loaded, []},\n    ...>   {:ok, false},\n    ...> ]\n    ...> |> Dx.Defd.Result.any?()\n    {:not_loaded, []}\n\n    iex> [\n    ...>   {:ok, false},\n    ...>   {:ok, false},\n    ...> ]\n    ...> |> Dx.Defd.Result.any?()\n    {:ok, false}","ref":"Dx.Defd.Result.html#any?/2-examples","title":"Examples - Dx.Defd.Result.any?/2","type":"function"},{"doc":"","ref":"Dx.Defd.Result.html#collect/1","title":"Dx.Defd.Result.collect/1","type":"function"},{"doc":"","ref":"Dx.Defd.Result.html#collect_map_pairs/1","title":"Dx.Defd.Result.collect_map_pairs/1","type":"function"},{"doc":"","ref":"Dx.Defd.Result.html#collect_ok/1","title":"Dx.Defd.Result.collect_ok/1","type":"function"},{"doc":"","ref":"Dx.Defd.Result.html#collect_ok_reverse/2","title":"Dx.Defd.Result.collect_ok_reverse/2","type":"function"},{"doc":"Returns `{:ok, mapped_results}` if all elements map to `{:ok, result}`.\nOtherwise, returns `{:error, e}` on error, or `{:not_loaded, data_reqs}` with all data requirements.","ref":"Dx.Defd.Result.html#collect_reverse/2","title":"Dx.Defd.Result.collect_reverse/2","type":"function"},{"doc":"iex> [\n    ...>   {:ok, 1},\n    ...>   {:ok, 2},\n    ...>   {:ok, 3},\n    ...> ]\n    ...> |> Dx.Defd.Result.collect_reverse()\n    {:ok, [3, 2, 1]}\n\n    iex> [\n    ...>   {:ok, 1},\n    ...>   {:not_loaded, [:x]},\n    ...>   {:ok, 3},\n    ...>   {:not_loaded, [:y]},\n    ...> ]\n    ...> |> Dx.Defd.Result.collect_reverse()\n    {:not_loaded, [:y, :x]}\n\n    iex> [\n    ...>   {:ok, 1},\n    ...>   {:error, :x},\n    ...>   {:ok, 3},\n    ...>   {:not_loaded, [:y]},\n    ...> ]\n    ...> |> Dx.Defd.Result.collect_reverse()\n    {:error, :x}","ref":"Dx.Defd.Result.html#collect_reverse/2-examples","title":"Examples - Dx.Defd.Result.collect_reverse/2","type":"function"},{"doc":"","ref":"Dx.Defd.Result.html#combine/2","title":"Dx.Defd.Result.combine/2","type":"function"},{"doc":"","ref":"Dx.Defd.Result.html#filter/3","title":"Dx.Defd.Result.filter/3","type":"function"},{"doc":"Returns `{:ok, elem}` for the first `elem` for which `fun` evaluates to `{:ok, true}`.\nIf any elements before that return `{:not_loaded, data_reqs}`, returns all of them combined as `{:not_loaded, ...}`.\nOtherwise, returns `{:ok, default}`.","ref":"Dx.Defd.Result.html#find/4","title":"Dx.Defd.Result.find/4","type":"function"},{"doc":"iex> [\n    ...>   {:ok, true},\n    ...>   {:not_loaded, []},\n    ...>   {:ok, false},\n    ...> ]\n    ...> |> Dx.Defd.Result.find()\n    {:ok, {:ok, true}}\n\n    iex> [\n    ...>   {:ok, false},\n    ...>   {:not_loaded, [1]},\n    ...>   {:not_loaded, [2]},\n    ...>   {:ok, true},\n    ...>   {:not_loaded, [3]},\n    ...> ]\n    ...> |> Dx.Defd.Result.find()\n    {:not_loaded, [1, 2]}\n\n    iex> [\n    ...>   {:ok, false},\n    ...>   {:ok, false},\n    ...> ]\n    ...> |> Dx.Defd.Result.find()\n    {:ok, nil}\n\n    iex> [\n    ...>   false,\n    ...>   false,\n    ...> ]\n    ...> |> Dx.Defd.Result.find(&{:ok, not &1})\n    {:ok, false}","ref":"Dx.Defd.Result.html#find/4-examples","title":"Examples - Dx.Defd.Result.find/4","type":"function"},{"doc":"","ref":"Dx.Defd.Result.html#find_value/3","title":"Dx.Defd.Result.find_value/3","type":"function"},{"doc":"Returns `{:ok, mapped_results}` if all elements map to `{:ok, result}`.\nOtherwise, returns `{:error, e}` on error, or `{:not_loaded, data_reqs}` with all data requirements.","ref":"Dx.Defd.Result.html#map/2","title":"Dx.Defd.Result.map/2","type":"function"},{"doc":"iex> [\n    ...>   {:ok, 1},\n    ...>   {:ok, 2},\n    ...>   {:ok, 3},\n    ...> ]\n    ...> |> Dx.Defd.Result.map()\n    {:ok, [1, 2, 3]}\n\n    iex> [\n    ...>   {:ok, 1},\n    ...>   {:not_loaded, [:x]},\n    ...>   {:ok, 3},\n    ...>   {:not_loaded, [:y]},\n    ...> ]\n    ...> |> Dx.Defd.Result.map()\n    {:not_loaded, [:x, :y]}\n\n    iex> [\n    ...>   {:ok, 1},\n    ...>   {:error, :x},\n    ...>   {:ok, 3},\n    ...>   {:not_loaded, [:y]},\n    ...> ]\n    ...> |> Dx.Defd.Result.map()\n    {:error, :x}","ref":"Dx.Defd.Result.html#map/2-examples","title":"Examples - Dx.Defd.Result.map/2","type":"function"},{"doc":"","ref":"Dx.Defd.Result.html#map/3","title":"Dx.Defd.Result.map/3","type":"function"},{"doc":"","ref":"Dx.Defd.Result.html#map_then_reduce/3","title":"Dx.Defd.Result.map_then_reduce/3","type":"function"},{"doc":"","ref":"Dx.Defd.Result.html#map_then_reduce/4","title":"Dx.Defd.Result.map_then_reduce/4","type":"function"},{"doc":"Applies the `mapper` function to each element and reduces the mapped results\nusing `acc` and `fun` as long as the mapped results are `{:ok, _}` tuples.\nReturns `{:ok, reduced_acc}` if all elements map to `{:ok, result}`.\nOtherwise, returns `{:error, e}` on error, or `{:not_loaded, data_reqs}` with all data requirements.","ref":"Dx.Defd.Result.html#map_then_reduce_ok/4","title":"Dx.Defd.Result.map_then_reduce_ok/4","type":"function"},{"doc":"iex> [\n    ...>   {:ok, 1},\n    ...>   {:ok, 2},\n    ...>   {:ok, 3},\n    ...> ]\n    ...> |> Dx.Defd.Result.map_then_reduce_ok(& &1, [], &[&1 | &2])\n    {:ok, [3, 2, 1]}\n\n    iex> [\n    ...>   {:ok, 1},\n    ...>   {:not_loaded, [:x]},\n    ...>   {:ok, 3},\n    ...>   {:not_loaded, [:y]},\n    ...> ]\n    ...> |> Dx.Defd.Result.map_then_reduce_ok(& &1, [], &[&1 | &2])\n    {:not_loaded, [:x, :y]}\n\n    iex> [\n    ...>   {:ok, 1},\n    ...>   {:error, :x},\n    ...>   {:ok, 3},\n    ...>   {:not_loaded, [:y]},\n    ...> ]\n    ...> |> Dx.Defd.Result.map_then_reduce_ok(& &1, [], &[&1 | &2])\n    {:error, :x}","ref":"Dx.Defd.Result.html#map_then_reduce_ok/4-examples","title":"Examples - Dx.Defd.Result.map_then_reduce_ok/4","type":"function"},{"doc":"","ref":"Dx.Defd.Result.html#map_then_reduce_ok_while/4","title":"Dx.Defd.Result.map_then_reduce_ok_while/4","type":"function"},{"doc":"","ref":"Dx.Defd.Result.html#merge/2","title":"Dx.Defd.Result.merge/2","type":"function"},{"doc":"Wraps a value in an `:ok` result.","ref":"Dx.Defd.Result.html#ok/1","title":"Dx.Defd.Result.ok/1","type":"function"},{"doc":"","ref":"Dx.Defd.Result.html#reduce/2","title":"Dx.Defd.Result.reduce/2","type":"function"},{"doc":"","ref":"Dx.Defd.Result.html#reduce/3","title":"Dx.Defd.Result.reduce/3","type":"function"},{"doc":"","ref":"Dx.Defd.Result.html#reduce_while/3","title":"Dx.Defd.Result.reduce_while/3","type":"function"},{"doc":"","ref":"Dx.Defd.Result.html#reject/3","title":"Dx.Defd.Result.reject/3","type":"function"},{"doc":"When given `{:ok, value}`, runs `fun` on `value` and returns the result.\nOtherwise, returns first argument as is.","ref":"Dx.Defd.Result.html#then/2","title":"Dx.Defd.Result.then/2","type":"function"},{"doc":"When given `{:ok, value}`, runs `fun` on `value` and returns `{:ok, new_value}`.\nOtherwise, returns first argument as is.","ref":"Dx.Defd.Result.html#transform/1","title":"Dx.Defd.Result.transform/1","type":"function"},{"doc":"","ref":"Dx.Defd.Result.html#transform/2","title":"Dx.Defd.Result.transform/2","type":"function"},{"doc":"","ref":"Dx.Defd.Result.html#transform/3","title":"Dx.Defd.Result.transform/3","type":"function"},{"doc":"","ref":"Dx.Defd.Result.html#transform_while/2","title":"Dx.Defd.Result.transform_while/2","type":"function"},{"doc":"Holds run options and already loaded data passed between `Dx.Defd`-defined functions according to the\n[token pattern](https://rrrene.org/2018/03/26/flow-elixir-using-plug-like-token/)\nin Elixir.\n\nThis is also used in the now deprecated `infer` approach of Dx.","ref":"Dx.Evaluation.html","title":"Dx.Evaluation","type":"module"},{"doc":"","ref":"Dx.Evaluation.html#add_options/2","title":"Dx.Evaluation.add_options/2","type":"function"},{"doc":"","ref":"Dx.Evaluation.html#from_options/1","title":"Dx.Evaluation.from_options/1","type":"function"},{"doc":"","ref":"Dx.Evaluation.html#t:t/0","title":"Dx.Evaluation.t/0","type":"type"},{"doc":"Used as intermediate data structure to translating defd code to SQL.","ref":"Dx.Scope.html","title":"Dx.Scope","type":"module"},{"doc":"","ref":"Dx.Scope.html#add_conditions/2","title":"Dx.Scope.add_conditions/2","type":"function"},{"doc":"Explicitly create an unfiltered scope for a schema module.","ref":"Dx.Scope.html#all/1","title":"Dx.Scope.all/1","type":"function"},{"doc":"Looks up a scope using the provided `Dx.Evaluation` struct.\nRuns any post-load processing defined in the scope.","ref":"Dx.Scope.html#lookup/2","title":"Dx.Scope.lookup/2","type":"function"},{"doc":"","ref":"Dx.Scope.html#map_plan/2","title":"Dx.Scope.map_plan/2","type":"function"},{"doc":"Converts an atom to a scope using `all/1` if given an atom, otherwise returns the input unchanged.","ref":"Dx.Scope.html#maybe_atom/1","title":"Dx.Scope.maybe_atom/1","type":"function"},{"doc":"Looks up a scope if given {:ok, scope}, otherwise returns the input unchanged.","ref":"Dx.Scope.html#maybe_load/2","title":"Dx.Scope.maybe_load/2","type":"function"},{"doc":"Looks up a scope if given one, otherwise wraps the input in an `:ok` tuple.","ref":"Dx.Scope.html#maybe_lookup/2","title":"Dx.Scope.maybe_lookup/2","type":"function"},{"doc":"A scope struct used for translating defd code to SQL queries.\n\nFields:\n- `:plan` - The query plan to be executed\n- `:type` - The schema module type\n- `:cardinality` - Either `:one` or `:many` (default: `:many`)\n- `:aggregate?` - Whether this scope represents an aggregate query\n- `:aggregate_default` - Default value to use for empty aggregates (e.g. `0` for `count`)\n- `:ref` - Root alias when building the Ecto query (default: `:root`)\n- `:main_condition_candidates` - Candidates for the main query condition\n- `:post_load` - Post-processing defd functions to apply after loading (default: `{:loaded}`),\n                 e.g. filters that could not be translated to SQL\n- `:opts` - Additional options (default: `[]`)","ref":"Dx.Scope.html#t:t/0","title":"Dx.Scope.t/0","type":"type"},{"doc":"","ref":"Dx.Ecto.Query.TranslationError.html","title":"Dx.Ecto.Query.TranslationError","type":"exception"},{"doc":"","ref":"Dx.Ecto.Query.TranslationError.html#message/1","title":"Dx.Ecto.Query.TranslationError.message/1","type":"function"},{"doc":"","ref":"Dx.Error.Generic.html","title":"Dx.Error.Generic","type":"exception"},{"doc":"","ref":"Dx.Error.Generic.html#message/1","title":"Dx.Error.Generic.message/1","type":"function"},{"doc":"","ref":"Dx.Error.NotLoaded.html","title":"Dx.Error.NotLoaded","type":"exception"},{"doc":"","ref":"Dx.Error.NotLoaded.html#message/1","title":"Dx.Error.NotLoaded.message/1","type":"function"},{"doc":"","ref":"Dx.Error.RulesNotFound.html","title":"Dx.Error.RulesNotFound","type":"exception"},{"doc":"","ref":"Dx.Error.RulesNotFound.html#message/1","title":"Dx.Error.RulesNotFound.message/1","type":"function"},{"doc":"","ref":"Dx.Error.Timeout.html","title":"Dx.Error.Timeout","type":"exception"},{"doc":"","ref":"Dx.Error.Timeout.html#message/1","title":"Dx.Error.Timeout.message/1","type":"function"},{"doc":"# Full Reference","ref":"full_reference.html","title":"Full Reference","type":"extras"},{"doc":"`use Dx.Ecto.Schema` enables a module to specify inferences, such as\n\n```elixir\nuse Dx.Ecto.Schema\n\ninfer has_children?: true, when: %{relatives: %{relation: \"parent_of\"}}\ninfer has_children?: false\n```\n\nUnlike full-fledged inference engines (such as [calypte](https://github.com/liveforeverx/calypte)\nor [retex](https://github.com/lorenzosinisi/retex)), all rules in Dx are bound to an individual\nrecord type as their subject. This, in turn, allows to utilize Ecto schemas and queries to their full extent.","ref":"full_reference.html#augment-ecto-schema","title":"Augment Ecto schema - Full Reference","type":"extras"},{"doc":"- `infer ...` defines a **rule** in a module. It applies to an instance of that module:\n  A struct, Ecto record, Ash resource, ...\n- This instance of a module, on which rules are evaluated, is the **subject**.\n- A rule can have a **condition**, or `:when` part, that must be met in order for it to apply,\n  e.g. `%{relatives: %{relation: \"parent_of\"}}`.\n- When the condition is met, a given **predicate** is assigned a given **value**,\n  e.g. `has_children?: true`. This is also called the **result** of the rule.\n- All rules are evaluated from top to bottom until the first one for each predicate matches,\n  similar to a `cond` statement.\n- A condition can make use of other predicates as well as **fields** defined on the schema or\n  struct of the underlying type.\n- An executed rule results in a (derived) **fact**: subject, predicate, value.","ref":"full_reference.html#terminology","title":"Terminology - Full Reference","type":"extras"},{"doc":"- `Dx.get/3` evaluates the given predicate(s) using only the (pre)loaded data available, and returns the result(s)\n- `Dx.load/3` is like `get`, but loads any additional data as needed\n- `Dx.put/3` is like `load`, but puts the results into the `:inferred` field\n  (or virtual schema field) of the subject(s) as a map, and returns the subject(s)\n\nThese functions return a tuple, either `{:ok, result}`, `{:error, error}`, or `{:not_loaded, data_reqs}` (only `get`).\n\nThe corresponding `Dx.get!/3`, `Dx.load!/3` and `Dx.put!/3` functions return `result`\ndirectly, or otherwise raise an exception.\n\nArguments:\n\n- **subjects** can either be an individual subject (with the given predicates defined on it), or a list of subjects.\n  Passing an individual subject will return the predicates for the subject, passing a list will return a list of them.\n- **predicates** can either be a single predicate, or a list of predicates.\n  Passing a single predicate will return the resulting value, passing a list will return a **map**\n  of the predicates and their resulting values.\n- **options** (optional) See below.\n\nOptions:\n\n- **args** (list or map) can be used to pass in data from the caller's context that can be used in\n  rules (see _Arguments_ below). A classic example is the `current_user`, e.g.\n  ```elixir\n  Dx.put!(project, :can_edit?, args: [user: current_user])\n  ```\n- **extra_rules** (module or list of modules) can be used to add context-specific rules that are\n  not defined directly on the subject. This can be used to structure rules into their own modules\n  and use them only where needed.\n- **debug?** (boolean) makes Dx print additional information to the console as rules are evaluated.\n  Should only be used while debugging.","ref":"full_reference.html#api-overview","title":"API overview - Full Reference","type":"extras"},{"doc":"In a rule condition, the part after `when: ...`,\n\n- **Maps** represent multiple conditions, of which **all** need to be satisfied (logical `AND`).\n- **Lists** represent multiple conditions, of which **at least one** needs to be satisfied (logical `OR`).\n- Values can be negated using `{:not, \"value\"}`.\n\nExamples:\n\n```elixir\n# :role must be \"admin\"\ninfer role: :admin, when: %{role: \"admin\"}\n\n# :role must be either \"admin\" or \"superadmin\"\ninfer role: :admin, when: %{role: [\"admin\", \"superadmin\"]}\n\n# :role must be \"admin\" and :verified? must be true\ninfer role: :admin, when: %{role: \"admin\", verified?: true}\n\n# :role must be \"admin\" and :verified_at must not be nil\ninfer role: :admin, when: %{role: \"admin\", verified_at: {:not, nil}}\n```","ref":"full_reference.html#conditions","title":"Conditions - Full Reference","type":"extras"},{"doc":"A single atom is a shorthand for `%{atom: true}`.","ref":"full_reference.html#boolean-shorthand-form","title":"Boolean shorthand form - Full Reference","type":"extras"},{"doc":"When conditions are tested against list data, e.g. a person's list of roles, the condition is satisfied\nif at least one element of the list matches the given conditions (like `Enum.any?/2`).\n\nAlthough they might look similar, it's important to differentiate between lists that appear in\nconditions, and lists that appear in the data, which are checked against a condition.\n\nWhen both occur together, i.e. a list in a condition is checked against a list of values, the condition\nis met if at least one of the condition list elements applies to at least one element of the value list.\n\nFor example:\n\n```elixir\ninfer :can_edit?, when: %{roles: [\"project_manager\", \"admin\"]}\n\niex> %Person{roles: [\"worker\", \"assistant\"]} |> Dx.get!(:can_edit?)\nnil\n\niex> %Person{roles: [\"assistant\", \"project_manager\"]} |> Dx.get!(:can_edit?)\ntrue\n\niex> %Person{roles: [\"admin\"]} |> Dx.get!(:can_edit?)\ntrue\n```\n\nThe same applies to complex conditions.","ref":"full_reference.html#conditions-on-list-data","title":"Conditions on list data - Full Reference","type":"extras"},{"doc":"The assigned value of a predicate is generally assigned as is.\n\nA few special tuples, however, will be replaced by Dx (see _Features_ below)\n\nExample:\n\n```elixir\ninfer d: 4\ninfer nested: %{a: 1, b: 2, c: {:ref, :d}}  # => %{a: 1, b: 2, c: 4}\n```","ref":"full_reference.html#rule-results","title":"Rule results - Full Reference","type":"extras"},{"doc":"Syntax:\n\n- `{:ref, path}` (in conditions and result values)\n\nArguments:\n\n- **path** is a list of fields or predicates, starting from the subject.\n  The brackets can be omitted (i.a. an atom passed), if the path consists of one element.\n  The last element can be a map or list (see _Branching_ below)\n\nExample:\n\n```elixir\ninfer ot_fields: %{editable: true},\n    when: %{\n      construction_bectu?: true,\n      roles: %{\n        user: {:ref, [:args, :user]},\n        type: [\"project_manager\", \"admin\"]\n      }\n    }\n```","ref":"full_reference.html#references","title":"References - Full Reference","type":"extras"},{"doc":"Any part of the `path` that represents an underlying **list of subjects**, such as referencing\na `has_many` association, will cause the result of the `:ref` to be a list as well.\nIt basically behaves similar to `Enum.map/2`.\n\nA **map** as last element of a `path` will branch the returned result out into this map.\nThe keys are returned as is, the values must be a list (or atom) continuing that path.\nThis is particularly powerful when used on a list of subjects (see above), because it\nwill return the given map with the values at the given paths for each underlying subject:\n\nA **list** as last element of a `path` behaves like a map where each value equals its key.\n\nExamples:\n\n```elixir\ninfer list: [%{a: 1, b: 2, c: %{d: 4}}, %{a: 9, b: 8, c: %{d: 6}}]\n\ninfer result1: {:ref, [:list, :a]}  # => [1, 9]\ninfer result2: {:ref, [:list, %{x: :a, y: [:c, :d]}]}  # => [%{x: 1, y: 4}, %{x: 9, y: 6}]\ninfer result3: {:ref, [:list, [:a, :b]]}  # => [%{a: 1, b: 2}, %{a: 9, b: 8}]\n```","ref":"full_reference.html#branching","title":"Branching - Full Reference","type":"extras"},{"doc":"Passing `:args` as an option to any of the Dx API functions enables referencing the passed data\nin conditions and values using `{:ref, [:args, ...]}`.","ref":"full_reference.html#arguments","title":"Arguments - Full Reference","type":"extras"},{"doc":"It's possible to give predicates the same name as existing fields in the schema.\nThis represents the fact that these fields are derived from other data, using rules.\n\nRules on these fields can even take into account the existing value of the underlying field.\nIn order to reference it, use `:fields` in between a path or condition, for example:\n\n```elixir\nschema \"blog_posts\" do\n  field :state\n  field :published_at\nend\n\n# nilify published_at when deleted, or when it's an old archived post\ninfer published_at: nil, when: %{state: \"deleted\"}\ninfer published_at: nil, when: %{state: \"archived\", fields: %{published_at: {:before, ~D[2020-02-20]}}}\ninfer published_at: {:ref, [:fields, :published_at]}\n```\n\nWhile it's always possible to achieve a similar behavior by giving the predicate a different\nname than the field, and then mapping the predicate to the field somewhere else,\nusing the field name in conjunction with `:fields` makes explicit that it's a conditional override.","ref":"full_reference.html#overriding-existing-fields","title":"Overriding existing fields - Full Reference","type":"extras"},{"doc":"Syntax:\n\n- `{:bind, key}` (in conditions)\n- `{:bind, key, subcondition}` (in conditions)\n- `{:bound, key}` (in result values)\n- `{:bound, key, default}` (in result values)\n\nWhen a condition is evaluated on a list of values, the **first value** satisfying\nthe condition can be bound to a variable using `{:bind, variable}`.\n\nThese bound values can be referenced using `{:bound, key}` with an optional default:\n`{:bound, key, default}`.\n\n```elixir\ninfer project_manager: {:bound, :person},\n    when: %{roles: %{type: \"project_manager\", person: {:bind, :person}}}\n```","ref":"full_reference.html#binding-subject-parts","title":"Binding subject parts - Full Reference","type":"extras"},{"doc":"Syntax:\n\n- `infer_alias key: ...` (in modules before using `key` in `infer ...`)\n\nIn order to create shorthands and avoid repetition, aliases can be defined.\nThese apply only to subsequent rules within the same module and are not exposed in any other way.\n\n```elixir\ninfer_alias pm?: %{roles: %{type: [\"project_manager\", admin]}}\n\ninfer ot_fields: %{editable: true}, when: [:pm?, %{construction_bectu?: true}]\n```","ref":"full_reference.html#local-aliases","title":"Local aliases - Full Reference","type":"extras"},{"doc":"Syntax:\n\n- `{&module.fun/n, [arg_1, ..., arg_n]}` (in result values)\n- `{&module.fun/1, arg_1}` (in result values)\n\nAny function can be called to map the given arguments to other values.\nThe function arguments must be passed as a list, except if it's only one.\nArguments can be fixed values or other Dx features (passed as is), such as references.\n\n```elixir\ninfer day_of_week: {&Date.day_of_week/1, {:ref, :date}}\n\ninfer duration: {&Timex.diff/3, [{:ref, :start_datetime}, {:ref, :end_datetime}, :hours]}\n```\n\nOnly pure functions with low overhead should be used.\nDx might call them very often during evaluation (once after each loading of data).","ref":"full_reference.html#calling-functions","title":"Calling functions - Full Reference","type":"extras"},{"doc":"Syntax:\n\n- `{:query_one, type, conditions}`\n- `{:query_one, type, conditions, options}`\n- `{:query_first, type, conditions}`\n- `{:query_first, type, conditions, options}`\n- `{:query_all, type, conditions}`\n- `{:query_all, type, conditions, options}`\n\nArguments:\n\n- `type` is a module name (or Ecto queryable), e.g. an Ecto schema\n- `conditions` is a **keyword list** of fields and their respective values, or lists of values, they must match\n- `options` is a subset of the options that Ecto queries support:\n  - `order_by`\n  - `limit`","ref":"full_reference.html#querying","title":"Querying - Full Reference","type":"extras"},{"doc":"The first key-value pair has a special behavior:\nIt is used as the main condition for `Dataloader`, and thus should have the highest cardinality.\nIt must be a single value, not a list of values.\n\n_Rule of thumb:_ Put a single field that has the most unique values as first condition.","ref":"full_reference.html#conditions","title":"Conditions - Full Reference","type":"extras"},{"doc":"Syntax:\n\n- `{:filter, source, condition}` (in result values)\n- `{:map, source, mapper}` (in result values)\n- `{:map, source, bind_key/condition, mapper}` (in result values)\n\nArguments:\n\n- `source` can either be a list literal, a field or predicate that evaluates to a list,\n  or another feature such as a query.\n- `condition` has the same form and functionality as any other rule condition.\n- `mapper` can either be a field or predicate (atom), or is otherwise treated as any other rule value.\n\nThere are 3 variants:\n\n- `{:filter, source, condition}` keeps only elements from `source`, for which the `condition` is met.\n- `{:map, source, mapper}` returns the result of `mapper` for each element in `source`.\n- `{:map, source, bind_key/condition, mapper}` is a special form of `:map`, where the `mapper` is based on the\n  subject of the rule, not the list element. The list element is referenced using the middle arg, which can be either:\n  - a `bind_key` (atom) - the current list element is referenced via `{:bound, bind_key}` in the `mapper`\n  - a `condition` - any values bound in the condition via `{:bind, key, ...}` can be accessed\n    via `{:bound, key}` in the `mapper`\n\nUse the special form of `:map` only when you need to reference both the list element (via `:bound`),\nand the subject of the rule (via `:ref`).\nUsing a combination of `:filter` and basic `:map` instead is always preferred, if possible.\n\nAny `nil` elements in the list are mapped to `nil`, when using `:map` without condition.\n\nExamples:\n\n```elixir\ninfer accepted_offers: {:filter, :offers, %{state: \"accepted\"}}\n\ninfer offer_ids: {:map, :offers, :id}\n\ninfer first_offer_of_same_user:\n        {:map, :offers, %{state: \"accepted\", user_id: {:bind, :uid, {:not, nil}}},\n         {:query_first, Offer, user_id: {:bound, :uid}, project_id: {:ref, :project_id}}}\n```","ref":"full_reference.html#transforming-lists","title":"Transforming lists - Full Reference","type":"extras"},{"doc":"Syntax:\n\n- `{:count, source, condition/predicate}` (in result values)\n- `{:count_while, source, condition/predicate}` (in result values)\n\nArguments:\n\n- `source` can either be a list literal, a field or predicate that evaluates to a list,\n  or another feature such as a query.\n- `condition` has the same form and functionality as any other rule condition.\n- `predicate` can either be a predicate (atom) that returns either `true`, `false`,\n  or `:skip` (only for `:count_while`)\n\nTakes the given list and counts the elements that evaluate to `true`.\n`:count_while` stops after the first element that returns `false`.\nTo not count an element, but not stop counting either, the given predicate may return `:skip`.\nAny `nil` elements in the list are treated as `false`.","ref":"full_reference.html#counting","title":"Counting - Full Reference","type":"extras"},{"doc":"# Welcome \n\nWelcome to the documentation of `Dx`, a rule-based inference engine written in Elixir.\n\nIf you're new to `Dx`, we recommend starting with the [basics](basics/00_intro.md).","ref":"welcome.html","title":"Welcome ","type":"extras"},{"doc":"# Introduction\n\nIn the following sections, we'll learn...\n\n- what [predicates](01_predicates.md) are, and how to define rules to assign their values\n- how [associations](02_associations.md) are easily traversed when defining rules\n- combining [conditions](03_conditions.md) to define more complex rules\n- using [references](04_references.md) to compare multiple fields or predicates with each other\n- passing in [arguments](05_arguments.md) from the outside context in which rules are evaluated\n\nFinally, we close with a chapter on [Thinking in Dx](06_thinking_in_dx.md), learn to apply\nall the lessons learnt.","ref":"00_intro.html","title":"Introduction","type":"extras"},{"doc":"# Predicates\n\nDx allows you to add predicates to your schema.\nPredicates are like virtual fields, but instead of storing values,\nyou define what the value should be, based on conditions.","ref":"01_predicates.html","title":"Predicates","type":"extras"},{"doc":"Say we have a ToDo list app with a `Todo.List` schema type.\n\n```elixir\ndefmodule Todo.List do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"lists\" do\n    field :archived_at, :utc_datetime\n  end\n\n  infer archived?: false, when: %{archived_at: nil}\n  infer archived?: true\nend\n```\n\nHere, we define a predicate `archived?` on our `Todo.List` schema.\nIt has the value `false` when the field `archived_at` is `nil`.\nIf this condition doesn't match, Dx will look at the next rule\nand assign the value `true`. Since there is no condition for this\nlast rule, it will always match.\n\n> _Tip: It is a good practice to always have a last rule without\n> condition to define a fallback value._\n\n#### Usage\n\nThis predicate can now be used like a field, as long as you use an `Dx`\nto to evaluate it, such as `Dx.get!/2`:\n\n```elixir\n# loading a predicate\niex> %Todo.List{archived_at: nil}\n...> |> Dx.get!(:archived?)\nfalse\n\niex> %Todo.List{archived_at: ~U[2022-02-02 22:22:22Z]}\n...> |> Dx.get!(:archived?)\ntrue\n```","ref":"01_predicates.html#example-boolean-predicate","title":"Example: boolean predicate - Predicates","type":"extras"},{"doc":"Instead of assigning `true` or `false`, we might define a predicate\n`state` that can be easily extended later on.\nWe can even use the existing predicate and reference it in our new rule:\n\n```elixir\ndefmodule Todo.List do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"lists\" do\n    field :archived_at, :utc_datetime\n  end\n\n  infer archived?: false, when: %{archived_at: nil}\n  infer archived?: true\n\n  infer state: :archived, when: %{archived?: true}\n  infer state: :active\nend\n```\n\n#### Usage\n\nJust as with `archived?`, we can now use `state` as if it was a field when using `Dx`:\n\n```elixir\niex> %Todo.List{archived_at: nil}\n...> |> Dx.get!(:state)\n:active\n\niex> %Todo.List{archived_at: ~U[2022-02-02 22:22:22Z]}\n...> |> Dx.get!(:state)\n:archived\n```","ref":"01_predicates.html#example-multi-value-predicate","title":"Example: multi-value predicate - Predicates","type":"extras"},{"doc":"# Associations\n\nDx allows to easily traverse associations to access fields or even\npredicates defined on associated records.\n\nSay our `Todo.List` schema from the previous guide now `has_many` tasks:\n\n```elixir\ndefmodule Todo.List do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"lists\" do\n    field :archived_at, :utc_datetime\n\n    has_many :tasks, Todo.Task\n  end\n\n  infer archived?: false, when: %{archived_at: nil}\n  infer archived?: true\n\n  infer state: :archived, when: %{archived?: true}\n  infer state: :active\nend\n```\n\nIn return, we add a Task schema that `belongs_to` a List:\n\n```elixir\ndefmodule Todo.Task do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"tasks\" do\n    field :completed_at, :utc_datetime\n\n    belongs_to :list, Todo.List\n  end\n\n  infer completed?: false, when: %{completed_at: nil}\n  infer completed?: true\nend\n```","ref":"02_associations.html","title":"Associations","type":"extras"},{"doc":"Say we want a Task to be `archived?` when the List it belongs to is archived.\nWe could write a similar rule on the `Todo.Task` schema as we have on the List:\n\n```elixir\n  infer archived?: false, when: %{list: %{archived_at: nil}}\n  infer archived?: true\n```\n\nThe `archived?` predicate looks at the associated `list` (defined using `belongs_to`)\nand its field `archived_at`, and compares that to `nil`.\nIf it's `nil` then the Task's predicate `archived?` is `false`, otherwise it's `true`.\n\nHowever, since we've already defined this logic on the List, we can also use the predicate\non the associated List instead, and change things around a bit:\n\n```elixir\n  infer archived?: true, when: %{list: %{archived?: true}}\n  infer archived?: false\n```\n\n#### Usage\n\nLike before, we can use `Dx.get!/2` to evaluate the predicate,\nbut only if the association is (pre)loaded:\n\n```elixir\niex> list = %Todo.List{archived_at: ~U[2022-02-02 22:22:22Z]} |> Todo.Repo.insert!()\n...> %Todo.Task{completed_at: nil, list: list}\n...> |> Dx.get!(:archived?)\ntrue\n```\n\nIf the association is not (pre)loaded, `Dx.get!/2` will raise an error:\n\n```elixir\niex> list = %Todo.List{archived_at: ~U[2022-02-02 22:22:22Z]} |> Todo.Repo.insert!()\n...> %Todo.Task{completed_at: nil, list: list}\n...> |> Todo.Repo.insert!() |> Todo.Repo.reload!()  # insert and reload without associations\n...> |> Dx.get!(:archived?)\n** (Dx.Error.NotLoaded) Association list is not loaded on nil. Cannot get path: nil\n```\n\nTo allow Dx to load associations as needed, use `Dx.load!/2` instead:\n\n```elixir\niex> list = %Todo.List{archived_at: ~U[2022-02-02 22:22:22Z]} |> Todo.Repo.insert!()\n...> %Todo.Task{completed_at: nil, list: list}\n...> |> Todo.Repo.insert!() |> Todo.Repo.reload!()  # insert and reload without associations\n...> |> Dx.load!(:archived?)\n# loads the associated list\ntrue\n```","ref":"02_associations.html#belongs_to","title":"belongs_to - Associations","type":"extras"},{"doc":"We can also define predicates based on a `has_many` association.\nDx generally treats conditions on a list of records like an `Enum.any?` condition:\n\n```elixir\ndefmodule Todo.List do\n  # ...\n\n  infer in_progress?: true, when: %{tasks: %{completed?: true}}\n  infer in_progress?: false\nend\n```\n\nThe predicate `in_progress?` is `true` if there's any Task associated that has `completed?: true`.\nOtherwise, if there's no Task associated that has `completed?: true`, `in_progress?` is `false`.\n\nPutting it all together, we can extend our `state` predicate on the `Todo.List` schema:\n\n```elixir\ndefmodule Todo.List do\n  # ...\n\n  infer state: :archived, when: %{archived?: true}\n  infer state: :in_progress, when: %{tasks: %{completed?: true}}\n  infer state: :ready, when: %{tasks: %{}}\n  infer state: :empty\nend\n```\n\nWhat does the `:ready` rule do?\nIt checks whether there's any Task, without any condition on the Task.\nSo if the List is not archived, and there are no completed tasks, but there is a Task,\n`:state` is `:ready`. Otherwise `:state` is `:empty`.\n\n_This might be hard to grasp, but it will hopefully become clearer in the next guide..._","ref":"02_associations.html#has_many","title":"has_many - Associations","type":"extras"},{"doc":"# Conditions\n\nWe've already seen some conditions nested using maps.","ref":"03_conditions.html","title":"Conditions","type":"extras"},{"doc":"Using maps is the go-to way of writing conditions. If you're unsure\nabout how to define a condition, use a `Map`.\n\nWhen using a `Map` with multiple elements in a condition, all of its\nelements must match for the whole condition to match. This is\nsimilar to pattern-matching in Elixir code.\n\nSay we want a `Todo.List` to only be `archivable?` if it's not\narchived yet **and** all of its tasks are completed.\n\n```elixir\ndefmodule Todo.List do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"lists\" do\n    field :archived_at, :utc_datetime\n\n    belongs_to :created_by, Todo.User\n  end\n\n  infer archived?: false, when: %{archived_at: nil}\n  infer archived?: true\n\n  infer archivable?: true,\n        when: %{\n          archived?: false,\n          tasks: {:all?, %{completed?: true}}\n        }\n\n  infer archivable?: false\nend\n```","ref":"03_conditions.html#and","title":"And - Conditions","type":"extras"},{"doc":"A logical \"or\" is expressed by an Elixir `List`. This is the first\nmajor difference to pattern-matching. It might not feel intuitive\nat first, but gets familiar fast and becomes very useful once you\ngot used to it.\n\nSay we want a `Todo.List` to be `archivable?` if its `:state` we\ndefined in the previous chapter is either `:completed` or `:ready`.\n\n```elixir\ndefmodule Todo.List do\n  # ...\n\n  infer state: :archived, when: %{archived?: true}\n  infer state: :completed, when: %{tasks: {:all?, %{completed?: true}}}\n  infer state: :in_progress, when: %{tasks: %{completed?: true}}\n  infer state: :ready, when: %{tasks: %{}}\n  infer state: :empty\n\n  infer archivable?: true, when: %{state: [:completed, :ready]}\n  infer archivable?: false\nend\n```\n\nThis is also a good example for defining predicates based on other\npredicates if they reflect how you actually think about them.\nDx will find an efficient way to evaluate them.","ref":"03_conditions.html#or","title":"Or - Conditions","type":"extras"},{"doc":"Negations can be expressed by wrapping a condition in a `:not` tuple.\n\nAnother way of expressing the `archived?` predicate from the first\nguide would thus be:\n\n```elixir\ndefmodule Todo.List do\n  # ...\n\n  infer archived?: true, when: %{archived_at: {:not, nil}}\n  infer archived?: false\n\n  # previously:\n  # infer archived?: false, when: %{archived_at: nil}\n  # infer archived?: true\nend\n```","ref":"03_conditions.html#not","title":"Not - Conditions","type":"extras"},{"doc":"# References\n\nOften times, we need to compare values in different fields with\neach other, not with fixed values. This is where references come in.\n\nSay we want to add a `by_owner?` predicate to a `Todo.Task`:\n\n```elixir\ndefmodule Todo.Task do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"tasks\" do\n    field :completed_at, :utc_datetime\n\n    belongs_to :list, Todo.List\n    belongs_to :created_by, Todo.User\n  end\n\n  infer by_owner?: true, when: %{created_by_id: {:ref, [:list, :created_by_id]}}\n  infer by_owner?: false\nend\n```","ref":"04_references.html","title":"References","type":"extras"},{"doc":"By default, all comparisons need to match exactly. However, other comparisons are possible as well.\n\nSay we support completing tasks on an already archived list.\nAnd we want to add a predicate `completed_later?` to capture that.\n\n```elixir\ndefmodule Todo.Task do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"tasks\" do\n    field :completed_at, :utc_datetime\n\n    belongs_to :list, Todo.List\n    belongs_to :created_by, Todo.User\n  end\n\n  infer completed_later?: false, when: %{completed?: false}\n  infer completed_later?: false, when: %{list: %{archived?: false}}\n  infer completed_later?: true, when: %{completed_at: {:gt, {:ref, [:list, :archived_at]}}}\n  infer completed_later?: false\nend\n```\n\nThe `Todo.Task` must already by `completed?` and the `Todo.List` `archived?`.\nIn particular, the `Todo.Task` must be `completed_at` after the `Todo.List` was archived.\n\nOperators can also compare to fixed values (not references).\n\n#### Supported operators\n\nOperators with all aliases:\n\n- Greater than: `:gt`, `:>`, `:greater_than`, `:after`\n- Greater than or equal: `:gte`, `:>=`, `:greater_than_or_equal`, `:on_or_after`, `:at_or_after`\n- Less than: `:lt`, `:<`, `:less_than`, `:before`\n- Less than or equal: `:lte`, `:<=`, `:less_than_or_equal`, `:on_or_before`, `:at_or_before`","ref":"04_references.html#operators","title":"Operators - References","type":"extras"},{"doc":"# Arguments\n\nTo pass in data from the caller context and make it available in the rules, there's the `args` option.\nAny `args` passed to the `Dx` API function will be available in rules as if `args` was\nan association on the current root record.\n\nSay we implement some authorization, where a user can archive a `Todo.List` only if they are an admin, or they are the owner of the list.\nWe pass in the currently logged-in user struct, which was already loaded as part of authentication.\n\n```elixir\nDx.load!(list, args: [current_user: current_user])\n```\n\nThe `current_user` is then available within `args`, including any\nfields, associations and predicates defined on it.\n\n```elixir\ndefmodule Todo.List do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"lists\" do\n    field :archived_at, :utc_datetime\n\n    belongs_to :created_by, Todo.User\n  end\n\n  infer can_archive?: true, when: %{args: %{current_user: %{is_admin?: true}}}\n  infer can_archive?: true, when: %{created_by_id: {:ref, [:args, :current_user, :id]}}\n  infer can_archive?: false\nend\n```","ref":"05_arguments.html","title":"Arguments","type":"extras"},{"doc":"# Thinking in Dx\n\nWhen working with Dx, we have to think top-down, as opposed to bottom-up.\nWe always start from the end result, which we want to achieve.\nAny logic and inputs needed to get to the end result are defined within Dx.","ref":"06_thinking_in_dx.html","title":"Thinking in Dx","type":"extras"},{"doc":"Say we have a complex requirement to implement:\n\n> A user can archive a Todo list, but only if they created it, or if they have an \"admin\" role,\n> and only if all tasks in the list are completed.\n\nLet's assume we only have the schema, and no other functions, helpers, or rules defined.\n\n```elixir\ndefmodule Todo.User do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"users\" do\n    has_many :roles, Todo.UserRole\n  end\nend\n\ndefmodule Todo.UserRole do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"user_roles\" do\n    field :name, Ecto.Enum, values: [:moderator, :admin, :super_admin]\n\n    belongs_to :user, Todo.User\n  end\nend\n\ndefmodule Todo.List do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"lists\" do\n    field :archived_at, :utc_datetime\n\n    belongs_to :created_by, Todo.User\n  end\nend\n\ndefmodule Todo.Task do\n  use Ecto.Schema\n  use Dx.Ecto.Schema, repo: Todo.Repo\n\n  schema \"tasks\" do\n    field :completed_at, :utc_datetime\n\n    belongs_to :list, Todo.List\n  end\nend\n```\n\nThe inputs are the `list` to be archived and the `current_user` who tries to archive it.\nThe end result is either the now archived list, or an error.\n\nWithout Dx, we'd write a function that takes the `list` and the `user` who tries to archive it.\nWe'd then have to think about **how** to load the data needed to compute the result, and implement it.\n\nWith Dx, we don't have to think about **how** to load the data or compute the result.\nInstead, we focus entirely on **what** is relevant and write the rules to represent this logic.\nDx then takes care of loading data as needed, in an efficient way.\n\nThinking in Dx, we usually take the following steps:\n\n1.  What are the possible end results that we need to continue in our other code, f.ex. a web request?\n    In our example, the end result can be either \"archive the list\" or \"can't archive list\".\n    In code terms, we could return `true` or `false`, or we could return `:ok` or `{:error, reason}`.\n\n    _Note:_ We think of Dx as read-only; we don't perform an action (such as archiving a list),\n    but prepare and compute all the data needed to do it.\n\n2.  What is the primary data point, on which to operate on?\n    In our example, it's rather easy: we operate on a `list`.\n    In other cases, there might be multiple candidates; in these cases, it might help to ask\n    what data type feels most intuitive to return the end results conceived in step 1.\n\n3.  Define a predicate on the main data type from step 2 with the possible values from step 1.\n    In the code where the outcome is used, f.ex. a web request, call `Dx` with the main data point\n    and this predicate. We also add additional data needed as `args`.\n\n    In our example:\n\n        # in Todo.List\n        infer archivable?: :ok\n        infer archivable?: {:error, :unauthorized}\n        infer archivable?: {:error, :pending_tasks}\n\n        # in the List controller\n        with :ok <- Dx.load!(list, :archivable?, args: [current_user: current_user]),\n             {:ok, archived_list} <- List.archive(list) do\n          render(conn, \"show.html\", list: archived_list)\n        end\n\n4.  Flesh out the conditions for the various cases. For each condition, think about what's needed\n    and how it could be called. If there's a good answer, use the term in the condition as if it\n    already existed. This way, it's easier to stay on the requirements level, using terms that make\n    sense in the app's domain.\n\n    In our example, we also reverse the order, checking all error cases first,\n    and returning `:ok` otherwise:\n\n        # in Todo.List\n        infer archivable?: {:error, :unauthorized}, when: %{can_archive?: false}\n        infer archivable?: {:error, :pending_tasks}, when: %{tasks: %{completed?: false}}\n        infer archivable?: :ok\n\n5.  Define the predicates you used on the correct schema types, and continue the process until the\n    requirements are fully defined using rules.\n\n    In our example, the final set of rules might look like this:\n\n        # in Todo.List\n        infer archivable?: {:error, :unauthorized}, when: %{can_archive?: false}\n        infer archivable?: {:error, :pending_tasks}, when: %{tasks: %{completed?: false}}\n        infer archivable?: :ok\n\n        infer can_archive?: true, when: %{args: %{current_user: %{is_admin?: true}}}\n        infer can_archive?: true, when: %{is_owner?: true}\n        infer can_archive?: false\n\n        infer is_owner?: true, when: %{created_by_id: {:ref, [:args, :current_user, :id]}}\n        infer is_owner?: false\n\n        # in Todo.User\n        infer is_admin?: true, when: %{roles: %{name: [:admin, :super_admin]}}\n        infer is_admin?: false\n\n        # in Todo.Task\n        infer completed?: true, when: %{completed_at: {:not, nil}}\n        infer completed?: false","ref":"06_thinking_in_dx.html#example","title":"Example - Thinking in Dx","type":"extras"},{"doc":"We could use the rules we defined to cover other use cases as well:\n\n#### Filtering archivable lists\n\nSay we have a list of `Todo.List` structs, and want to keep only the ones that can be archived,\nfor example to implement a web request to archive multiple lists. We use `Dx.filter/3` for it,\nwhich takes a list of data as well as a condition, just like the ones we use when defining rules:\n\n```elixir\nDx.filter(lists, %{archivable?: :ok}, args: [current_user: current_user])\n```\n\n#### Querying all archivable lists\n\nSay we want to query all lists that a given user can archive. We use `Dx.query_all/3` for it,\nwhich takes a type as well as a condition, just like the ones we use when defining rules:\n\n```elixir\nDx.query_all(Todo.List, %{archivable?: :ok}, args: [current_user: current_user])\n```","ref":"06_thinking_in_dx.html#other-use-cases-covered","title":"Other use cases covered - Thinking in Dx","type":"extras"},{"doc":"# Done \n\nWe've learnt all the basics about using Dx, and even thinking in it.\n\nThis should be enough to get you started.\n\nWe're currently writing guides on more advanced topics, so stay tuned! ","ref":"99_outro.html","title":"Done ","type":"extras"}],"producer":{"name":"ex_doc","version":[48,46,51,52,46,50]}}