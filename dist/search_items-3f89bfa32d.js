searchNodes=[{"doc":"Infer is an inference engine that allows to declare logic based on data schemas (such as Ecto) in a central and concise way. Why Infer? Infer offers a declarative approach to application logic that especially shines in apps with: Complex data schemas, especially when rules need to look at data in many multiple or deeply nested associated types/modules Complex application logic, especially with many &quot;edge cases&quot; and other conditional logic Large parts of the data being loaded (e.g. from the database) is only needed to compute final results Infer helps in these cases, because: Application logic is declared in a concise and clean way that's readable even to non-developers (with a short introduction) Application logic can be laid out into modules as it makes sense for the application domain, not the code No execution code needs to be written, just call Infer with a single or list of records and the desired results, and it will compute them Infer loads required data as needed (e.g. from the database), in an optimized way that applies filtering, batching and concurrency, and avoids overfetching Usage use Infer.Ecto.Schema enables a module to specify inferences, such as use Infer.Ecto.Schema infer has_children? : true , when : %{ relatives : %{ relation : &quot;parent_of&quot; } } infer has_children? : false Unlike full-fledged inference engines (such as calypte or retex ), all rules in Infer are bound to an individual record type as their subject. This, in turn, allows to utilize Ecto schemas and queries to their full extent. Terminology infer ... defines a rule in a module. It applies to an instance of that module: A struct, Ecto record, Ash resource, ... This instance of a module, on which rules are evaluated, is the subject . A rule can have a condition , or :when part, that must be met in order for it to apply, e.g. %{relatives: %{relation: &quot;parent_of&quot;}} . When the condition is met, a given predicate is assigned a given value , e.g. has_children?: true . This is also called the result of the rule. All rules are evaluated from top to bottom until the first one for each predicate matches, similar to a cond statement. A condition can make use of other predicates as well as fields defined on the schema or struct of the underlying type. An executed rule results in a (derived) fact : subject, predicate, value. API overview Infer.get/3 evaluates the given predicate(s) using only the (pre)loaded data available, and returns the result(s) Infer.load/3 is like get , but loads any additional data as needed Infer.put/3 is like load , but puts the results into the :inferred field (or virtual schema field) of the subject(s) as a map, and returns the subject(s) These functions return a tuple, either {:ok, result} , {:error, error} , or {:not_loaded, data_reqs} (only get ). The corresponding Infer.get!/3 , Infer.load!/3 and Infer.put!/3 functions return result directly, or otherwise raise an exception. Arguments: subjects can either be an individual subject (with the given predicates defined on it), or a list of subjects. Passing an individual subject will return the predicates for the subject, passing a list will return a list of them. predicates can either be a single predicate, or a list of predicates. Passing a single predicate will return the resulting value, passing a list will return a map of the predicates and their resulting values. options (optional) See below. Options: args (list or map) can be used to pass in data from the caller's context that can be used in rules (see Arguments below). A classic example is the current_user , e.g. Infer . put! ( project , :can_edit? , args : [ user : current_user ] ) extra_rules (module or list of modules) can be used to add context-specific rules that are not defined directly on the subject. This can be used to structure rules into their own modules and use them only where needed. debug? (boolean) makes Infer print additional information to the console as rules are evaluated. Should only be used while debugging. Conditions In a rule condition, the part after when: ... , Maps represent multiple conditions, of which all need to be satisfied (logical AND ). Lists represent multiple conditions, of which at least one needs to be satisfied (logical OR ). Values can be negated using {:not, &quot;value&quot;} . Examples: # :role must be &quot;admin&quot; infer role : :admin , when : %{ role : &quot;admin&quot; } # :role must be either &quot;admin&quot; or &quot;superadmin&quot; infer role : :admin , when : %{ role : [ &quot;admin&quot; , &quot;superadmin&quot; ] } # :role must be &quot;admin&quot; and :verified? must be true infer role : :admin , when : %{ role : &quot;admin&quot; , verified? : true } # :role must be &quot;admin&quot; and :verified_at must not be nil infer role : :admin , when : %{ role : &quot;admin&quot; , verified_at : { :not , nil } } Boolean shorthand form A single atom is a shorthand for %{atom: true} . Conditions on list data When conditions are tested against list data, e.g. a person's list of roles, the condition is satisfied if at least one element of the list matches the given conditions (like Enum.any?/2 ). Although they might look similar, it's important to differentiate between lists that appear in conditions, and lists that appear in the data, which are checked against a condition. When both occur together, i.e. a list in a condition is checked against a list of values, the condition is met if at least one of the condition list elements applies to at least one element of the value list. For example: infer :can_edit? , when : %{ roles : [ &quot;project_manager&quot; , &quot;admin&quot; ] } iex&gt; % Person { roles : [ &quot;worker&quot; , &quot;assistant&quot; ] } |&gt; Infer . get! ( :can_edit? ) nil iex&gt; % Person { roles : [ &quot;assistant&quot; , &quot;project_manager&quot; ] } |&gt; Infer . get! ( :can_edit? ) true iex&gt; % Person { roles : [ &quot;admin&quot; ] } |&gt; Infer . get! ( :can_edit? ) true The same applies to complex conditions. Rule results The assigned value of a predicate is generally assigned as is. A few special tuples, however, will be replaced by Infer (see Features below) Example: infer d : 4 infer nested : %{ a : 1 , b : 2 , c : { :ref , :d } } # =&gt; %{a: 1, b: 2, c: 4} Features References Syntax: {:ref, path} (in conditions and result values) Arguments: path is a list of fields or predicates, starting from the subject. The brackets can be omitted (i.a. an atom passed), if the path consists of one element. The last element can be a map or list (see Branching below) Example: infer ot_fields : %{ editable : true } , when : %{ construction_bectu? : true , roles : %{ user : { :ref , [ :args , :user ] } , type : [ &quot;project_manager&quot; , &quot;admin&quot; ] } } Branching Any part of the path that represents an underlying list of subjects , such as referencing a has_many association, will cause the result of the :ref to be a list as well. It basically behaves similar to Enum.map/2 . A map as last element of a path will branch the returned result out into this map. The keys are returned as is, the values must be a list (or atom) continuing that path. This is particularly powerful when used on a list of subjects (see above), because it will return the given map with the values at the given paths for each underlying subject: A list as last element of a path behaves like a map where each value equals its key. Examples: infer list : [ %{ a : 1 , b : 2 , c : %{ d : 4 } } , %{ a : 9 , b : 8 , c : %{ d : 6 } } ] infer result1 : { :ref , [ :list , :a ] } # =&gt; [1, 9] infer result2 : { :ref , [ :list , %{ x : :a , y : [ :c , :d ] } ] } # =&gt; [%{x: 1, y: 4}, %{x: 9, y: 6}] infer result3 : { :ref , [ :list , [ :a , :b ] ] } # =&gt; [%{a: 1, b: 2}, %{a: 9, b: 8}] Arguments Passing :args as an option to any of the Infer API functions enables referencing the passed data in conditions and values using {:ref, [:args, ...]} . Overriding existing fields It's possible to give predicates the same name as existing fields in the schema. This represents the fact that these fields are derived from other data, using rules. Rules on these fields can even take into account the existing value of the underlying field. In order to reference it, use :fields in between a path or condition, for example: schema &quot;blog_posts&quot; do field :state field :published_at end # nilify published_at when deleted, or when it&#39;s an old archived post infer published_at : nil , when : %{ state : &quot;deleted&quot; } infer published_at : nil , when : %{ state : &quot;archived&quot; , fields : %{ published_at : { :before , ~D[2020-02-20] } } } infer published_at : { :ref , [ :fields , :published_at ] } While it's always possible to achieve a similar behavior by giving the predicate a different name than the field, and then mapping the predicate to the field somewhere else, using the field name in conjunction with :fields makes explicit that it's a conditional override. Binding subject parts Syntax: {:bind, key} (in conditions) {:bind, key, subcondition} (in conditions) {:bound, key} (in result values) {:bound, key, default} (in result values) When a condition is evaluated on a list of values, the first value satisfying the condition can be bound to a variable using {:bind, variable} . These bound values can be referenced using {:bound, key} with an optional default: {:bound, key, default} . infer project_manager : { :bound , :person } , when : %{ roles : %{ type : &quot;project_manager&quot; , person : { :bind , :person } } } Local aliases Syntax: infer_alias key: ... (in modules before using key in infer ... ) In order to create shorthands and avoid repetition, aliases can be defined. These apply only to subsequent rules within the same module and are not exposed in any other way. infer_alias pm? : %{ roles : %{ type : [ &quot;project_manager&quot; , admin ] } } infer ot_fields : %{ editable : true } , when : [ :pm? , %{ construction_bectu? : true } ] Calling functions Syntax: {&amp;module.fun/n, [arg_1, ..., arg_n]} (in result values) {&amp;module.fun/1, arg_1} (in result values) Any function can be called to map the given arguments to other values. The function arguments must be passed as a list, except if it's only one. Arguments can be fixed values or other Infer features (passed as is), such as references. infer day_of_week : { &amp; Date . day_of_week / 1 , { :ref , :date } } infer duration : { &amp; Timex . diff / 3 , [ { :ref , :start_datetime } , { :ref , :end_datetime } , :hours ] } Only pure functions with low overhead should be used. Infer might call them very often during evaluation (once after each loading of data). Querying Syntax: {:query_one, type, conditions} {:query_one, type, conditions, options} {:query_first, type, conditions} {:query_first, type, conditions, options} {:query_all, type, conditions} {:query_all, type, conditions, options} Arguments: type is a module name (or Ecto queryable), e.g. an Ecto schema conditions is a keyword list of fields and their respective values, or lists of values, they must match options is a subset of the options that Ecto queries support: order_by limit Conditions The first key-value pair has a special behavior: It is used as the main condition for Dataloader , and thus should have the highest cardinality. It must be a single value, not a list of values. Rule of thumb: Put a single field that has the most unique values as first condition. Transforming lists Syntax: {:filter, source, condition} (in result values) {:map, source, mapper} (in result values) {:map, source, bind_key/condition, mapper} (in result values) Arguments: source can either be a list literal, a field or predicate that evaluates to a list, or another feature such as a query. condition has the same form and functionality as any other rule condition. mapper can either be a field or predicate (atom), or is otherwise treated as any other rule value. There are 3 variants: {:filter, source, condition} keeps only elements from source , for which the condition is met. {:map, source, mapper} returns the result of mapper for each element in source . {:map, source, bind_key/condition, mapper} is a special form of :map , where the mapper is based on the subject of the rule, not the list element. The list element is referenced using the middle arg, which can be either: a bind_key (atom) - the current list element is referenced via {:bound, bind_key} in the mapper a condition - any values bound in the condition via {:bind, key, ...} can be accessed via {:bound, key} in the mapper Use the special form of :map only when you need to reference both the list element (via :bound ), and the subject of the rule (via :ref ). Using a combination of :filter and basic :map instead is always preferred, if possible. Any nil elements in the list are mapped to nil , when using :map without condition. Examples: infer accepted_offers : { :filter , :offers , %{ state : &quot;accepted&quot; } } infer offer_ids : { :map , :offers , :id } infer first_offer_of_same_user : { :map , :offers , %{ state : &quot;accepted&quot; , user_id : { :bind , :uid , { :not , nil } } } , { :query_first , Offer , user_id : { :bound , :uid } , project_id : { :ref , :project_id } } } Counting Syntax: {:count, source, condition/predicate} (in result values) {:count_while, source, condition/predicate} (in result values) Arguments: source can either be a list literal, a field or predicate that evaluates to a list, or another feature such as a query. condition has the same form and functionality as any other rule condition. predicate can either be a predicate (atom) that returns either true , false , or :skip (only for :count_while ) Takes the given list and counts the elements that evaluate to true . :count_while stops after the first element that returns false . To not count an element, but not stop counting either, the given predicate may return :skip . Any nil elements in the list are treated as false . Predicate groups (not implemented yet) Groups with multiple predicates can be defined and used as shorthands in assigns and preloads. See predicate_group/1 for examples. By default, Infer defines :all_fields as a group of all fields defined, e.g. Struct fields, Ecto schema fields, ... Uses: In API: A group name can be passed to the Infer API to infer all predicates in that group. In rule results: Instead of a simple key, a list of keys can be given as a key as a short hand to setting the same value for all listed keys, e.g. %{[:admin?, :senior?] =&gt; true} . This also enables using predicate groups as keys. Rule checks at compile-time (not implemented yet) Problems that can be detected at compile-time: Invalid rule: &quot;Rule X uses non-existing predicate :has_child? . Did you mean :has_children? &quot; Invalid function call: &quot; Infer.get!(%Person{}, :has_child?) uses non-existing predicate :has_child? . Did you mean :has_children? &quot; Cycles in rule definitions: &quot;Cycle detected: Rule X on Person references Rule Y on Role. Rule Y on Role references Rule X on Person.&quot; Unreachable rules: &quot;Rule Y can never be reached, as Rule X always matches.&quot;","ref":"Infer.html","title":"Infer","type":"module"},{"doc":"Removes all elements not matching the given condition from the given list.","ref":"Infer.html#filter/3","title":"Infer.filter/3","type":"function"},{"doc":"Evaluates one or multiple predicates for one or multiple records and returns the results. Does not load any additional data. Options :with_meta (boolean) - whether or not to return a map for predicates with meta data. When false , only the values are returned for all predicates. Default: true .","ref":"Infer.html#get/3","title":"Infer.get/3","type":"function"},{"doc":"Like get/3 but returns the result value, or raises an error.","ref":"Infer.html#get!/3","title":"Infer.get!/3","type":"function"},{"doc":"Like get/3 , but loads additional data if needed.","ref":"Infer.html#load/3","title":"Infer.load/3","type":"function"},{"doc":"Like get!/3 , but loads additional data if needed.","ref":"Infer.html#load!/3","title":"Infer.load!/3","type":"function"},{"doc":"Ensures that the given record(s) have all data loaded that is required to evaluate the given predicate(s). Options :refresh - whether or not to load data again that's already loaded. Default: false . Examples Preload data required to infer the value of the predicate :has_children? : defmodule Person do infer :has_children? , when : %{ relatives : %{ relation : &quot;parent_of&quot; } } end iex&gt; Infer . preload ( % Person { } , :has_children? ) % Person { relatives : [ % Relation { relation : &quot;sibling&quot; } , ... ] } iex&gt; Infer . preload ( [ % Person { } , ... ] , :has_children? ) [ % Person { relatives : [ % Relation { relation : &quot;sibling&quot; } , ... ] } , ... ]","ref":"Infer.html#preload/3","title":"Infer.preload/3","type":"function"},{"doc":"Preloads data for a record nested under the given field or path (list of fields) inside the given record(s).","ref":"Infer.html#preload_in/4","title":"Infer.preload_in/4","type":"function"},{"doc":"Loads the given predicate(s) for the given record(s) and merges the results into the inferred map field of the record(s), returning them. Options Same as for get/3 .","ref":"Infer.html#put/3","title":"Infer.put/3","type":"function"},{"doc":"","ref":"Infer.html#put!/3","title":"Infer.put!/3","type":"function"},{"doc":"Returns all records matching the given condition. Options :base_query (Ecto.Query) - query to use as a base for retrieving records. Can be used for additional conditions, pagination, etc. Default: Ecto.Query.from(x in ^type) . :put (predicate list) - predicates to evaluate, which are not part of the condition (requires predicate cache ). :put_with_meta (boolean) - whether or not the predicates listed in :put return a map when they have meta data. When false , only the value is returned for each. Default: true . :preload (predicate list) - load all data required to evaluate the given predicate(s) on the results (also see preload/2 ). Using :put and :preload In general, as much work as possible is done in the database: If possible, the condition is completely translated to an Ecto.Query so the database only returns matching records. Even predicates given via :put are evaluated in the database and returned as a single value, whenever possible. Use :preload to ensure that data is loaded, which is required to evaluate the given predicate(s) in the application. Examples Entity . query ( Offer , :construction_bectu? , preload : [ :all_fields ] ) # SELECT offers o # INNER JOIN projects p ON p.id = o.project_id # INNER JOIN job_titles j ON j.id = o.job_title_id # WHERE # &quot;p.contruction_bectu?&quot; = TRUE AND # j.type &lt;&gt; &#39;standard&#39; { :ok , [ % Offer { } , % Offer { } , ... ] , [ %{ construction_bectu? : true } , %{ construction_bectu? : true } , ... ] } Entity . query ( Offer , %{ id : [ 1 , 4 , 5 ] , construction_bectu? : true } ) # SELECT offers o # INNER JOIN projects p ON p.id = o.project_id # INNER JOIN job_titles j ON j.id = o.job_title_id # WHERE # &quot;p.contruction_bectu?&quot; = TRUE AND # j.type &lt;&gt; &#39;standard&#39; AND # o.id IN (1, 4, 5) { :ok , [ % Offer { } , % Offer { } ] , [ %{ construction_bectu? : true } , %{ construction_bectu? : true } ] } Entity . query ( Offer , %{ rate_type : :flat_rate_ot } ) # SELECT offers o # INNER JOIN projects p ON p.id = o.project_id # WHERE # (p.type = &#39;Feature Film&#39; AND # p.bectu_type = &#39;NONE&#39;) # OR # (p.type = &#39;Television&#39; AND # p.bectu_type IN (&#39;BECTU_CUSTOM_OVERTIME&#39;, &#39;NONE&#39;)) { :ok , [ % Offer { } , % Offer { } , ... ] , [ %{ rate_type : :flat_rate_ot } , %{ rate_type : :flat_rate_ot } , ... ] }","ref":"Infer.html#query_all/3","title":"Infer.query_all/3","type":"function"},{"doc":"Returns the first record matching the given condition. Options Same as for query_all/3 .","ref":"Infer.html#query_one/3","title":"Infer.query_one/3","type":"function"},{"doc":"Removes all elements matching the given condition from the given list.","ref":"Infer.html#reject/3","title":"Infer.reject/3","type":"function"},{"doc":"","ref":"Infer.DSL.html","title":"Infer.DSL","type":"module"},{"doc":"","ref":"Infer.DSL.html#add/2","title":"Infer.DSL.add/2","type":"function"},{"doc":"","ref":"Infer.DSL.html#bind/2","title":"Infer.DSL.bind/2","type":"function"},{"doc":"","ref":"Infer.DSL.html#bind_all/2","title":"Infer.DSL.bind_all/2","type":"function"},{"doc":"","ref":"Infer.DSL.html#bound/1","title":"Infer.DSL.bound/1","type":"function"},{"doc":"","ref":"Infer.DSL.html#count/1","title":"Infer.DSL.count/1","type":"function"},{"doc":"","ref":"Infer.DSL.html#iterator/0","title":"Infer.DSL.iterator/0","type":"function"},{"doc":"","ref":"Infer.DSL.html#range/2","title":"Infer.DSL.range/2","type":"function"},{"doc":"","ref":"Infer.DSL.html#ref/1","title":"Infer.DSL.ref/1","type":"function"},{"doc":"","ref":"Infer.DSL.html#t:path/0","title":"Infer.DSL.path/0","type":"type"},{"doc":"","ref":"Infer.DSL.Add.html","title":"Infer.DSL.Add","type":"module"},{"doc":"","ref":"Infer.DSL.Add.html#t:t/0","title":"Infer.DSL.Add.t/0","type":"type"},{"doc":"","ref":"Infer.DSL.Bind.html","title":"Infer.DSL.Bind","type":"module"},{"doc":"","ref":"Infer.DSL.Bind.html#as/2","title":"Infer.DSL.Bind.as/2","type":"function"},{"doc":"","ref":"Infer.DSL.Bind.html#t:t/0","title":"Infer.DSL.Bind.t/0","type":"type"},{"doc":"","ref":"Infer.DSL.BindAll.html","title":"Infer.DSL.BindAll","type":"module"},{"doc":"","ref":"Infer.DSL.BindAll.html#as/2","title":"Infer.DSL.BindAll.as/2","type":"function"},{"doc":"","ref":"Infer.DSL.BindAll.html#t:t/0","title":"Infer.DSL.BindAll.t/0","type":"type"},{"doc":"Represents a reference to a variable bound using Bind or BindAll . Instead of an Atom or String to reference the bound value as a whole, a List can be passed to get a nested value at the given path inside the bound variable.","ref":"Infer.DSL.Bound.html","title":"Infer.DSL.Bound","type":"module"},{"doc":"","ref":"Infer.DSL.Bound.html#t:t/0","title":"Infer.DSL.Bound.t/0","type":"type"},{"doc":"","ref":"Infer.DSL.Count.html","title":"Infer.DSL.Count","type":"module"},{"doc":"","ref":"Infer.DSL.Count.html#t:t/0","title":"Infer.DSL.Count.t/0","type":"type"},{"doc":"Represents an iterator inside a loop, e.g. MapWhile .","ref":"Infer.DSL.Iterator.html","title":"Infer.DSL.Iterator","type":"module"},{"doc":"","ref":"Infer.DSL.Iterator.html#t:t/0","title":"Infer.DSL.Iterator.t/0","type":"type"},{"doc":"","ref":"Infer.DSL.MapWhile.html","title":"Infer.DSL.MapWhile","type":"module"},{"doc":"","ref":"Infer.DSL.MapWhile.html#t:t/0","title":"Infer.DSL.MapWhile.t/0","type":"type"},{"doc":"","ref":"Infer.DSL.QueryAll.html","title":"Infer.DSL.QueryAll","type":"module"},{"doc":"","ref":"Infer.DSL.QueryAll.html#t:t/0","title":"Infer.DSL.QueryAll.t/0","type":"type"},{"doc":"","ref":"Infer.DSL.Range.html","title":"Infer.DSL.Range","type":"module"},{"doc":"","ref":"Infer.DSL.Range.html#t:t/0","title":"Infer.DSL.Range.t/0","type":"type"},{"doc":"Represents a reference to another field. :path is always traversed from the root, i.e. the type where the rule is defined. An Atom or String instead of a List is treated as if it was a list with one element. En empty list [] references the subject itself, as a whole.","ref":"Infer.DSL.Ref.html","title":"Infer.DSL.Ref","type":"module"},{"doc":"","ref":"Infer.DSL.Ref.html#to/1","title":"Infer.DSL.Ref.to/1","type":"function"},{"doc":"","ref":"Infer.DSL.Ref.html#t:t/0","title":"Infer.DSL.Ref.t/0","type":"type"},{"doc":"Functions to dynamically generate Ecto query parts.","ref":"Infer.Ecto.Query.html","title":"Infer.Ecto.Query","type":"module"},{"doc":"Returns a 2-tuple with the modified queryable with the given conditions applied as WHERE clauses any remaining conditions that couldn't be added to the query Returns {query, true} if all conditions could be added to the query.","ref":"Infer.Ecto.Query.html#apply_condition/3","title":"Infer.Ecto.Query.apply_condition/3","type":"function"},{"doc":"Applies all known options to the given queryable and returns it, along with all options that were unknown.","ref":"Infer.Ecto.Query.html#apply_options/2","title":"Infer.Ecto.Query.apply_options/2","type":"function"},{"doc":"Apply all options to the given queryable , raise on any unknown option.","ref":"Infer.Ecto.Query.html#from_options/2","title":"Infer.Ecto.Query.from_options/2","type":"function"},{"doc":"","ref":"Infer.Ecto.Query.html#inspect/2","title":"Infer.Ecto.Query.inspect/2","type":"function"},{"doc":"","ref":"Infer.Ecto.Query.html#is_simple/1","title":"Infer.Ecto.Query.is_simple/1","type":"macro"},{"doc":"","ref":"Infer.Ecto.Query.html#limit/2","title":"Infer.Ecto.Query.limit/2","type":"function"},{"doc":"","ref":"Infer.Ecto.Query.html#order_by/2","title":"Infer.Ecto.Query.order_by/2","type":"function"},{"doc":"Returns generated SQL for given query with all params replaced","ref":"Infer.Ecto.Query.html#to_sql/2","title":"Infer.Ecto.Query.to_sql/2","type":"function"},{"doc":"Add predicate-based filters to a queryable and return it.","ref":"Infer.Ecto.Query.html#where/3","title":"Infer.Ecto.Query.where/3","type":"function"},{"doc":"Internal data structure to keep track of all context needed to translate complex Infer rules to Ecto queries. Context switches Evaluate rule on other subject Can not access existing aliases Reset path Keep only next alias index Subquery (EXISTS) Can access existing aliases &amp; path Mark existing aliases &amp; path entries as :parent Add alias &amp; path entry Join Can access existing aliases &amp; path Add alias &amp; path entry","ref":"Infer.Ecto.Query.Builder.html","title":"Infer.Ecto.Query.Builder","type":"module"},{"doc":"","ref":"Infer.Ecto.Query.Builder.html#add_aliased/1","title":"Infer.Ecto.Query.Builder.add_aliased/1","type":"function"},{"doc":"","ref":"Infer.Ecto.Query.Builder.html#add_aliased_join/2","title":"Infer.Ecto.Query.Builder.add_aliased_join/2","type":"function"},{"doc":"","ref":"Infer.Ecto.Query.Builder.html#current_alias/1","title":"Infer.Ecto.Query.Builder.current_alias/1","type":"function"},{"doc":"","ref":"Infer.Ecto.Query.Builder.html#current_type/1","title":"Infer.Ecto.Query.Builder.current_type/1","type":"function"},{"doc":"","ref":"Infer.Ecto.Query.Builder.html#field/3","title":"Infer.Ecto.Query.Builder.field/3","type":"function"},{"doc":"","ref":"Infer.Ecto.Query.Builder.html#from_root/2","title":"Infer.Ecto.Query.Builder.from_root/2","type":"function"},{"doc":"","ref":"Infer.Ecto.Query.Builder.html#init/2","title":"Infer.Ecto.Query.Builder.init/2","type":"function"},{"doc":"","ref":"Infer.Ecto.Query.Builder.html#negate/2","title":"Infer.Ecto.Query.Builder.negate/2","type":"function"},{"doc":"","ref":"Infer.Ecto.Query.Builder.html#root_alias/1","title":"Infer.Ecto.Query.Builder.root_alias/1","type":"function"},{"doc":"","ref":"Infer.Ecto.Query.Builder.html#root_type/1","title":"Infer.Ecto.Query.Builder.root_type/1","type":"function"},{"doc":"","ref":"Infer.Ecto.Query.Builder.html#step_into/4","title":"Infer.Ecto.Query.Builder.step_into/4","type":"function"},{"doc":"","ref":"Infer.Ecto.Query.Builder.html#with_join/3","title":"Infer.Ecto.Query.Builder.with_join/3","type":"function"},{"doc":"","ref":"Infer.Ecto.Query.Builder.html#t:mapped_alias/0","title":"Infer.Ecto.Query.Builder.mapped_alias/0","type":"type"},{"doc":"","ref":"Infer.Ecto.Query.Builder.html#t:t/0","title":"Infer.Ecto.Query.Builder.t/0","type":"type"},{"doc":"See Infer .","ref":"Infer.Ecto.Schema.html","title":"Infer.Ecto.Schema","type":"module"},{"doc":"Encapsulates the main functionality of working with rules.","ref":"Infer.Engine.html","title":"Infer.Engine","type":"module"},{"doc":"","ref":"Infer.Engine.html#evaluate_condition/3","title":"Infer.Engine.evaluate_condition/3","type":"function"},{"doc":"Traverses the value of a rule, replacing special tuples {:ref, path} with the predicate or field value found at the given path {fun/n, arg_1, ..., arg_n} with the result of calling the given function with the given arguments (which in turn can be special tuples) {:bound, :var} - with a corresponding matching {:bind, :var} {:bound, :var, default} - same with default ...","ref":"Infer.Engine.html#map_result/2","title":"Infer.Engine.map_result/2","type":"function"},{"doc":"Returns the result of evaluating a field or predicate.","ref":"Infer.Engine.html#resolve/3","title":"Infer.Engine.resolve/3","type":"function"},{"doc":"Returns the result of evaluating a predicate.","ref":"Infer.Engine.html#resolve_predicate/3","title":"Infer.Engine.resolve_predicate/3","type":"function"},{"doc":"","ref":"Infer.Engine.html#resolve_source/2","title":"Infer.Engine.resolve_source/2","type":"function"},{"doc":"Represents an evaluation run in Infer.Engine according to the token pattern in Elixir.","ref":"Infer.Evaluation.html","title":"Infer.Evaluation","type":"module"},{"doc":"","ref":"Infer.Evaluation.html#add_options/2","title":"Infer.Evaluation.add_options/2","type":"function"},{"doc":"","ref":"Infer.Evaluation.html#from_options/1","title":"Infer.Evaluation.from_options/1","type":"function"},{"doc":"Loads the given data requirements in an evaluation, and returns it updated.","ref":"Infer.Evaluation.html#load_data_reqs/2","title":"Infer.Evaluation.load_data_reqs/2","type":"function"},{"doc":"","ref":"Infer.Evaluation.html#t:t/0","title":"Infer.Evaluation.t/0","type":"type"},{"doc":"Uses Dataloader to load missing data incrementally.","ref":"Infer.Loaders.Dataloader.html","title":"Infer.Loaders.Dataloader","type":"module"},{"doc":"","ref":"Infer.Loaders.Dataloader.html#config/1","title":"Infer.Loaders.Dataloader.config/1","type":"function"},{"doc":"","ref":"Infer.Loaders.Dataloader.html#init/0","title":"Infer.Loaders.Dataloader.init/0","type":"function"},{"doc":"","ref":"Infer.Loaders.Dataloader.html#load/2","title":"Infer.Loaders.Dataloader.load/2","type":"function"},{"doc":"","ref":"Infer.Loaders.Dataloader.html#lookup/2","title":"Infer.Loaders.Dataloader.lookup/2","type":"function"},{"doc":"Receives the module attributes created by the macros in Infer.DSL and converts them into normalized aliases and lists of Infer.Rule structs.","ref":"Infer.Parser.html","title":"Infer.Parser","type":"module"},{"doc":"","ref":"Infer.Parser.html#directive_to_rules/2","title":"Infer.Parser.directive_to_rules/2","type":"function"},{"doc":"","ref":"Infer.Parser.html#normalize_aliases/1","title":"Infer.Parser.normalize_aliases/1","type":"function"},{"doc":"Entry point for this module","ref":"Infer.Parser.html#parse/2","title":"Infer.Parser.parse/2","type":"function"},{"doc":"","ref":"Infer.Parser.Token.html","title":"Infer.Parser.Token","type":"module"},{"doc":"Encapsulates all static args to be passed around between functions.","ref":"Infer.Parser.Token.html#__struct__/0","title":"Infer.Parser.Token.__struct__/0","type":"function"},{"doc":"","ref":"Infer.Parser.Token.html#set_aliases/2","title":"Infer.Parser.Token.set_aliases/2","type":"function"},{"doc":"","ref":"Infer.Parser.Token.html#with_opts/2","title":"Infer.Parser.Token.with_opts/2","type":"function"},{"doc":"","ref":"Infer.Parser.Token.html#t:t/0","title":"Infer.Parser.Token.t/0","type":"type"},{"doc":"Determines preloads based on predicates to be inferred.","ref":"Infer.Preloader.html","title":"Infer.Preloader","type":"module"},{"doc":"This is the entry point for this module.","ref":"Infer.Preloader.html#preload_for_predicates/3","title":"Infer.Preloader.preload_for_predicates/3","type":"function"},{"doc":"Result types and helpers to work with them. A result is either: {:error, e} if an error occurred {:not_loaded, data_reqs} if the result could not be determined without loading more data {:ok, boolean, binds} otherwise, in contexts where a boolean is expected (type t:b() ) {:ok, result, binds} otherwise, where result can be any value (type t:v() ) Data loading In general, {:not_loaded, all_reqs} only ever returns data requirements that are really needed. Example using all For example, using all?/1 with 3 conditions A, B and C, where iex&gt; [ ...&gt; { :ok , true , %{ } } , # A ...&gt; { :not_loaded , [ 1 ] } , # B ...&gt; { :ok , false , %{ } } , # C ...&gt; ] ...&gt; |&gt; Infer.Result . all? ( ) { :ok , false , %{ } } The overall result is {:ok, false, %{}} . While B would need more data to be loaded, C can already determind and is false , so and any additional data loaded will not change that. Example using find Another example, using find/1 with 5 conditions A, B, C, D and E, where iex&gt; [ ...&gt; { :ok , false , %{ } } , # A ...&gt; { :not_loaded , [ 1 ] } , # B ...&gt; { :not_loaded , [ 2 ] } , # C ...&gt; { :ok , true , %{ } } , # D ...&gt; { :not_loaded , [ 3 ] } , # E ...&gt; ] ...&gt; |&gt; Infer.Result . find ( ) { :not_loaded , [ 1 , 2 ] } The overall result is {:not_loaded, data_reqs1 + data_reqs2} . While D can already be determined and is {:ok, true, %{}} , B and C come first and need more data to be loaded, so they can be determined and returned if either is {:ok, true, %{}} first. All data requirements that might be needed are returned together in the result (those of B and C), while those of E can be ruled out, as D already returns {:ok, true, %{}} and comes first.","ref":"Infer.Result.html","title":"Infer.Result","type":"module"},{"doc":"Returns {:ok, true} if fun evaluates to {:ok, true} for all elements in enum . Otherwise, returns {:not_loaded, data_reqs} if any yield that. Otherwise, returns {:ok, false} . Examples iex&gt; [ ...&gt; { :ok , true , %{ } } , ...&gt; { :not_loaded , [ ] } , ...&gt; { :ok , false , %{ } } , ...&gt; ] ...&gt; |&gt; Infer.Result . all? ( ) { :ok , false , %{ } } iex&gt; [ ...&gt; { :ok , true , %{ } } , ...&gt; { :not_loaded , [ ] } , ...&gt; { :ok , true , %{ } } , ...&gt; ] ...&gt; |&gt; Infer.Result . all? ( ) { :not_loaded , [ ] } iex&gt; [ ...&gt; { :ok , true , %{ } } , ...&gt; { :ok , true , %{ } } , ...&gt; ] ...&gt; |&gt; Infer.Result . all? ( ) { :ok , true , %{ } }","ref":"Infer.Result.html#all?/2","title":"Infer.Result.all?/2","type":"function"},{"doc":"Returns {:ok, true, binds} if fun evaluates to {:ok, true, binds} for any element in enum . Otherwise, returns {:not_loaded, data_reqs} if any yields that. Otherwise, returns {:ok, false, %{}} . Examples iex&gt; [ ...&gt; { :ok , true , %{ a : 1 } } , ...&gt; { :not_loaded , [ ] } , ...&gt; { :ok , false , %{ } } , ...&gt; ] ...&gt; |&gt; Infer.Result . any? ( ) { :ok , true , %{ a : 1 } } iex&gt; [ ...&gt; { :ok , false , %{ } } , ...&gt; { :not_loaded , [ ] } , ...&gt; { :ok , false , %{ } } , ...&gt; ] ...&gt; |&gt; Infer.Result . any? ( ) { :not_loaded , [ ] } iex&gt; [ ...&gt; { :ok , false , %{ } } , ...&gt; { :ok , false , %{ } } , ...&gt; ] ...&gt; |&gt; Infer.Result . any? ( ) { :ok , false , %{ } }","ref":"Infer.Result.html#any?/2","title":"Infer.Result.any?/2","type":"function"},{"doc":"If ok, binds the result to the given key and returns the updated tuple. Otherwise, returns first argument as is.","ref":"Infer.Result.html#bind/3","title":"Infer.Result.bind/3","type":"function"},{"doc":"Returns the number of elements for which fun evaluates to {:ok, true} . If any elements return {:not_loaded, data_reqs} , returns all of them combined as {:not_loaded, ...} . Otherwise, returns {:ok, default} . Examples iex&gt; [ ...&gt; { :ok , true , %{ } } , ...&gt; { :ok , false , %{ } } , ...&gt; { :ok , true , %{ } } , ...&gt; ] ...&gt; |&gt; Infer.Result . count ( ) { :ok , 2 , %{ } } iex&gt; [ ...&gt; { :ok , false , %{ } } , ...&gt; { :not_loaded , [ 1 ] } , ...&gt; { :not_loaded , [ 2 ] } , ...&gt; { :ok , true , %{ } } , ...&gt; { :not_loaded , [ 3 ] } , ...&gt; ] ...&gt; |&gt; Infer.Result . count ( ) { :not_loaded , [ 1 , 2 , 3 ] } iex&gt; [ ...&gt; { :ok , true , %{ } } , ...&gt; { :ok , :skip , %{ } } , ...&gt; { :ok , false , %{ } } , ...&gt; { :ok , false , %{ } } , ...&gt; ] ...&gt; |&gt; Infer.Result . count ( ) { :ok , 1 , %{ } } iex&gt; [ ...&gt; false , ...&gt; false , ...&gt; ] ...&gt; |&gt; Infer.Result . count ( &amp; { :ok , not &amp;1 , %{ } } ) { :ok , 2 , %{ } }","ref":"Infer.Result.html#count/2","title":"Infer.Result.count/2","type":"function"},{"doc":"Returns the number of elements before fun evaluates to {:ok, false} or an element is nil . Elements are skipped (not counted) whenever fun evaluates to {:ok, :skip} . If any elements before that return {:not_loaded, data_reqs} , returns all of them combined as {:not_loaded, ...} . Otherwise, returns {:ok, default} . Examples iex&gt; [ ...&gt; { :ok , true , %{ } } , ...&gt; { :not_loaded , [ ] } , ...&gt; { :ok , false , %{ } } , ...&gt; ] ...&gt; |&gt; Infer.Result . count_while ( ) { :not_loaded , [ ] } iex&gt; [ ...&gt; { :ok , false , %{ } } , ...&gt; { :not_loaded , [ 1 ] } , ...&gt; { :not_loaded , [ 2 ] } , ...&gt; { :ok , true , %{ } } , ...&gt; { :not_loaded , [ 3 ] } , ...&gt; ] ...&gt; |&gt; Infer.Result . count_while ( ) { :ok , 0 , %{ } } iex&gt; [ ...&gt; { :ok , true , %{ } } , ...&gt; { :ok , :skip , %{ } } , ...&gt; { :ok , false , %{ } } , ...&gt; { :ok , false , %{ } } , ...&gt; ] ...&gt; |&gt; Infer.Result . count_while ( ) { :ok , 1 , %{ } } iex&gt; [ ...&gt; false , ...&gt; false , ...&gt; ] ...&gt; |&gt; Infer.Result . count_while ( &amp; { :ok , not &amp;1 , %{ } } ) { :ok , 2 , %{ } }","ref":"Infer.Result.html#count_while/2","title":"Infer.Result.count_while/2","type":"function"},{"doc":"","ref":"Infer.Result.html#filter_map/3","title":"Infer.Result.filter_map/3","type":"function"},{"doc":"Returns {:ok, elem} for the first elem for which fun evaluates to {:ok, true} . If any elements before that return {:not_loaded, data_reqs} , returns all of them combined as {:not_loaded, ...} . Otherwise, returns {:ok, default} . Examples iex&gt; [ ...&gt; { :ok , true , %{ } } , ...&gt; { :not_loaded , [ ] } , ...&gt; { :ok , false , %{ } } , ...&gt; ] ...&gt; |&gt; Infer.Result . find ( ) { :ok , { :ok , true , %{ } } , %{ } } iex&gt; [ ...&gt; { :ok , false , %{ } } , ...&gt; { :not_loaded , [ 1 ] } , ...&gt; { :not_loaded , [ 2 ] } , ...&gt; { :ok , true , %{ } } , ...&gt; { :not_loaded , [ 3 ] } , ...&gt; ] ...&gt; |&gt; Infer.Result . find ( ) { :not_loaded , [ 1 , 2 ] } iex&gt; [ ...&gt; { :ok , false , %{ } } , ...&gt; { :ok , false , %{ } } , ...&gt; ] ...&gt; |&gt; Infer.Result . find ( ) { :ok , nil , %{ } } iex&gt; [ ...&gt; false , ...&gt; false , ...&gt; ] ...&gt; |&gt; Infer.Result . find ( &amp; { :ok , not &amp;1 , %{ } } ) { :ok , false , %{ } }","ref":"Infer.Result.html#find/4","title":"Infer.Result.find/4","type":"function"},{"doc":"Converts 2-tuples to the internal 3-tuple result format (type t:v() or t:b() ). Examples iex&gt; { :ok , 5 } ...&gt; |&gt; Infer.Result . from_simple ( ) { :ok , 5 , %{ } } iex&gt; { :error , :err } ...&gt; |&gt; Infer.Result . from_simple ( ) { :error , :err }","ref":"Infer.Result.html#from_simple/1","title":"Infer.Result.from_simple/1","type":"function"},{"doc":"Returns {:ok, mapped_results, binds} if all elements map to {:ok, result, binds} . Otherwise, returns {:error, e} on error, or {:not_loaded, data_reqs} with all data requirements. Examples iex&gt; [ ...&gt; { :ok , 1 , %{ } } , ...&gt; { :ok , 2 , %{ } } , ...&gt; { :ok , 3 , %{ } } , ...&gt; ] ...&gt; |&gt; Infer.Result . map ( ) { :ok , [ 1 , 2 , 3 ] , %{ } } iex&gt; [ ...&gt; { :ok , 1 , %{ } } , ...&gt; { :not_loaded , [ :x ] } , ...&gt; { :ok , 3 , %{ } } , ...&gt; { :not_loaded , [ :y ] } , ...&gt; ] ...&gt; |&gt; Infer.Result . map ( ) { :not_loaded , [ :x , :y ] } iex&gt; [ ...&gt; { :ok , 1 , %{ } } , ...&gt; { :error , :x } , ...&gt; { :ok , 3 , %{ } } , ...&gt; { :not_loaded , [ :y ] } , ...&gt; ] ...&gt; |&gt; Infer.Result . map ( ) { :error , :x }","ref":"Infer.Result.html#map/2","title":"Infer.Result.map/2","type":"function"},{"doc":"Returns {:ok, new_keyword_list, binds} with new values if all values map to {:ok, new_value, binds} . Otherwise, returns {:error, e} on error, or {:not_loaded, data_reqs} with all data requirements. Examples iex&gt; [ ...&gt; a : { :ok , 1 , %{ } } , ...&gt; b : { :ok , 2 , %{ } } , ...&gt; c : { :ok , 3 , %{ } } , ...&gt; ] ...&gt; |&gt; Infer.Result . map_keyword_values ( ) { :ok , [ a : 1 , b : 2 , c : 3 ] , %{ } } iex&gt; [ ...&gt; a : { :ok , 1 , %{ } } , ...&gt; b : { :not_loaded , MapSet . new ( [ :x ] ) } , ...&gt; c : { :ok , 3 , %{ } } , ...&gt; d : { :not_loaded , MapSet . new ( [ :y ] ) } , ...&gt; ] ...&gt; |&gt; Infer.Result . map_keyword_values ( ) { :not_loaded , MapSet . new ( [ :x , :y ] ) } iex&gt; [ ...&gt; a : { :ok , 1 , %{ } } , ...&gt; b : { :error , :x } , ...&gt; c : { :ok , 3 , %{ } } , ...&gt; d : { :not_loaded , [ :y ] } , ...&gt; ] ...&gt; |&gt; Infer.Result . map_keyword_values ( ) { :error , :x }","ref":"Infer.Result.html#map_keyword_values/2","title":"Infer.Result.map_keyword_values/2","type":"function"},{"doc":"Returns {:ok, new_map, binds} with new values if all values map to {:ok, new_value, binds} . Otherwise, returns {:error, e} on error, or {:not_loaded, data_reqs} with all data requirements. Examples iex&gt; %{ ...&gt; a : { :ok , 1 , %{ } } , ...&gt; b : { :ok , 2 , %{ } } , ...&gt; c : { :ok , 3 , %{ } } , ...&gt; } ...&gt; |&gt; Infer.Result . map_values ( ) { :ok , %{ a : 1 , b : 2 , c : 3 } , %{ } } iex&gt; %{ ...&gt; a : { :ok , 1 , %{ } } , ...&gt; b : { :not_loaded , MapSet . new ( [ :x ] ) } , ...&gt; c : { :ok , 3 , %{ } } , ...&gt; d : { :not_loaded , MapSet . new ( [ :y ] ) } , ...&gt; } ...&gt; |&gt; Infer.Result . map_values ( ) { :not_loaded , MapSet . new ( [ :x , :y ] ) } iex&gt; %{ ...&gt; a : { :ok , 1 , %{ } } , ...&gt; b : { :error , :x } , ...&gt; c : { :ok , 3 , %{ } } , ...&gt; d : { :not_loaded , [ :y ] } , ...&gt; } ...&gt; |&gt; Infer.Result . map_values ( ) { :error , :x }","ref":"Infer.Result.html#map_values/2","title":"Infer.Result.map_values/2","type":"function"},{"doc":"Wraps a value in an :ok result.","ref":"Infer.Result.html#ok/2","title":"Infer.Result.ok/2","type":"function"},{"doc":"When given {:ok, value, binds} , runs fun on value and returns the result. Otherwise, returns first argument as is.","ref":"Infer.Result.html#then/2","title":"Infer.Result.then/2","type":"function"},{"doc":"Converts the internal 3-tuple result format (type t:v() or t:b() ) to a 2-tuple format. Examples iex&gt; { :ok , 5 , %{ } } ...&gt; |&gt; Infer.Result . to_simple ( ) { :ok , 5 } iex&gt; { :error , :err } ...&gt; |&gt; Infer.Result . to_simple ( ) { :error , :err }","ref":"Infer.Result.html#to_simple/1","title":"Infer.Result.to_simple/1","type":"function"},{"doc":"When given {:ok, value, binds} , runs fun on value and returns {:ok, new_value, binds} . Otherwise, returns first argument as is.","ref":"Infer.Result.html#transform/2","title":"Infer.Result.transform/2","type":"function"},{"doc":"When given {:ok, value, binds} or {:ok, value} , returns value . Otherwise, raises an exception.","ref":"Infer.Result.html#unwrap!/1","title":"Infer.Result.unwrap!/1","type":"function"},{"doc":"Possible return values from conditions.","ref":"Infer.Result.html#t:b/0","title":"Infer.Result.b/0","type":"type"},{"doc":"","ref":"Infer.Result.html#t:binds/0","title":"Infer.Result.binds/0","type":"type"},{"doc":"Possible return values from resolving predicates.","ref":"Infer.Result.html#t:v/0","title":"Infer.Result.v/0","type":"type"},{"doc":"Represents a rule to apply to an Infer, based on an individual record. when Nested map with data requirements and matching values. Lists mean one of the values must match. Negations can be expressed using {:not, value} or {:not, [values]} .","ref":"Infer.Rule.html","title":"Infer.Rule","type":"module"},{"doc":"","ref":"Infer.Rule.html#t:t/0","title":"Infer.Rule.t/0","type":"type"},{"doc":"See Infer .","ref":"Infer.Rules.html","title":"Infer.Rules","type":"module"},{"doc":"Alias for predicate_group/1 .","ref":"Infer.Rules.html#field_group/1","title":"Infer.Rules.field_group/1","type":"macro"},{"doc":"","ref":"Infer.Rules.html#import_rules/2","title":"Infer.Rules.import_rules/2","type":"macro"},{"doc":"","ref":"Infer.Rules.html#infer/1","title":"Infer.Rules.infer/1","type":"macro"},{"doc":"","ref":"Infer.Rules.html#infer/2","title":"Infer.Rules.infer/2","type":"macro"},{"doc":"","ref":"Infer.Rules.html#infer_alias/1","title":"Infer.Rules.infer_alias/1","type":"macro"},{"doc":"","ref":"Infer.Rules.html#predicate_group/1","title":"Infer.Rules.predicate_group/1","type":"macro"},{"doc":"Helpers needed in several core modules.","ref":"Infer.Util.html","title":"Infer.Util","type":"module"},{"doc":"Merges two nested maps recursively.","ref":"Infer.Util.html#deep_merge/2","title":"Infer.Util.deep_merge/2","type":"function"},{"doc":"","ref":"Infer.Util.html#rules_for_predicate/3","title":"Infer.Util.rules_for_predicate/3","type":"function"},{"doc":"Utility functions to inspect Ecto schemas. See: https://hexdocs.pm/ecto/Ecto.Schema.html#module-reflection","ref":"Infer.Util.Ecto.html","title":"Infer.Util.Ecto","type":"module"},{"doc":"","ref":"Infer.Util.Ecto.html#association_details/2","title":"Infer.Util.Ecto.association_details/2","type":"function"},{"doc":"","ref":"Infer.Util.Ecto.html#association_names/1","title":"Infer.Util.Ecto.association_names/1","type":"function"},{"doc":"","ref":"Infer.Util.Ecto.html#association_type/2","title":"Infer.Util.Ecto.association_type/2","type":"function"},{"doc":"","ref":"Infer.Util.Ecto.html#field_details/2","title":"Infer.Util.Ecto.field_details/2","type":"function"},{"doc":"Utility functions for working with Enum data structures.","ref":"Infer.Util.Enum.html","title":"Infer.Util.Enum","type":"module"},{"doc":"","ref":"Infer.Util.Enum.html#zip/4","title":"Infer.Util.Enum.zip/4","type":"function"},{"doc":"Utility functions for working with Map data structures.","ref":"Infer.Util.Map.html","title":"Infer.Util.Map","type":"module"},{"doc":"","ref":"Infer.Util.Map.html#do_get_in/2","title":"Infer.Util.Map.do_get_in/2","type":"function"},{"doc":"","ref":"Infer.Util.Map.html#do_put_in/3","title":"Infer.Util.Map.do_put_in/3","type":"function"},{"doc":"","ref":"Infer.Util.Map.html#do_zip/3","title":"Infer.Util.Map.do_zip/3","type":"function"},{"doc":"When given two maps, merges the second map into the first. When the first argument is nil , returns the second argument.","ref":"Infer.Util.Map.html#maybe_merge/2","title":"Infer.Util.Map.maybe_merge/2","type":"function"},{"doc":"Returns a Map with given keys and values zipped together Examples iex&gt; [ :d , :e , :b ] ...&gt; |&gt; Infer.Util.Map . zip ( [ 8 , 2 , 3 ] ) %{ d : 8 , e : 2 , b : 3 }","ref":"Infer.Util.Map.html#zip/2","title":"Infer.Util.Map.zip/2","type":"function"},{"doc":"Utility functions for working with modules and their functions.","ref":"Infer.Util.Module.html","title":"Infer.Util.Module","type":"module"},{"doc":"See Kernel.function_exported?/3 .","ref":"Infer.Util.Module.html#has_function?/3","title":"Infer.Util.Module.has_function?/3","type":"function"},{"doc":"","ref":"Infer.Ecto.Query.TranslationError.html","title":"Infer.Ecto.Query.TranslationError","type":"exception"},{"doc":"Callback implementation for Exception.message/1 .","ref":"Infer.Ecto.Query.TranslationError.html#message/1","title":"Infer.Ecto.Query.TranslationError.message/1","type":"function"},{"doc":"","ref":"Infer.Error.NotLoaded.html","title":"Infer.Error.NotLoaded","type":"exception"},{"doc":"Callback implementation for Exception.message/1 .","ref":"Infer.Error.NotLoaded.html#message/1","title":"Infer.Error.NotLoaded.message/1","type":"function"},{"doc":"","ref":"Infer.Error.RulesNotFound.html","title":"Infer.Error.RulesNotFound","type":"exception"},{"doc":"Callback implementation for Exception.message/1 .","ref":"Infer.Error.RulesNotFound.html#message/1","title":"Infer.Error.RulesNotFound.message/1","type":"function"},{"doc":"Welcome to the documentation of Infer, a rule-based inference engine written in Elixir. If you're new to Infer, we recommend starting with the basics .","ref":"welcome.html","title":"Welcome ðŸ‘‹","type":"extras"},{"doc":"In the following sections, we'll learn... what predicates are, and how to define rules to assign their values how associations are easily traversed when defining rules combining conditions to define more complex rules using references to compare multiple fields or predicates with each other passing in arguments from the outside context in which rules are evaluated Finally, we close with a chapter on Thinking in Infer , learn to apply all the lessons learnt.","ref":"00_intro.html","title":"Introduction","type":"extras"},{"doc":"Infer allows you to add predicates to your schema. Predicates are like virtual fields, but instead of storing values, you define what the value should be, based on conditions. Example: boolean predicate Say we have a ToDo list app with a Todo.List schema type. defmodule Todo.List do use Ecto.Schema use Infer.Ecto.Schema , repo : Todo.Repo schema &quot;lists&quot; do field :archived_at , :utc_datetime end infer archived? : false , when : %{ archived_at : nil } infer archived? : true end Here, we define a predicate archived? on our Todo.List schema. It has the value false when the field archived_at is nil . If this condition doesn't match, Infer will look at the next rule and assign the value true . Since there is no condition for this last rule, it will always match. Tip: It is a good practice to always have a last rule without condition to define a fallback value. Usage This predicate can now be used like a field, as long as you use an Infer to to evaluate it, such as Infer.get!/2 : # loading a predicate iex&gt; % Todo.List { archived_at : nil } ...&gt; |&gt; Infer . get! ( :archived? ) false iex&gt; % Todo.List { archived_at : ~U[2022-02-02 22:22:22Z] } ...&gt; |&gt; Infer . get! ( :archived? ) true Example: multi-value predicate Instead of assigning true or false , we might define a predicate state that can be easily extended later on. We can even use the existing predicate and reference it in our new rule: defmodule Todo.List do use Ecto.Schema use Infer.Ecto.Schema , repo : Todo.Repo schema &quot;lists&quot; do field :archived_at , :utc_datetime end infer archived? : false , when : %{ archived_at : nil } infer archived? : true infer state : :archived , when : %{ archived? : true } infer state : :active end Usage Just as with archived? , we can now use state as if it was a field when using Infer : iex&gt; % Todo.List { archived_at : nil } ...&gt; |&gt; Infer . get! ( :state ) :active iex&gt; % Todo.List { archived_at : ~U[2022-02-02 22:22:22Z] } ...&gt; |&gt; Infer . get! ( :state ) :archived","ref":"01_predicates.html","title":"Predicates","type":"extras"},{"doc":"Infer allows to easily traverse associations to access fields or even predicates defined on associated records. Say our Todo.List schema from the previous guide now has_many tasks: defmodule Todo.List do use Ecto.Schema use Infer.Ecto.Schema , repo : Todo.Repo schema &quot;lists&quot; do field :archived_at , :utc_datetime has_many :tasks , Todo.Task end infer archived? : false , when : %{ archived_at : nil } infer archived? : true infer state : :archived , when : %{ archived? : true } infer state : :active end In return, we add a Task schema that belongs_to a List: defmodule Todo.Task do use Ecto.Schema use Infer.Ecto.Schema , repo : Todo.Repo schema &quot;tasks&quot; do field :completed_at , :utc_datetime belongs_to :list , Todo.List end infer completed? : false , when : %{ completed_at : nil } infer completed? : true end belongs_to Say we want a Task to be archived? when the List it belongs to is archived. We could write a similar rule on the Todo.Task schema as we have on the List: infer archived? : false , when : %{ list : %{ archived_at : nil } } infer archived? : true The archived? predicate looks at the associated list (defined using belongs_to ) and its field archived_at , and compares that to nil . If it's nil then the Task's predicate archived? is false , otherwise it's true . However, since we've already defined this logic on the List, we can also use the predicate on the associated List instead, and change things around a bit: infer archived? : true , when : %{ list : %{ archived? : true } } infer archived? : false Usage Like before, we can use Infer.get!/2 to evaluate the predicate, but only if the association is (pre)loaded: iex&gt; list = % Todo.List { archived_at : ~U[2022-02-02 22:22:22Z] } |&gt; Todo.Repo . insert! ( ) ...&gt; % Todo.Task { completed_at : nil , list : list } ...&gt; |&gt; Infer . get! ( :archived? ) true If the association is not (pre)loaded, Infer.get!/2 will raise an error: iex&gt; list = % Todo.List { archived_at : ~U[2022-02-02 22:22:22Z] } |&gt; Todo.Repo . insert! ( ) ...&gt; % Todo.Task { completed_at : nil , list : list } ...&gt; |&gt; Todo.Repo . insert! ( ) |&gt; Todo.Repo . reload! ( ) # insert and reload without associations ...&gt; |&gt; Infer . load! ( :archived? ) ** (Infer.Error.NotLoaded) Association list is not loaded on nil. Cannot get path: nil To allow Infer to load associations as needed, use Infer.load!/2 instead: iex&gt; list = % Todo.List { archived_at : ~U[2022-02-02 22:22:22Z] } |&gt; Todo.Repo . insert! ( ) ...&gt; % Todo.Task { completed_at : nil , list : list } ...&gt; |&gt; Todo.Repo . insert! ( ) |&gt; Todo.Repo . reload! ( ) # insert and reload without associations ...&gt; |&gt; Infer . load! ( :archived? ) # loads the associated list true has_many We can also define predicates based on a has_many association. Infer generally treats conditions on a list of records like an Enum.any? condition: defmodule Todo.List do # ... infer in_progress? : true , when : %{ tasks : %{ completed? : true } } infer in_progress? : false end The predicate in_progress? is true if there's any Task associated that has completed?: true . Otherwise, if there's no Task associated that has completed?: true , in_progress? is false . Say we want to have a completed? predicate on the List, that's true if all associated tasks are completed. We can use the all? primitive, which shifts the condition from an Enum.any? to an Enum.all? kind of check: defmodule Todo.List do # ... infer completed? : true , when : %{ tasks : { :all , %{ completed? : true } } } infer completed? : false end Putting it all together, we can extend our state predicate on the Todo.List schema: defmodule Todo.List do # ... infer state : :archived , when : %{ archived? : true } infer state : :completed , when : %{ tasks : { :all , %{ completed? : true } } } infer state : :in_progress , when : %{ tasks : %{ completed? : true } } infer state : :ready , when : %{ tasks : %{ } } infer state : :empty end What does the :ready rule do? It checks whether there's any Task, without any condition on the Task. So if the List is not archived, and there are no completed tasks, but there is a Task, :state is :ready . Otherwise :state is :empty . This might be hard to grasp, but it will hopefully become clearer in the next guide...","ref":"02_associations.html","title":"Associations","type":"extras"},{"doc":"When working with Infer, we have to think top-down, as opposed to bottom-up. We always start from the end result, which we want to achieve. Any logic and inputs needed to get to the end result are defined within Infer. Example Say we have a complex requirement to implement: A user can archive a Todo list, but only if they created it, or if they have an &quot;admin&quot; role, and only if all tasks in the list are completed. Let's assume we only have the schema, and no other functions, helpers, or rules defined. defmodule Todo.User do use Ecto.Schema use Infer.Ecto.Schema , repo : Todo.Repo schema &quot;users&quot; do has_many :roles , Todo.UserRole end end defmodule Todo.UserRole do use Ecto.Schema use Infer.Ecto.Schema , repo : Todo.Repo schema &quot;user_roles&quot; do field :name , Ecto.Enum , values : [ :moderator , :admin , :super_admin ] belongs_to :user , Todo.User end end defmodule Todo.List do use Ecto.Schema use Infer.Ecto.Schema , repo : Todo.Repo schema &quot;lists&quot; do field :archived_at , :utc_datetime belongs_to :created_by , Todo.User end end defmodule Todo.Task do use Ecto.Schema use Infer.Ecto.Schema , repo : Todo.Repo schema &quot;tasks&quot; do field :completed_at , :utc_datetime belongs_to :list , Todo.List end end The inputs are the list to be archived and the current_user who tries to archive it. The end result is either the now archived list, or an error. Without Infer, we'd write a function that takes the list and the user who tries to archive it. We'd then have to think about how to load the data needed to compute the result, and implement it. With Infer, we don't have to think about how to load the data or compute the result. Instead, we focus entirely on what is relevant and write the rules to represent this logic. Infer then takes care of loading data as needed, in an efficient way. Thinking in Infer, we usually take the following steps: What are the possible end results that we need to continue in our other code, f.ex. a web request? In our example, the end result can be either &quot;archive the list&quot; or &quot;can't archive list&quot;. In code terms, we could return true or false , or we could return :ok or {:error, reason} . Note: We think of Infer as read-only; we don't perform an action (such as archiving a list), but prepare and compute all the data needed to do it. What is the primary data point, on which to operate on? In our example, it's rather easy: we operate on a list . In other cases, there might be multiple candidates; in these cases, it might help to ask what data type feels most intuitive to return the end results conceived in step 1. Define a predicate on the main data type from step 2 with the possible values from step 1. In the code where the outcome is used, f.ex. a web request, call Infer with the main data point and this predicate. We also add additional data needed as args . In our example: # in Todo.List infer archivable? : :ok infer archivable? : { :error , :unauthorized } infer archivable? : { :error , :pending_tasks } # in the List controller with :ok &lt;- Infer . load! ( list , :archivable? , args : [ current_user : current_user ] ) , { :ok , archived_list } &lt;- List . archive ( list ) do render ( conn , &quot;show.html&quot; , list : archived_list ) end Flesh out the conditions for the various cases. For each condition, think about what's needed and how it could be called. If there's a good answer, use the term in the condition as if it already existed. This way, it's easier to stay on the requirements level, using terms that make sense in the app's domain. In our example, we also reverse the order, checking all error cases first, and returning :ok otherwise: # in Todo.List infer archivable? : { :error , :unauthorized } , when : %{ can_archive? : false } infer archivable? : { :error , :pending_tasks } , when : %{ tasks : %{ completed? : false } } infer archivable? : :ok Define the predicates you used on the correct schema types, and continue the process until the requirements are fully defined using rules. In our example, the final set of rules might look like this: # in Todo.List infer archivable? : { :error , :unauthorized } , when : %{ can_archive? : false } infer archivable? : { :error , :pending_tasks } , when : %{ tasks : %{ completed? : false } } infer archivable? : :ok infer can_archive? : true , when : %{ args : %{ current_user : %{ is_admin? : true } } } infer can_archive? : true , when : %{ is_owner? : true } infer can_archive? : false infer is_owner? : true , when : %{ created_by_id : { :ref , [ :args , :current_user , :id ] } } infer is_owner? : false # in Todo.User infer is_admin? : true , when : %{ roles : %{ name : [ :admin , :super_admin ] } } infer is_admin? : false # in Todo.Task infer completed? : true , when : %{ completed_at : { :not , nil } } infer completed? : false Other use cases covered We could use the rules we defined to cover other use cases as well: Filtering archivable lists Say we have a list of Todo.List structs, and want to keep only the ones that can be archived, for example to implement a web request to archive multiple lists. We use Infer.filter/3 for it, which takes a list of data as well as a condition, just like the ones we use when defining rules: Infer . filter ( lists , %{ archivable? : :ok } , args : [ current_user : current_user ] ) Querying all archivable lists Say we want to query all lists that a given user can archive. We use Infer.query_all/3 for it, which takes a type as well as a condition, just like the ones we use when defining rules: Infer . query_all ( Todo.List , %{ archivable? : :ok } , args : [ current_user : current_user ] )","ref":"06_thinking_in_infer.html","title":"Thinking in Infer","type":"extras"},{"doc":"We've learnt all the basics about using Infer, and even thinking in it. This should be enough to get you started. We're currently writing guides on more advanced topics, so stay tuned! ðŸ™Œ","ref":"99_outro.html","title":"Done ðŸŽ‰","type":"extras"}]