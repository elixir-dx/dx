<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.28.3">
    <meta name="project" content="infer v0.3.0">

    <title>Full Reference â€” infer v0.3.0</title>
    <link rel="stylesheet" href="dist/elixir-d5ff82e6b0f5651c0ac0.css" />

    <script src="dist/sidebar_items-ee4f01c929.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-a088a6cc33ae3464193e.js"></script>


  </head>
  <body data-type="extras">
    <script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script>

<div class="main">


<section class="sidebar">
  <button class="sidebar-button sidebar-toggle" aria-label="toggle sidebar">
    <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
  </button>

  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <i class="ri-search-2-line" aria-hidden="true" title="Submit search"></i>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <i class="ri-close-line ri-lg" aria-hidden="true" title="Cancel search"></i>
    </button>
    <label class="search-label">
      <p class="sr-only">Search</p>
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">

    <div class="sidebar-projectDetails">
      <a href="welcome.html" class="sidebar-projectName" translate="no">
infer
      </a>
      <strong class="sidebar-projectVersion" translate="no">
        v0.3.0
      </strong>
    </div>
    <ul class="sidebar-listNav">
      <li><a id="extras-list-link" href="#full-list">Guides</a></li>

        <li><a id="modules-list-link" href="#full-list">Modules</a></li>


    </ul>
  </div>

  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">

<h1>
<button class="settings display-settings">
  <i class="ri-settings-3-line"></i>
  <span class="sr-only">Settings</span>
</button>


    <a href="https://github.com/infer-beam/infer/blob/v0.3.0/docs/full_reference.md#L1" title="View Source" class="view-source" rel="help">
      <i class="ri-code-s-slash-line" aria-hidden="true"></i>
      <span class="sr-only">View Source</span>
    </a>

  <span>Full Reference</span>
</h1>

<h2 id="augment-ecto-schema" class="section-heading">
  <a href="#augment-ecto-schema" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">augment-ecto-schema</p>
  </a>
  Augment Ecto schema
</h2>
<p><code class="inline">use Infer.Ecto.Schema</code> enables a module to specify inferences, such as</p><pre><code class="makeup elixir" translate="no"><span class="kn">use</span><span class="w"> </span><span class="nc">Infer.Ecto.Schema</span><span class="w">

</span><span class="n">infer</span><span class="w"> </span><span class="ss">has_children?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p">,</span><span class="w"> </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3591380330-1">%{</span><span class="ss">relatives</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3591380330-2">%{</span><span class="ss">relation</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;parent_of&quot;</span><span class="p" data-group-id="3591380330-2">}</span><span class="p" data-group-id="3591380330-1">}</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">has_children?</span><span class="p">:</span><span class="w"> </span><span class="no">false</span></code></pre><p>Unlike full-fledged inference engines (such as <a href="https://github.com/liveforeverx/calypte">calypte</a>
or <a href="https://github.com/lorenzosinisi/retex">retex</a>), all rules in Infer are bound to an individual
record type as their subject. This, in turn, allows to utilize Ecto schemas and queries to their full extent.</p><h2 id="terminology" class="section-heading">
  <a href="#terminology" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">terminology</p>
  </a>
  Terminology
</h2>
<ul><li><code class="inline">infer ...</code> defines a <strong>rule</strong> in a module. It applies to an instance of that module:
A struct, Ecto record, Ash resource, ...</li><li>This instance of a module, on which rules are evaluated, is the <strong>subject</strong>.</li><li>A rule can have a <strong>condition</strong>, or <code class="inline">:when</code> part, that must be met in order for it to apply,
e.g. <code class="inline">%{relatives: %{relation: &quot;parent_of&quot;}}</code>.</li><li>When the condition is met, a given <strong>predicate</strong> is assigned a given <strong>value</strong>,
e.g. <code class="inline">has_children?: true</code>. This is also called the <strong>result</strong> of the rule.</li><li>All rules are evaluated from top to bottom until the first one for each predicate matches,
similar to a <code class="inline">cond</code> statement.</li><li>A condition can make use of other predicates as well as <strong>fields</strong> defined on the schema or
struct of the underlying type.</li><li>An executed rule results in a (derived) <strong>fact</strong>: subject, predicate, value.</li></ul><h2 id="api-overview" class="section-heading">
  <a href="#api-overview" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">api-overview</p>
  </a>
  API overview
</h2>
<ul><li><a href="Infer.html#get/3"><code class="inline">Infer.get/3</code></a> evaluates the given predicate(s) using only the (pre)loaded data available, and returns the result(s)</li><li><a href="Infer.html#load/3"><code class="inline">Infer.load/3</code></a> is like <code class="inline">get</code>, but loads any additional data as needed</li><li><a href="Infer.html#put/3"><code class="inline">Infer.put/3</code></a> is like <code class="inline">load</code>, but puts the results into the <code class="inline">:inferred</code> field
(or virtual schema field) of the subject(s) as a map, and returns the subject(s)</li></ul><p>These functions return a tuple, either <code class="inline">{:ok, result}</code>, <code class="inline">{:error, error}</code>, or <code class="inline">{:not_loaded, data_reqs}</code> (only <code class="inline">get</code>).</p><p>The corresponding <a href="Infer.html#get!/3"><code class="inline">Infer.get!/3</code></a>, <a href="Infer.html#load!/3"><code class="inline">Infer.load!/3</code></a> and <a href="Infer.html#put!/3"><code class="inline">Infer.put!/3</code></a> functions return <code class="inline">result</code>
directly, or otherwise raise an exception.</p><p>Arguments:</p><ul><li><strong>subjects</strong> can either be an individual subject (with the given predicates defined on it), or a list of subjects.
Passing an individual subject will return the predicates for the subject, passing a list will return a list of them.</li><li><strong>predicates</strong> can either be a single predicate, or a list of predicates.
Passing a single predicate will return the resulting value, passing a list will return a <strong>map</strong>
of the predicates and their resulting values.</li><li><strong>options</strong> (optional) See below.</li></ul><p>Options:</p><ul><li><strong>args</strong> (list or map) can be used to pass in data from the caller's context that can be used in
rules (see <em>Arguments</em> below). A classic example is the <code class="inline">current_user</code>, e.g.<pre><code class="makeup elixir" translate="no"><span class="w">  </span><span class="nc">Infer</span><span class="o">.</span><span class="n">put!</span><span class="p" data-group-id="1355778710-1">(</span><span class="n">project</span><span class="p">,</span><span class="w"> </span><span class="ss">:can_edit?</span><span class="p">,</span><span class="w"> </span><span class="ss">args</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1355778710-2">[</span><span class="ss">user</span><span class="p">:</span><span class="w"> </span><span class="n">current_user</span><span class="p" data-group-id="1355778710-2">]</span><span class="p" data-group-id="1355778710-1">)</span></code></pre></li><li><strong>extra_rules</strong> (module or list of modules) can be used to add context-specific rules that are
not defined directly on the subject. This can be used to structure rules into their own modules
and use them only where needed.</li><li><strong>debug?</strong> (boolean) makes Infer print additional information to the console as rules are evaluated.
Should only be used while debugging.</li></ul><h2 id="conditions" class="section-heading">
  <a href="#conditions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">conditions</p>
  </a>
  Conditions
</h2>
<p>In a rule condition, the part after <code class="inline">when: ...</code>,</p><ul><li><strong>Maps</strong> represent multiple conditions, of which <strong>all</strong> need to be satisfied (logical <code class="inline">AND</code>).</li><li><strong>Lists</strong> represent multiple conditions, of which <strong>at least one</strong> needs to be satisfied (logical <code class="inline">OR</code>).</li><li>Values can be negated using <code class="inline">{:not, &quot;value&quot;}</code>.</li></ul><p>Examples:</p><pre><code class="makeup elixir" translate="no"><span class="c1"># :role must be &quot;admin&quot;</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">role</span><span class="p">:</span><span class="w"> </span><span class="ss">:admin</span><span class="p">,</span><span class="w"> </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3236531506-1">%{</span><span class="ss">role</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;admin&quot;</span><span class="p" data-group-id="3236531506-1">}</span><span class="w">

</span><span class="c1"># :role must be either &quot;admin&quot; or &quot;superadmin&quot;</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">role</span><span class="p">:</span><span class="w"> </span><span class="ss">:admin</span><span class="p">,</span><span class="w"> </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3236531506-2">%{</span><span class="ss">role</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3236531506-3">[</span><span class="s">&quot;admin&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;superadmin&quot;</span><span class="p" data-group-id="3236531506-3">]</span><span class="p" data-group-id="3236531506-2">}</span><span class="w">

</span><span class="c1"># :role must be &quot;admin&quot; and :verified? must be true</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">role</span><span class="p">:</span><span class="w"> </span><span class="ss">:admin</span><span class="p">,</span><span class="w"> </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3236531506-4">%{</span><span class="ss">role</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;admin&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">verified?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="3236531506-4">}</span><span class="w">

</span><span class="c1"># :role must be &quot;admin&quot; and :verified_at must not be nil</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">role</span><span class="p">:</span><span class="w"> </span><span class="ss">:admin</span><span class="p">,</span><span class="w"> </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3236531506-5">%{</span><span class="ss">role</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;admin&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">verified_at</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3236531506-6">{</span><span class="ss">:not</span><span class="p">,</span><span class="w"> </span><span class="no">nil</span><span class="p" data-group-id="3236531506-6">}</span><span class="p" data-group-id="3236531506-5">}</span></code></pre><h3 id="boolean-shorthand-form" class="section-heading">
  <a href="#boolean-shorthand-form" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">boolean-shorthand-form</p>
  </a>
  Boolean shorthand form
</h3>
<p>A single atom is a shorthand for <code class="inline">%{atom: true}</code>.</p><h3 id="conditions-on-list-data" class="section-heading">
  <a href="#conditions-on-list-data" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">conditions-on-list-data</p>
  </a>
  Conditions on list data
</h3>
<p>When conditions are tested against list data, e.g. a person's list of roles, the condition is satisfied
if at least one element of the list matches the given conditions (like <a href="https://hexdocs.pm/elixir/Enum.html#any?/2"><code class="inline">Enum.any?/2</code></a>).</p><p>Although they might look similar, it's important to differentiate between lists that appear in
conditions, and lists that appear in the data, which are checked against a condition.</p><p>When both occur together, i.e. a list in a condition is checked against a list of values, the condition
is met if at least one of the condition list elements applies to at least one element of the value list.</p><p>For example:</p><pre><code class="makeup elixir" translate="no"><span class="n">infer</span><span class="w"> </span><span class="ss">:can_edit?</span><span class="p">,</span><span class="w"> </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8809203835-1">%{</span><span class="ss">roles</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8809203835-2">[</span><span class="s">&quot;project_manager&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;admin&quot;</span><span class="p" data-group-id="8809203835-2">]</span><span class="p" data-group-id="8809203835-1">}</span><span class="w">

</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="8809203835-3">%</span><span class="nc" data-group-id="8809203835-3">Person</span><span class="p" data-group-id="8809203835-3">{</span><span class="ss">roles</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8809203835-4">[</span><span class="s">&quot;worker&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;assistant&quot;</span><span class="p" data-group-id="8809203835-4">]</span><span class="p" data-group-id="8809203835-3">}</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Infer</span><span class="o">.</span><span class="n">get!</span><span class="p" data-group-id="8809203835-5">(</span><span class="ss">:can_edit?</span><span class="p" data-group-id="8809203835-5">)</span><span class="w">
</span><span class="no">nil</span><span class="w">

</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="8809203835-6">%</span><span class="nc" data-group-id="8809203835-6">Person</span><span class="p" data-group-id="8809203835-6">{</span><span class="ss">roles</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8809203835-7">[</span><span class="s">&quot;assistant&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;project_manager&quot;</span><span class="p" data-group-id="8809203835-7">]</span><span class="p" data-group-id="8809203835-6">}</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Infer</span><span class="o">.</span><span class="n">get!</span><span class="p" data-group-id="8809203835-8">(</span><span class="ss">:can_edit?</span><span class="p" data-group-id="8809203835-8">)</span><span class="w">
</span><span class="no">true</span><span class="w">

</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="8809203835-9">%</span><span class="nc" data-group-id="8809203835-9">Person</span><span class="p" data-group-id="8809203835-9">{</span><span class="ss">roles</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8809203835-10">[</span><span class="s">&quot;admin&quot;</span><span class="p" data-group-id="8809203835-10">]</span><span class="p" data-group-id="8809203835-9">}</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Infer</span><span class="o">.</span><span class="n">get!</span><span class="p" data-group-id="8809203835-11">(</span><span class="ss">:can_edit?</span><span class="p" data-group-id="8809203835-11">)</span><span class="w">
</span><span class="no">true</span></code></pre><p>The same applies to complex conditions.</p><h2 id="rule-results" class="section-heading">
  <a href="#rule-results" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">rule-results</p>
  </a>
  Rule results
</h2>
<p>The assigned value of a predicate is generally assigned as is.</p><p>A few special tuples, however, will be replaced by Infer (see <em>Features</em> below)</p><p>Example:</p><pre><code class="makeup elixir" translate="no"><span class="n">infer</span><span class="w"> </span><span class="ss">d</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">nested</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0455976185-1">%{</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="ss">c</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0455976185-2">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="ss">:d</span><span class="p" data-group-id="0455976185-2">}</span><span class="p" data-group-id="0455976185-1">}</span><span class="w">  </span><span class="c1"># =&gt; %{a: 1, b: 2, c: 4}</span></code></pre><h2 id="references" class="section-heading">
  <a href="#references" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">references</p>
  </a>
  References
</h2>
<p>Syntax:</p><ul><li><code class="inline">{:ref, path}</code> (in conditions and result values)</li></ul><p>Arguments:</p><ul><li><strong>path</strong> is a list of fields or predicates, starting from the subject.
The brackets can be omitted (i.a. an atom passed), if the path consists of one element.
The last element can be a map or list (see <em>Branching</em> below)</li></ul><p>Example:</p><pre><code class="makeup elixir" translate="no"><span class="n">infer</span><span class="w"> </span><span class="ss">ot_fields</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4360327234-1">%{</span><span class="ss">editable</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="4360327234-1">}</span><span class="p">,</span><span class="w">
    </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4360327234-2">%{</span><span class="w">
      </span><span class="ss">construction_bectu?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p">,</span><span class="w">
      </span><span class="ss">roles</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4360327234-3">%{</span><span class="w">
        </span><span class="ss">user</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4360327234-4">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4360327234-5">[</span><span class="ss">:args</span><span class="p">,</span><span class="w"> </span><span class="ss">:user</span><span class="p" data-group-id="4360327234-5">]</span><span class="p" data-group-id="4360327234-4">}</span><span class="p">,</span><span class="w">
        </span><span class="ss">type</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4360327234-6">[</span><span class="s">&quot;project_manager&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;admin&quot;</span><span class="p" data-group-id="4360327234-6">]</span><span class="w">
      </span><span class="p" data-group-id="4360327234-3">}</span><span class="w">
    </span><span class="p" data-group-id="4360327234-2">}</span></code></pre><h3 id="branching" class="section-heading">
  <a href="#branching" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">branching</p>
  </a>
  Branching
</h3>
<p>Any part of the <code class="inline">path</code> that represents an underlying <strong>list of subjects</strong>, such as referencing
a <code class="inline">has_many</code> association, will cause the result of the <code class="inline">:ref</code> to be a list as well.
It basically behaves similar to <a href="https://hexdocs.pm/elixir/Enum.html#map/2"><code class="inline">Enum.map/2</code></a>.</p><p>A <strong>map</strong> as last element of a <code class="inline">path</code> will branch the returned result out into this map.
The keys are returned as is, the values must be a list (or atom) continuing that path.
This is particularly powerful when used on a list of subjects (see above), because it
will return the given map with the values at the given paths for each underlying subject:</p><p>A <strong>list</strong> as last element of a <code class="inline">path</code> behaves like a map where each value equals its key.</p><p>Examples:</p><pre><code class="makeup elixir" translate="no"><span class="n">infer</span><span class="w"> </span><span class="ss">list</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4952778256-1">[</span><span class="p" data-group-id="4952778256-2">%{</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="ss">c</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4952778256-3">%{</span><span class="ss">d</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="p" data-group-id="4952778256-3">}</span><span class="p" data-group-id="4952778256-2">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4952778256-4">%{</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="ss">c</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4952778256-5">%{</span><span class="ss">d</span><span class="p">:</span><span class="w"> </span><span class="mi">6</span><span class="p" data-group-id="4952778256-5">}</span><span class="p" data-group-id="4952778256-4">}</span><span class="p" data-group-id="4952778256-1">]</span><span class="w">

</span><span class="n">infer</span><span class="w"> </span><span class="ss">result1</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4952778256-6">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4952778256-7">[</span><span class="ss">:list</span><span class="p">,</span><span class="w"> </span><span class="ss">:a</span><span class="p" data-group-id="4952778256-7">]</span><span class="p" data-group-id="4952778256-6">}</span><span class="w">  </span><span class="c1"># =&gt; [1, 9]</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">result2</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4952778256-8">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4952778256-9">[</span><span class="ss">:list</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4952778256-10">%{</span><span class="ss">x</span><span class="p">:</span><span class="w"> </span><span class="ss">:a</span><span class="p">,</span><span class="w"> </span><span class="ss">y</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4952778256-11">[</span><span class="ss">:c</span><span class="p">,</span><span class="w"> </span><span class="ss">:d</span><span class="p" data-group-id="4952778256-11">]</span><span class="p" data-group-id="4952778256-10">}</span><span class="p" data-group-id="4952778256-9">]</span><span class="p" data-group-id="4952778256-8">}</span><span class="w">  </span><span class="c1"># =&gt; [%{x: 1, y: 4}, %{x: 9, y: 6}]</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">result3</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4952778256-12">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4952778256-13">[</span><span class="ss">:list</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4952778256-14">[</span><span class="ss">:a</span><span class="p">,</span><span class="w"> </span><span class="ss">:b</span><span class="p" data-group-id="4952778256-14">]</span><span class="p" data-group-id="4952778256-13">]</span><span class="p" data-group-id="4952778256-12">}</span><span class="w">  </span><span class="c1"># =&gt; [%{a: 1, b: 2}, %{a: 9, b: 8}]</span></code></pre><h2 id="arguments" class="section-heading">
  <a href="#arguments" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">arguments</p>
  </a>
  Arguments
</h2>
<p>Passing <code class="inline">:args</code> as an option to any of the Infer API functions enables referencing the passed data
in conditions and values using <code class="inline">{:ref, [:args, ...]}</code>.</p><h2 id="overriding-existing-fields" class="section-heading">
  <a href="#overriding-existing-fields" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">overriding-existing-fields</p>
  </a>
  Overriding existing fields
</h2>
<p>It's possible to give predicates the same name as existing fields in the schema.
This represents the fact that these fields are derived from other data, using rules.</p><p>Rules on these fields can even take into account the existing value of the underlying field.
In order to reference it, use <code class="inline">:fields</code> in between a path or condition, for example:</p><pre><code class="makeup elixir" translate="no"><span class="n">schema</span><span class="w"> </span><span class="s">&quot;blog_posts&quot;</span><span class="w"> </span><span class="k" data-group-id="8252837852-1">do</span><span class="w">
  </span><span class="n">field</span><span class="w"> </span><span class="ss">:state</span><span class="w">
  </span><span class="n">field</span><span class="w"> </span><span class="ss">:published_at</span><span class="w">
</span><span class="k" data-group-id="8252837852-1">end</span><span class="w">

</span><span class="c1"># nilify published_at when deleted, or when it&#39;s an old archived post</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">published_at</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="p">,</span><span class="w"> </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8252837852-2">%{</span><span class="ss">state</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;deleted&quot;</span><span class="p" data-group-id="8252837852-2">}</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">published_at</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="p">,</span><span class="w"> </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8252837852-3">%{</span><span class="ss">state</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;archived&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">fields</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8252837852-4">%{</span><span class="ss">published_at</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8252837852-5">{</span><span class="ss">:before</span><span class="p">,</span><span class="w"> </span><span class="ld">~D[2020-02-20]</span><span class="p" data-group-id="8252837852-5">}</span><span class="p" data-group-id="8252837852-4">}</span><span class="p" data-group-id="8252837852-3">}</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">published_at</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8252837852-6">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8252837852-7">[</span><span class="ss">:fields</span><span class="p">,</span><span class="w"> </span><span class="ss">:published_at</span><span class="p" data-group-id="8252837852-7">]</span><span class="p" data-group-id="8252837852-6">}</span></code></pre><p>While it's always possible to achieve a similar behavior by giving the predicate a different
name than the field, and then mapping the predicate to the field somewhere else,
using the field name in conjunction with <code class="inline">:fields</code> makes explicit that it's a conditional override.</p><h2 id="binding-subject-parts" class="section-heading">
  <a href="#binding-subject-parts" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">binding-subject-parts</p>
  </a>
  Binding subject parts
</h2>
<p>Syntax:</p><ul><li><code class="inline">{:bind, key}</code> (in conditions)</li><li><code class="inline">{:bind, key, subcondition}</code> (in conditions)</li><li><code class="inline">{:bound, key}</code> (in result values)</li><li><code class="inline">{:bound, key, default}</code> (in result values)</li></ul><p>When a condition is evaluated on a list of values, the <strong>first value</strong> satisfying
the condition can be bound to a variable using <code class="inline">{:bind, variable}</code>.</p><p>These bound values can be referenced using <code class="inline">{:bound, key}</code> with an optional default:
<code class="inline">{:bound, key, default}</code>.</p><pre><code class="makeup elixir" translate="no"><span class="n">infer</span><span class="w"> </span><span class="ss">project_manager</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="5508952999-1">{</span><span class="ss">:bound</span><span class="p">,</span><span class="w"> </span><span class="ss">:person</span><span class="p" data-group-id="5508952999-1">}</span><span class="p">,</span><span class="w">
    </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="5508952999-2">%{</span><span class="ss">roles</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="5508952999-3">%{</span><span class="ss">type</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;project_manager&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">person</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="5508952999-4">{</span><span class="ss">:bind</span><span class="p">,</span><span class="w"> </span><span class="ss">:person</span><span class="p" data-group-id="5508952999-4">}</span><span class="p" data-group-id="5508952999-3">}</span><span class="p" data-group-id="5508952999-2">}</span></code></pre><h2 id="local-aliases" class="section-heading">
  <a href="#local-aliases" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">local-aliases</p>
  </a>
  Local aliases
</h2>
<p>Syntax:</p><ul><li><code class="inline">infer_alias key: ...</code> (in modules before using <code class="inline">key</code> in <code class="inline">infer ...</code>)</li></ul><p>In order to create shorthands and avoid repetition, aliases can be defined.
These apply only to subsequent rules within the same module and are not exposed in any other way.</p><pre><code class="makeup elixir" translate="no"><span class="n">infer_alias</span><span class="w"> </span><span class="ss">pm?</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="5966131075-1">%{</span><span class="ss">roles</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="5966131075-2">%{</span><span class="ss">type</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="5966131075-3">[</span><span class="s">&quot;project_manager&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">admin</span><span class="p" data-group-id="5966131075-3">]</span><span class="p" data-group-id="5966131075-2">}</span><span class="p" data-group-id="5966131075-1">}</span><span class="w">

</span><span class="n">infer</span><span class="w"> </span><span class="ss">ot_fields</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="5966131075-4">%{</span><span class="ss">editable</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="5966131075-4">}</span><span class="p">,</span><span class="w"> </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="5966131075-5">[</span><span class="ss">:pm?</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5966131075-6">%{</span><span class="ss">construction_bectu?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="5966131075-6">}</span><span class="p" data-group-id="5966131075-5">]</span></code></pre><h2 id="calling-functions" class="section-heading">
  <a href="#calling-functions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">calling-functions</p>
  </a>
  Calling functions
</h2>
<p>Syntax:</p><ul><li><code class="inline">{&amp;module.fun/n, [arg_1, ..., arg_n]}</code> (in result values)</li><li><code class="inline">{&amp;module.fun/1, arg_1}</code> (in result values)</li></ul><p>Any function can be called to map the given arguments to other values.
The function arguments must be passed as a list, except if it's only one.
Arguments can be fixed values or other Infer features (passed as is), such as references.</p><pre><code class="makeup elixir" translate="no"><span class="n">infer</span><span class="w"> </span><span class="ss">day_of_week</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3692231168-1">{</span><span class="o">&amp;</span><span class="nc">Date</span><span class="o">.</span><span class="n">day_of_week</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3692231168-2">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="ss">:date</span><span class="p" data-group-id="3692231168-2">}</span><span class="p" data-group-id="3692231168-1">}</span><span class="w">

</span><span class="n">infer</span><span class="w"> </span><span class="ss">duration</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3692231168-3">{</span><span class="o">&amp;</span><span class="nc">Timex</span><span class="o">.</span><span class="n">diff</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3692231168-4">[</span><span class="p" data-group-id="3692231168-5">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="ss">:start_datetime</span><span class="p" data-group-id="3692231168-5">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3692231168-6">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="ss">:end_datetime</span><span class="p" data-group-id="3692231168-6">}</span><span class="p">,</span><span class="w"> </span><span class="ss">:hours</span><span class="p" data-group-id="3692231168-4">]</span><span class="p" data-group-id="3692231168-3">}</span></code></pre><p>Only pure functions with low overhead should be used.
Infer might call them very often during evaluation (once after each loading of data).</p><h2 id="querying" class="section-heading">
  <a href="#querying" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">querying</p>
  </a>
  Querying
</h2>
<p>Syntax:</p><ul><li><code class="inline">{:query_one, type, conditions}</code></li><li><code class="inline">{:query_one, type, conditions, options}</code></li><li><code class="inline">{:query_first, type, conditions}</code></li><li><code class="inline">{:query_first, type, conditions, options}</code></li><li><code class="inline">{:query_all, type, conditions}</code></li><li><code class="inline">{:query_all, type, conditions, options}</code></li></ul><p>Arguments:</p><ul><li><code class="inline">type</code> is a module name (or Ecto queryable), e.g. an Ecto schema</li><li><code class="inline">conditions</code> is a <strong>keyword list</strong> of fields and their respective values, or lists of values, they must match</li><li><code class="inline">options</code> is a subset of the options that Ecto queries support:<ul><li><code class="inline">order_by</code></li><li><code class="inline">limit</code></li></ul></li></ul><h3 id="conditions-1" class="section-heading">
  <a href="#conditions-1" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">conditions-1</p>
  </a>
  Conditions
</h3>
<p>The first key-value pair has a special behavior:
It is used as the main condition for <a href="https://hexdocs.pm/dataloader/1.0.9/Dataloader.html"><code class="inline">Dataloader</code></a>, and thus should have the highest cardinality.
It must be a single value, not a list of values.</p><p><em>Rule of thumb:</em> Put a single field that has the most unique values as first condition.</p><h2 id="transforming-lists" class="section-heading">
  <a href="#transforming-lists" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">transforming-lists</p>
  </a>
  Transforming lists
</h2>
<p>Syntax:</p><ul><li><code class="inline">{:filter, source, condition}</code> (in result values)</li><li><code class="inline">{:map, source, mapper}</code> (in result values)</li><li><code class="inline">{:map, source, bind_key/condition, mapper}</code> (in result values)</li></ul><p>Arguments:</p><ul><li><code class="inline">source</code> can either be a list literal, a field or predicate that evaluates to a list,
or another feature such as a query.</li><li><code class="inline">condition</code> has the same form and functionality as any other rule condition.</li><li><code class="inline">mapper</code> can either be a field or predicate (atom), or is otherwise treated as any other rule value.</li></ul><p>There are 3 variants:</p><ul><li><code class="inline">{:filter, source, condition}</code> keeps only elements from <code class="inline">source</code>, for which the <code class="inline">condition</code> is met.</li><li><code class="inline">{:map, source, mapper}</code> returns the result of <code class="inline">mapper</code> for each element in <code class="inline">source</code>.</li><li><code class="inline">{:map, source, bind_key/condition, mapper}</code> is a special form of <code class="inline">:map</code>, where the <code class="inline">mapper</code> is based on the
subject of the rule, not the list element. The list element is referenced using the middle arg, which can be either:<ul><li>a <code class="inline">bind_key</code> (atom) - the current list element is referenced via <code class="inline">{:bound, bind_key}</code> in the <code class="inline">mapper</code></li><li>a <code class="inline">condition</code> - any values bound in the condition via <code class="inline">{:bind, key, ...}</code> can be accessed
via <code class="inline">{:bound, key}</code> in the <code class="inline">mapper</code></li></ul></li></ul><p>Use the special form of <code class="inline">:map</code> only when you need to reference both the list element (via <code class="inline">:bound</code>),
and the subject of the rule (via <code class="inline">:ref</code>).
Using a combination of <code class="inline">:filter</code> and basic <code class="inline">:map</code> instead is always preferred, if possible.</p><p>Any <code class="inline">nil</code> elements in the list are mapped to <code class="inline">nil</code>, when using <code class="inline">:map</code> without condition.</p><p>Examples:</p><pre><code class="makeup elixir" translate="no"><span class="n">infer</span><span class="w"> </span><span class="ss">accepted_offers</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9818126009-1">{</span><span class="ss">:filter</span><span class="p">,</span><span class="w"> </span><span class="ss">:offers</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9818126009-2">%{</span><span class="ss">state</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;accepted&quot;</span><span class="p" data-group-id="9818126009-2">}</span><span class="p" data-group-id="9818126009-1">}</span><span class="w">

</span><span class="n">infer</span><span class="w"> </span><span class="ss">offer_ids</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9818126009-3">{</span><span class="ss">:map</span><span class="p">,</span><span class="w"> </span><span class="ss">:offers</span><span class="p">,</span><span class="w"> </span><span class="ss">:id</span><span class="p" data-group-id="9818126009-3">}</span><span class="w">

</span><span class="n">infer</span><span class="w"> </span><span class="ss">first_offer_of_same_user</span><span class="p">:</span><span class="w">
        </span><span class="p" data-group-id="9818126009-4">{</span><span class="ss">:map</span><span class="p">,</span><span class="w"> </span><span class="ss">:offers</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9818126009-5">%{</span><span class="ss">state</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;accepted&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">user_id</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9818126009-6">{</span><span class="ss">:bind</span><span class="p">,</span><span class="w"> </span><span class="ss">:uid</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9818126009-7">{</span><span class="ss">:not</span><span class="p">,</span><span class="w"> </span><span class="no">nil</span><span class="p" data-group-id="9818126009-7">}</span><span class="p" data-group-id="9818126009-6">}</span><span class="p" data-group-id="9818126009-5">}</span><span class="p">,</span><span class="w">
         </span><span class="p" data-group-id="9818126009-8">{</span><span class="ss">:query_first</span><span class="p">,</span><span class="w"> </span><span class="nc">Offer</span><span class="p">,</span><span class="w"> </span><span class="ss">user_id</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9818126009-9">{</span><span class="ss">:bound</span><span class="p">,</span><span class="w"> </span><span class="ss">:uid</span><span class="p" data-group-id="9818126009-9">}</span><span class="p">,</span><span class="w"> </span><span class="ss">project_id</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9818126009-10">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="ss">:project_id</span><span class="p" data-group-id="9818126009-10">}</span><span class="p" data-group-id="9818126009-8">}</span><span class="p" data-group-id="9818126009-4">}</span></code></pre><h2 id="counting" class="section-heading">
  <a href="#counting" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">counting</p>
  </a>
  Counting
</h2>
<p>Syntax:</p><ul><li><code class="inline">{:count, source, condition/predicate}</code> (in result values)</li><li><code class="inline">{:count_while, source, condition/predicate}</code> (in result values)</li></ul><p>Arguments:</p><ul><li><code class="inline">source</code> can either be a list literal, a field or predicate that evaluates to a list,
or another feature such as a query.</li><li><code class="inline">condition</code> has the same form and functionality as any other rule condition.</li><li><code class="inline">predicate</code> can either be a predicate (atom) that returns either <code class="inline">true</code>, <code class="inline">false</code>,
or <code class="inline">:skip</code> (only for <code class="inline">:count_while</code>)</li></ul><p>Takes the given list and counts the elements that evaluate to <code class="inline">true</code>.
<code class="inline">:count_while</code> stops after the first element that returns <code class="inline">false</code>.
To not count an element, but not stop counting either, the given predicate may return <code class="inline">:skip</code>.
Any <code class="inline">nil</code> elements in the list are treated as <code class="inline">false</code>.</p>
<div class="bottom-actions">
  <div class="bottom-actions-item">

  </div>
  <div class="bottom-actions-item">

      <a href="welcome.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page â†’
        </span>
        <span class="title">
Welcome ðŸ‘‹
        </span>
      </a>

  </div>
</div>

      <footer class="footer">

          <p>
            On Hex.pm:

            <span class="line">
              <a href="https://hex.pm/packages/infer/0.3.0" class="line footer-hex-package">Package</a>
              <a href="https://preview.hex.pm/preview/infer/0.3.0" class="line">Preview</a>

                <a href="https://preview.hex.pm/preview/infer/0.3.0/show/docs/full_reference.md">(current file)</a>

            </span>

            <button class="line footer-button display-quick-switch">
              Search
            </button>
          </p>

        <p>
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.28.3) for the
          <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
