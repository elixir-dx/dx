<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.34.2">
    <meta name="project" content="dx main">


    <title>Full Reference — dx main</title>
    <link rel="stylesheet" href="dist/html-elixir-F2VRIOKR.css" />


    <script src="dist/handlebars.runtime-NWIB6V2M.js"></script>
    <script src="dist/handlebars.templates-K7URE6B4.js"></script>
    <script src="dist/sidebar_items-93957DE4.js"></script>
    <script src="docs_config.js"></script>
    <script async src="dist/html-YIPIRHGU.js"></script>

  </head>
  <body data-type="extras" class="page-extra">
    <script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

      <div>
        <a href="Dx.html" class="sidebar-projectName" translate="no">
dx
        </a>
        <div class="sidebar-projectVersion" translate="no">
          main
        </div>
      </div>
    </div>
    <ul id="sidebar-listNav" class="sidebar-listNav" role="tablist">
      <li>
        <button id="extras-list-tab-button" role="tab" data-type="extras" aria-controls="extras-tab-panel" aria-selected="true" tabindex="0">
Guides (old)
        </button>
      </li>

        <li>
          <button id="modules-list-tab-button" role="tab" data-type="modules" aria-controls="modules-tab-panel" aria-selected="false" tabindex="-1">
            Modules
          </button>
        </li>


    </ul>
  </div>

  <div id="extras-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="extras-list-tab-button">
    <ul id="extras-full-list" class="full-list"></ul>
  </div>

    <div id="modules-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="modules-list-tab-button" hidden>
      <ul id="modules-full-list" class="full-list"></ul>
    </div>


</nav>

<main class="content">
  <output role="status" id="toast"></output>

  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of dx</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search">
            <i class="ri-search-2-line ri-lg" aria-hidden="true" title="Submit search"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <h1>

      <a href="https://github.com/elixir-dx/dx/blob/a8757c094f0503b5ae8ecbb5ee558c81256cd343/docs/full_reference.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>


    <span>Full Reference</span>
  </h1>

<h2 id="augment-ecto-schema" class="section-heading">
  <a href="#augment-ecto-schema" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Augment Ecto schema</span>
</h2>
<p><code class="inline">use Dx.Ecto.Schema</code> enables a module to specify inferences, such as</p><pre><code class="makeup elixir" translate="no"><span class="kn">use</span><span class="w"> </span><span class="nc">Dx.Ecto.Schema</span><span class="w">

</span><span class="n">infer</span><span class="w"> </span><span class="ss">has_children?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p">,</span><span class="w"> </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2094143971-1">%{</span><span class="ss">relatives</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2094143971-2">%{</span><span class="ss">relation</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;parent_of&quot;</span><span class="p" data-group-id="2094143971-2">}</span><span class="p" data-group-id="2094143971-1">}</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">has_children?</span><span class="p">:</span><span class="w"> </span><span class="no">false</span></code></pre><p>Unlike full-fledged inference engines (such as <a href="https://github.com/liveforeverx/calypte">calypte</a>
or <a href="https://github.com/lorenzosinisi/retex">retex</a>), all rules in Dx are bound to an individual
record type as their subject. This, in turn, allows to utilize Ecto schemas and queries to their full extent.</p><h2 id="terminology" class="section-heading">
  <a href="#terminology" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Terminology</span>
</h2>
<ul><li><code class="inline">infer ...</code> defines a <strong>rule</strong> in a module. It applies to an instance of that module:
A struct, Ecto record, Ash resource, ...</li><li>This instance of a module, on which rules are evaluated, is the <strong>subject</strong>.</li><li>A rule can have a <strong>condition</strong>, or <code class="inline">:when</code> part, that must be met in order for it to apply,
e.g. <code class="inline">%{relatives: %{relation: &quot;parent_of&quot;}}</code>.</li><li>When the condition is met, a given <strong>predicate</strong> is assigned a given <strong>value</strong>,
e.g. <code class="inline">has_children?: true</code>. This is also called the <strong>result</strong> of the rule.</li><li>All rules are evaluated from top to bottom until the first one for each predicate matches,
similar to a <code class="inline">cond</code> statement.</li><li>A condition can make use of other predicates as well as <strong>fields</strong> defined on the schema or
struct of the underlying type.</li><li>An executed rule results in a (derived) <strong>fact</strong>: subject, predicate, value.</li></ul><h2 id="api-overview" class="section-heading">
  <a href="#api-overview" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">API overview</span>
</h2>
<ul><li><a href="Dx.html#get/3"><code class="inline">Dx.get/3</code></a> evaluates the given predicate(s) using only the (pre)loaded data available, and returns the result(s)</li><li><a href="Dx.html#load/3"><code class="inline">Dx.load/3</code></a> is like <code class="inline">get</code>, but loads any additional data as needed</li><li><a href="Dx.html#put/3"><code class="inline">Dx.put/3</code></a> is like <code class="inline">load</code>, but puts the results into the <code class="inline">:inferred</code> field
(or virtual schema field) of the subject(s) as a map, and returns the subject(s)</li></ul><p>These functions return a tuple, either <code class="inline">{:ok, result}</code>, <code class="inline">{:error, error}</code>, or <code class="inline">{:not_loaded, data_reqs}</code> (only <code class="inline">get</code>).</p><p>The corresponding <a href="Dx.html#get!/3"><code class="inline">Dx.get!/3</code></a>, <a href="Dx.html#load!/3"><code class="inline">Dx.load!/3</code></a> and <a href="Dx.html#put!/3"><code class="inline">Dx.put!/3</code></a> functions return <code class="inline">result</code>
directly, or otherwise raise an exception.</p><p>Arguments:</p><ul><li><strong>subjects</strong> can either be an individual subject (with the given predicates defined on it), or a list of subjects.
Passing an individual subject will return the predicates for the subject, passing a list will return a list of them.</li><li><strong>predicates</strong> can either be a single predicate, or a list of predicates.
Passing a single predicate will return the resulting value, passing a list will return a <strong>map</strong>
of the predicates and their resulting values.</li><li><strong>options</strong> (optional) See below.</li></ul><p>Options:</p><ul><li><strong>args</strong> (list or map) can be used to pass in data from the caller's context that can be used in
rules (see <em>Arguments</em> below). A classic example is the <code class="inline">current_user</code>, e.g.<pre><code class="makeup elixir" translate="no"><span class="nc">Dx</span><span class="o">.</span><span class="n">put!</span><span class="p" data-group-id="4376939983-1">(</span><span class="n">project</span><span class="p">,</span><span class="w"> </span><span class="ss">:can_edit?</span><span class="p">,</span><span class="w"> </span><span class="ss">args</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4376939983-2">[</span><span class="ss">user</span><span class="p">:</span><span class="w"> </span><span class="n">current_user</span><span class="p" data-group-id="4376939983-2">]</span><span class="p" data-group-id="4376939983-1">)</span></code></pre></li><li><strong>extra_rules</strong> (module or list of modules) can be used to add context-specific rules that are
not defined directly on the subject. This can be used to structure rules into their own modules
and use them only where needed.</li><li><strong>debug?</strong> (boolean) makes Dx print additional information to the console as rules are evaluated.
Should only be used while debugging.</li></ul><h2 id="conditions" class="section-heading">
  <a href="#conditions" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Conditions</span>
</h2>
<p>In a rule condition, the part after <code class="inline">when: ...</code>,</p><ul><li><strong>Maps</strong> represent multiple conditions, of which <strong>all</strong> need to be satisfied (logical <code class="inline">AND</code>).</li><li><strong>Lists</strong> represent multiple conditions, of which <strong>at least one</strong> needs to be satisfied (logical <code class="inline">OR</code>).</li><li>Values can be negated using <code class="inline">{:not, &quot;value&quot;}</code>.</li></ul><p>Examples:</p><pre><code class="makeup elixir" translate="no"><span class="c1"># :role must be &quot;admin&quot;</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">role</span><span class="p">:</span><span class="w"> </span><span class="ss">:admin</span><span class="p">,</span><span class="w"> </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4392029978-1">%{</span><span class="ss">role</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;admin&quot;</span><span class="p" data-group-id="4392029978-1">}</span><span class="w">

</span><span class="c1"># :role must be either &quot;admin&quot; or &quot;superadmin&quot;</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">role</span><span class="p">:</span><span class="w"> </span><span class="ss">:admin</span><span class="p">,</span><span class="w"> </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4392029978-2">%{</span><span class="ss">role</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4392029978-3">[</span><span class="s">&quot;admin&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;superadmin&quot;</span><span class="p" data-group-id="4392029978-3">]</span><span class="p" data-group-id="4392029978-2">}</span><span class="w">

</span><span class="c1"># :role must be &quot;admin&quot; and :verified? must be true</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">role</span><span class="p">:</span><span class="w"> </span><span class="ss">:admin</span><span class="p">,</span><span class="w"> </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4392029978-4">%{</span><span class="ss">role</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;admin&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">verified?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="4392029978-4">}</span><span class="w">

</span><span class="c1"># :role must be &quot;admin&quot; and :verified_at must not be nil</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">role</span><span class="p">:</span><span class="w"> </span><span class="ss">:admin</span><span class="p">,</span><span class="w"> </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4392029978-5">%{</span><span class="ss">role</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;admin&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">verified_at</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4392029978-6">{</span><span class="ss">:not</span><span class="p">,</span><span class="w"> </span><span class="no">nil</span><span class="p" data-group-id="4392029978-6">}</span><span class="p" data-group-id="4392029978-5">}</span></code></pre><h3 id="boolean-shorthand-form" class="section-heading">
  <a href="#boolean-shorthand-form" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Boolean shorthand form</span>
</h3>
<p>A single atom is a shorthand for <code class="inline">%{atom: true}</code>.</p><h3 id="conditions-on-list-data" class="section-heading">
  <a href="#conditions-on-list-data" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Conditions on list data</span>
</h3>
<p>When conditions are tested against list data, e.g. a person's list of roles, the condition is satisfied
if at least one element of the list matches the given conditions (like <a href="https://hexdocs.pm/elixir/Enum.html#any?/2"><code class="inline">Enum.any?/2</code></a>).</p><p>Although they might look similar, it's important to differentiate between lists that appear in
conditions, and lists that appear in the data, which are checked against a condition.</p><p>When both occur together, i.e. a list in a condition is checked against a list of values, the condition
is met if at least one of the condition list elements applies to at least one element of the value list.</p><p>For example:</p><pre><code class="makeup elixir" translate="no"><span class="n">infer</span><span class="w"> </span><span class="ss">:can_edit?</span><span class="p">,</span><span class="w"> </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7106565345-1">%{</span><span class="ss">roles</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7106565345-2">[</span><span class="s">&quot;project_manager&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;admin&quot;</span><span class="p" data-group-id="7106565345-2">]</span><span class="p" data-group-id="7106565345-1">}</span><span class="w">

</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="7106565345-3">%</span><span class="nc" data-group-id="7106565345-3">Person</span><span class="p" data-group-id="7106565345-3">{</span><span class="ss">roles</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7106565345-4">[</span><span class="s">&quot;worker&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;assistant&quot;</span><span class="p" data-group-id="7106565345-4">]</span><span class="p" data-group-id="7106565345-3">}</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Dx</span><span class="o">.</span><span class="n">get!</span><span class="p" data-group-id="7106565345-5">(</span><span class="ss">:can_edit?</span><span class="p" data-group-id="7106565345-5">)</span><span class="w">
</span><span class="no">nil</span><span class="w">

</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="7106565345-6">%</span><span class="nc" data-group-id="7106565345-6">Person</span><span class="p" data-group-id="7106565345-6">{</span><span class="ss">roles</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7106565345-7">[</span><span class="s">&quot;assistant&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;project_manager&quot;</span><span class="p" data-group-id="7106565345-7">]</span><span class="p" data-group-id="7106565345-6">}</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Dx</span><span class="o">.</span><span class="n">get!</span><span class="p" data-group-id="7106565345-8">(</span><span class="ss">:can_edit?</span><span class="p" data-group-id="7106565345-8">)</span><span class="w">
</span><span class="no">true</span><span class="w">

</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="7106565345-9">%</span><span class="nc" data-group-id="7106565345-9">Person</span><span class="p" data-group-id="7106565345-9">{</span><span class="ss">roles</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7106565345-10">[</span><span class="s">&quot;admin&quot;</span><span class="p" data-group-id="7106565345-10">]</span><span class="p" data-group-id="7106565345-9">}</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Dx</span><span class="o">.</span><span class="n">get!</span><span class="p" data-group-id="7106565345-11">(</span><span class="ss">:can_edit?</span><span class="p" data-group-id="7106565345-11">)</span><span class="w">
</span><span class="no">true</span></code></pre><p>The same applies to complex conditions.</p><h2 id="rule-results" class="section-heading">
  <a href="#rule-results" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Rule results</span>
</h2>
<p>The assigned value of a predicate is generally assigned as is.</p><p>A few special tuples, however, will be replaced by Dx (see <em>Features</em> below)</p><p>Example:</p><pre><code class="makeup elixir" translate="no"><span class="n">infer</span><span class="w"> </span><span class="ss">d</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">nested</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3802090921-1">%{</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="ss">c</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3802090921-2">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="ss">:d</span><span class="p" data-group-id="3802090921-2">}</span><span class="p" data-group-id="3802090921-1">}</span><span class="w">  </span><span class="c1"># =&gt; %{a: 1, b: 2, c: 4}</span></code></pre><h2 id="references" class="section-heading">
  <a href="#references" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">References</span>
</h2>
<p>Syntax:</p><ul><li><code class="inline">{:ref, path}</code> (in conditions and result values)</li></ul><p>Arguments:</p><ul><li><strong>path</strong> is a list of fields or predicates, starting from the subject.
The brackets can be omitted (i.a. an atom passed), if the path consists of one element.
The last element can be a map or list (see <em>Branching</em> below)</li></ul><p>Example:</p><pre><code class="makeup elixir" translate="no"><span class="n">infer</span><span class="w"> </span><span class="ss">ot_fields</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1637890483-1">%{</span><span class="ss">editable</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="1637890483-1">}</span><span class="p">,</span><span class="w">
    </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1637890483-2">%{</span><span class="w">
      </span><span class="ss">construction_bectu?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p">,</span><span class="w">
      </span><span class="ss">roles</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1637890483-3">%{</span><span class="w">
        </span><span class="ss">user</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1637890483-4">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1637890483-5">[</span><span class="ss">:args</span><span class="p">,</span><span class="w"> </span><span class="ss">:user</span><span class="p" data-group-id="1637890483-5">]</span><span class="p" data-group-id="1637890483-4">}</span><span class="p">,</span><span class="w">
        </span><span class="ss">type</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1637890483-6">[</span><span class="s">&quot;project_manager&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;admin&quot;</span><span class="p" data-group-id="1637890483-6">]</span><span class="w">
      </span><span class="p" data-group-id="1637890483-3">}</span><span class="w">
    </span><span class="p" data-group-id="1637890483-2">}</span></code></pre><h3 id="branching" class="section-heading">
  <a href="#branching" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Branching</span>
</h3>
<p>Any part of the <code class="inline">path</code> that represents an underlying <strong>list of subjects</strong>, such as referencing
a <code class="inline">has_many</code> association, will cause the result of the <code class="inline">:ref</code> to be a list as well.
It basically behaves similar to <a href="https://hexdocs.pm/elixir/Enum.html#map/2"><code class="inline">Enum.map/2</code></a>.</p><p>A <strong>map</strong> as last element of a <code class="inline">path</code> will branch the returned result out into this map.
The keys are returned as is, the values must be a list (or atom) continuing that path.
This is particularly powerful when used on a list of subjects (see above), because it
will return the given map with the values at the given paths for each underlying subject:</p><p>A <strong>list</strong> as last element of a <code class="inline">path</code> behaves like a map where each value equals its key.</p><p>Examples:</p><pre><code class="makeup elixir" translate="no"><span class="n">infer</span><span class="w"> </span><span class="ss">list</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1730346489-1">[</span><span class="p" data-group-id="1730346489-2">%{</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="ss">c</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1730346489-3">%{</span><span class="ss">d</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="p" data-group-id="1730346489-3">}</span><span class="p" data-group-id="1730346489-2">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1730346489-4">%{</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="ss">c</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1730346489-5">%{</span><span class="ss">d</span><span class="p">:</span><span class="w"> </span><span class="mi">6</span><span class="p" data-group-id="1730346489-5">}</span><span class="p" data-group-id="1730346489-4">}</span><span class="p" data-group-id="1730346489-1">]</span><span class="w">

</span><span class="n">infer</span><span class="w"> </span><span class="ss">result1</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1730346489-6">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1730346489-7">[</span><span class="ss">:list</span><span class="p">,</span><span class="w"> </span><span class="ss">:a</span><span class="p" data-group-id="1730346489-7">]</span><span class="p" data-group-id="1730346489-6">}</span><span class="w">  </span><span class="c1"># =&gt; [1, 9]</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">result2</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1730346489-8">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1730346489-9">[</span><span class="ss">:list</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1730346489-10">%{</span><span class="ss">x</span><span class="p">:</span><span class="w"> </span><span class="ss">:a</span><span class="p">,</span><span class="w"> </span><span class="ss">y</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1730346489-11">[</span><span class="ss">:c</span><span class="p">,</span><span class="w"> </span><span class="ss">:d</span><span class="p" data-group-id="1730346489-11">]</span><span class="p" data-group-id="1730346489-10">}</span><span class="p" data-group-id="1730346489-9">]</span><span class="p" data-group-id="1730346489-8">}</span><span class="w">  </span><span class="c1"># =&gt; [%{x: 1, y: 4}, %{x: 9, y: 6}]</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">result3</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1730346489-12">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1730346489-13">[</span><span class="ss">:list</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1730346489-14">[</span><span class="ss">:a</span><span class="p">,</span><span class="w"> </span><span class="ss">:b</span><span class="p" data-group-id="1730346489-14">]</span><span class="p" data-group-id="1730346489-13">]</span><span class="p" data-group-id="1730346489-12">}</span><span class="w">  </span><span class="c1"># =&gt; [%{a: 1, b: 2}, %{a: 9, b: 8}]</span></code></pre><h2 id="arguments" class="section-heading">
  <a href="#arguments" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Arguments</span>
</h2>
<p>Passing <code class="inline">:args</code> as an option to any of the Dx API functions enables referencing the passed data
in conditions and values using <code class="inline">{:ref, [:args, ...]}</code>.</p><h2 id="overriding-existing-fields" class="section-heading">
  <a href="#overriding-existing-fields" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Overriding existing fields</span>
</h2>
<p>It's possible to give predicates the same name as existing fields in the schema.
This represents the fact that these fields are derived from other data, using rules.</p><p>Rules on these fields can even take into account the existing value of the underlying field.
In order to reference it, use <code class="inline">:fields</code> in between a path or condition, for example:</p><pre><code class="makeup elixir" translate="no"><span class="n">schema</span><span class="w"> </span><span class="s">&quot;blog_posts&quot;</span><span class="w"> </span><span class="k" data-group-id="1972394168-1">do</span><span class="w">
  </span><span class="n">field</span><span class="w"> </span><span class="ss">:state</span><span class="w">
  </span><span class="n">field</span><span class="w"> </span><span class="ss">:published_at</span><span class="w">
</span><span class="k" data-group-id="1972394168-1">end</span><span class="w">

</span><span class="c1"># nilify published_at when deleted, or when it&#39;s an old archived post</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">published_at</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="p">,</span><span class="w"> </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1972394168-2">%{</span><span class="ss">state</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;deleted&quot;</span><span class="p" data-group-id="1972394168-2">}</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">published_at</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="p">,</span><span class="w"> </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1972394168-3">%{</span><span class="ss">state</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;archived&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">fields</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1972394168-4">%{</span><span class="ss">published_at</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1972394168-5">{</span><span class="ss">:before</span><span class="p">,</span><span class="w"> </span><span class="ld">~D[2020-02-20]</span><span class="p" data-group-id="1972394168-5">}</span><span class="p" data-group-id="1972394168-4">}</span><span class="p" data-group-id="1972394168-3">}</span><span class="w">
</span><span class="n">infer</span><span class="w"> </span><span class="ss">published_at</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1972394168-6">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1972394168-7">[</span><span class="ss">:fields</span><span class="p">,</span><span class="w"> </span><span class="ss">:published_at</span><span class="p" data-group-id="1972394168-7">]</span><span class="p" data-group-id="1972394168-6">}</span></code></pre><p>While it's always possible to achieve a similar behavior by giving the predicate a different
name than the field, and then mapping the predicate to the field somewhere else,
using the field name in conjunction with <code class="inline">:fields</code> makes explicit that it's a conditional override.</p><h2 id="binding-subject-parts" class="section-heading">
  <a href="#binding-subject-parts" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Binding subject parts</span>
</h2>
<p>Syntax:</p><ul><li><code class="inline">{:bind, key}</code> (in conditions)</li><li><code class="inline">{:bind, key, subcondition}</code> (in conditions)</li><li><code class="inline">{:bound, key}</code> (in result values)</li><li><code class="inline">{:bound, key, default}</code> (in result values)</li></ul><p>When a condition is evaluated on a list of values, the <strong>first value</strong> satisfying
the condition can be bound to a variable using <code class="inline">{:bind, variable}</code>.</p><p>These bound values can be referenced using <code class="inline">{:bound, key}</code> with an optional default:
<code class="inline">{:bound, key, default}</code>.</p><pre><code class="makeup elixir" translate="no"><span class="n">infer</span><span class="w"> </span><span class="ss">project_manager</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0740829260-1">{</span><span class="ss">:bound</span><span class="p">,</span><span class="w"> </span><span class="ss">:person</span><span class="p" data-group-id="0740829260-1">}</span><span class="p">,</span><span class="w">
    </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0740829260-2">%{</span><span class="ss">roles</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0740829260-3">%{</span><span class="ss">type</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;project_manager&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">person</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0740829260-4">{</span><span class="ss">:bind</span><span class="p">,</span><span class="w"> </span><span class="ss">:person</span><span class="p" data-group-id="0740829260-4">}</span><span class="p" data-group-id="0740829260-3">}</span><span class="p" data-group-id="0740829260-2">}</span></code></pre><h2 id="local-aliases" class="section-heading">
  <a href="#local-aliases" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Local aliases</span>
</h2>
<p>Syntax:</p><ul><li><code class="inline">infer_alias key: ...</code> (in modules before using <code class="inline">key</code> in <code class="inline">infer ...</code>)</li></ul><p>In order to create shorthands and avoid repetition, aliases can be defined.
These apply only to subsequent rules within the same module and are not exposed in any other way.</p><pre><code class="makeup elixir" translate="no"><span class="n">infer_alias</span><span class="w"> </span><span class="ss">pm?</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6553625770-1">%{</span><span class="ss">roles</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6553625770-2">%{</span><span class="ss">type</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6553625770-3">[</span><span class="s">&quot;project_manager&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">admin</span><span class="p" data-group-id="6553625770-3">]</span><span class="p" data-group-id="6553625770-2">}</span><span class="p" data-group-id="6553625770-1">}</span><span class="w">

</span><span class="n">infer</span><span class="w"> </span><span class="ss">ot_fields</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6553625770-4">%{</span><span class="ss">editable</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="6553625770-4">}</span><span class="p">,</span><span class="w"> </span><span class="ss">when</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6553625770-5">[</span><span class="ss">:pm?</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6553625770-6">%{</span><span class="ss">construction_bectu?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="6553625770-6">}</span><span class="p" data-group-id="6553625770-5">]</span></code></pre><h2 id="calling-functions" class="section-heading">
  <a href="#calling-functions" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Calling functions</span>
</h2>
<p>Syntax:</p><ul><li><code class="inline">{&amp;module.fun/n, [arg_1, ..., arg_n]}</code> (in result values)</li><li><code class="inline">{&amp;module.fun/1, arg_1}</code> (in result values)</li></ul><p>Any function can be called to map the given arguments to other values.
The function arguments must be passed as a list, except if it's only one.
Arguments can be fixed values or other Dx features (passed as is), such as references.</p><pre><code class="makeup elixir" translate="no"><span class="n">infer</span><span class="w"> </span><span class="ss">day_of_week</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7685980897-1">{</span><span class="o">&amp;</span><span class="nc">Date</span><span class="o">.</span><span class="n">day_of_week</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7685980897-2">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="ss">:date</span><span class="p" data-group-id="7685980897-2">}</span><span class="p" data-group-id="7685980897-1">}</span><span class="w">

</span><span class="n">infer</span><span class="w"> </span><span class="ss">duration</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7685980897-3">{</span><span class="o">&amp;</span><span class="nc">Timex</span><span class="o">.</span><span class="n">diff</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7685980897-4">[</span><span class="p" data-group-id="7685980897-5">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="ss">:start_datetime</span><span class="p" data-group-id="7685980897-5">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7685980897-6">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="ss">:end_datetime</span><span class="p" data-group-id="7685980897-6">}</span><span class="p">,</span><span class="w"> </span><span class="ss">:hours</span><span class="p" data-group-id="7685980897-4">]</span><span class="p" data-group-id="7685980897-3">}</span></code></pre><p>Only pure functions with low overhead should be used.
Dx might call them very often during evaluation (once after each loading of data).</p><h2 id="querying" class="section-heading">
  <a href="#querying" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Querying</span>
</h2>
<p>Syntax:</p><ul><li><code class="inline">{:query_one, type, conditions}</code></li><li><code class="inline">{:query_one, type, conditions, options}</code></li><li><code class="inline">{:query_first, type, conditions}</code></li><li><code class="inline">{:query_first, type, conditions, options}</code></li><li><code class="inline">{:query_all, type, conditions}</code></li><li><code class="inline">{:query_all, type, conditions, options}</code></li></ul><p>Arguments:</p><ul><li><code class="inline">type</code> is a module name (or Ecto queryable), e.g. an Ecto schema</li><li><code class="inline">conditions</code> is a <strong>keyword list</strong> of fields and their respective values, or lists of values, they must match</li><li><code class="inline">options</code> is a subset of the options that Ecto queries support:<ul><li><code class="inline">order_by</code></li><li><code class="inline">limit</code></li></ul></li></ul><h3 id="conditions-1" class="section-heading">
  <a href="#conditions-1" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Conditions</span>
</h3>
<p>The first key-value pair has a special behavior:
It is used as the main condition for <a href="https://hexdocs.pm/dataloader/2.0.0/Dataloader.html"><code class="inline">Dataloader</code></a>, and thus should have the highest cardinality.
It must be a single value, not a list of values.</p><p><em>Rule of thumb:</em> Put a single field that has the most unique values as first condition.</p><h2 id="transforming-lists" class="section-heading">
  <a href="#transforming-lists" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Transforming lists</span>
</h2>
<p>Syntax:</p><ul><li><code class="inline">{:filter, source, condition}</code> (in result values)</li><li><code class="inline">{:map, source, mapper}</code> (in result values)</li><li><code class="inline">{:map, source, bind_key/condition, mapper}</code> (in result values)</li></ul><p>Arguments:</p><ul><li><code class="inline">source</code> can either be a list literal, a field or predicate that evaluates to a list,
or another feature such as a query.</li><li><code class="inline">condition</code> has the same form and functionality as any other rule condition.</li><li><code class="inline">mapper</code> can either be a field or predicate (atom), or is otherwise treated as any other rule value.</li></ul><p>There are 3 variants:</p><ul><li><code class="inline">{:filter, source, condition}</code> keeps only elements from <code class="inline">source</code>, for which the <code class="inline">condition</code> is met.</li><li><code class="inline">{:map, source, mapper}</code> returns the result of <code class="inline">mapper</code> for each element in <code class="inline">source</code>.</li><li><code class="inline">{:map, source, bind_key/condition, mapper}</code> is a special form of <code class="inline">:map</code>, where the <code class="inline">mapper</code> is based on the
subject of the rule, not the list element. The list element is referenced using the middle arg, which can be either:<ul><li>a <code class="inline">bind_key</code> (atom) - the current list element is referenced via <code class="inline">{:bound, bind_key}</code> in the <code class="inline">mapper</code></li><li>a <code class="inline">condition</code> - any values bound in the condition via <code class="inline">{:bind, key, ...}</code> can be accessed
via <code class="inline">{:bound, key}</code> in the <code class="inline">mapper</code></li></ul></li></ul><p>Use the special form of <code class="inline">:map</code> only when you need to reference both the list element (via <code class="inline">:bound</code>),
and the subject of the rule (via <code class="inline">:ref</code>).
Using a combination of <code class="inline">:filter</code> and basic <code class="inline">:map</code> instead is always preferred, if possible.</p><p>Any <code class="inline">nil</code> elements in the list are mapped to <code class="inline">nil</code>, when using <code class="inline">:map</code> without condition.</p><p>Examples:</p><pre><code class="makeup elixir" translate="no"><span class="n">infer</span><span class="w"> </span><span class="ss">accepted_offers</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3303949608-1">{</span><span class="ss">:filter</span><span class="p">,</span><span class="w"> </span><span class="ss">:offers</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3303949608-2">%{</span><span class="ss">state</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;accepted&quot;</span><span class="p" data-group-id="3303949608-2">}</span><span class="p" data-group-id="3303949608-1">}</span><span class="w">

</span><span class="n">infer</span><span class="w"> </span><span class="ss">offer_ids</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3303949608-3">{</span><span class="ss">:map</span><span class="p">,</span><span class="w"> </span><span class="ss">:offers</span><span class="p">,</span><span class="w"> </span><span class="ss">:id</span><span class="p" data-group-id="3303949608-3">}</span><span class="w">

</span><span class="n">infer</span><span class="w"> </span><span class="ss">first_offer_of_same_user</span><span class="p">:</span><span class="w">
        </span><span class="p" data-group-id="3303949608-4">{</span><span class="ss">:map</span><span class="p">,</span><span class="w"> </span><span class="ss">:offers</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3303949608-5">%{</span><span class="ss">state</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;accepted&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">user_id</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3303949608-6">{</span><span class="ss">:bind</span><span class="p">,</span><span class="w"> </span><span class="ss">:uid</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3303949608-7">{</span><span class="ss">:not</span><span class="p">,</span><span class="w"> </span><span class="no">nil</span><span class="p" data-group-id="3303949608-7">}</span><span class="p" data-group-id="3303949608-6">}</span><span class="p" data-group-id="3303949608-5">}</span><span class="p">,</span><span class="w">
         </span><span class="p" data-group-id="3303949608-8">{</span><span class="ss">:query_first</span><span class="p">,</span><span class="w"> </span><span class="nc">Offer</span><span class="p">,</span><span class="w"> </span><span class="ss">user_id</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3303949608-9">{</span><span class="ss">:bound</span><span class="p">,</span><span class="w"> </span><span class="ss">:uid</span><span class="p" data-group-id="3303949608-9">}</span><span class="p">,</span><span class="w"> </span><span class="ss">project_id</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3303949608-10">{</span><span class="ss">:ref</span><span class="p">,</span><span class="w"> </span><span class="ss">:project_id</span><span class="p" data-group-id="3303949608-10">}</span><span class="p" data-group-id="3303949608-8">}</span><span class="p" data-group-id="3303949608-4">}</span></code></pre><h2 id="counting" class="section-heading">
  <a href="#counting" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Counting</span>
</h2>
<p>Syntax:</p><ul><li><code class="inline">{:count, source, condition/predicate}</code> (in result values)</li><li><code class="inline">{:count_while, source, condition/predicate}</code> (in result values)</li></ul><p>Arguments:</p><ul><li><code class="inline">source</code> can either be a list literal, a field or predicate that evaluates to a list,
or another feature such as a query.</li><li><code class="inline">condition</code> has the same form and functionality as any other rule condition.</li><li><code class="inline">predicate</code> can either be a predicate (atom) that returns either <code class="inline">true</code>, <code class="inline">false</code>,
or <code class="inline">:skip</code> (only for <code class="inline">:count_while</code>)</li></ul><p>Takes the given list and counts the elements that evaluate to <code class="inline">true</code>.
<code class="inline">:count_while</code> stops after the first element that returns <code class="inline">false</code>.
To not count an element, but not stop counting either, the given predicate may return <code class="inline">:skip</code>.
Any <code class="inline">nil</code> elements in the list are treated as <code class="inline">false</code>.</p>
</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="api-reference.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
API Reference
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="welcome.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
Welcome 👋
        </span>
      </a>

  </div>
</div>
    <footer class="footer">
      <p>

          <span class="line">
            <a href="https://hex.pm/packages/dx/0.0.0" class="footer-hex-package">Hex Package</a>

            <a href="https://preview.hex.pm/preview/dx/0.0.0">Hex Preview</a>

              (<a href="https://preview.hex.pm/preview/dx/0.0.0/show/docs/full_reference.md">current file</a>)

          </span>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

            <a href="dx.epub" title="ePub version">
              Download ePub version
            </a>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.34.2) for the

          <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a>

      </p>

    </footer>
  </div>
</main>
</div>

  </body>
</html>
